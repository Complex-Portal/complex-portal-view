{"version":3,"sources":["node_modules/@angular/cdk/fesm2022/collections.mjs","node_modules/@angular/cdk/fesm2022/scrolling.mjs","node_modules/@angular/cdk/fesm2022/portal.mjs","node_modules/@angular/cdk/fesm2022/overlay.mjs","node_modules/@angular/material/fesm2022/tooltip.mjs"],"sourcesContent":["import { ConnectableObservable, isObservable, of, Subject } from 'rxjs';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable } from '@angular/core';\nclass DataSource {}\n/** Checks whether an object is a data source. */\nfunction isDataSource(value) {\n  // Check if the value is a DataSource by observing if it has a connect function. Cannot\n  // be checked as an `instanceof DataSource` since people could create their own sources\n  // that match the interface, but don't extend DataSource. We also can't use `isObservable`\n  // here, because of some internal apps.\n  return value && typeof value.connect === 'function' && !(value instanceof ConnectableObservable);\n}\n\n/** DataSource wrapper for a native array. */\nclass ArrayDataSource extends DataSource {\n  constructor(_data) {\n    super();\n    this._data = _data;\n  }\n  connect() {\n    return isObservable(this._data) ? this._data : of(this._data);\n  }\n  disconnect() {}\n}\n\n/** Indicates how a view was changed by a {@link _ViewRepeater}. */\nvar _ViewRepeaterOperation;\n(function (_ViewRepeaterOperation) {\n  /** The content of an existing view was replaced with another item. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"REPLACED\"] = 0] = \"REPLACED\";\n  /** A new view was created with `createEmbeddedView`. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"INSERTED\"] = 1] = \"INSERTED\";\n  /** The position of a view changed, but the content remains the same. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"MOVED\"] = 2] = \"MOVED\";\n  /** A view was detached from the view container. */\n  _ViewRepeaterOperation[_ViewRepeaterOperation[\"REMOVED\"] = 3] = \"REMOVED\";\n})(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));\n/**\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\n * @docs-private\n */\nconst _VIEW_REPEATER_STRATEGY = new InjectionToken('_ViewRepeater');\n\n/**\n * A repeater that destroys views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will always construct a new embedded view for each item.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _DisposeViewRepeaterStrategy {\n  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n      let view;\n      let operation;\n      if (record.previousIndex == null) {\n        const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n        view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);\n        operation = _ViewRepeaterOperation.INSERTED;\n      } else if (currentIndex == null) {\n        viewContainerRef.remove(adjustedPreviousIndex);\n        operation = _ViewRepeaterOperation.REMOVED;\n      } else {\n        view = viewContainerRef.get(adjustedPreviousIndex);\n        viewContainerRef.move(view, currentIndex);\n        operation = _ViewRepeaterOperation.MOVED;\n      }\n      if (itemViewChanged) {\n        itemViewChanged({\n          context: view?.context,\n          operation,\n          record\n        });\n      }\n    });\n  }\n  detach() {}\n}\n\n/**\n * A repeater that caches views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _RecycleViewRepeaterStrategy {\n  constructor() {\n    /**\n     * The size of the cache used to store unused views.\n     * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n     */\n    this.viewCacheSize = 20;\n    /**\n     * View cache that stores embedded view instances that have been previously stamped out,\n     * but don't are not currently rendered. The view repeater will reuse these views rather than\n     * creating brand new ones.\n     *\n     * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n     */\n    this._viewCache = [];\n  }\n  /** Apply changes to the DOM. */\n  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n    // Rearrange the views to put them in the right location.\n    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n      let view;\n      let operation;\n      if (record.previousIndex == null) {\n        // Item added.\n        const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\n        operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;\n      } else if (currentIndex == null) {\n        // Item removed.\n        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\n        operation = _ViewRepeaterOperation.REMOVED;\n      } else {\n        // Item moved.\n        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\n        operation = _ViewRepeaterOperation.MOVED;\n      }\n      if (itemViewChanged) {\n        itemViewChanged({\n          context: view?.context,\n          operation,\n          record\n        });\n      }\n    });\n  }\n  detach() {\n    for (const view of this._viewCache) {\n      view.destroy();\n    }\n    this._viewCache = [];\n  }\n  /**\n   * Inserts a view for a new item, either from the cache or by creating a new\n   * one. Returns `undefined` if the item was inserted into a cached view.\n   */\n  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\n    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\n    if (cachedView) {\n      cachedView.context.$implicit = value;\n      return undefined;\n    }\n    const viewArgs = viewArgsFactory();\n    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\n  }\n  /** Detaches the view at the given index and inserts into the view cache. */\n  _detachAndCacheView(index, viewContainerRef) {\n    const detachedView = viewContainerRef.detach(index);\n    this._maybeCacheView(detachedView, viewContainerRef);\n  }\n  /** Moves view at the previous index to the current index. */\n  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\n    const view = viewContainerRef.get(adjustedPreviousIndex);\n    viewContainerRef.move(view, currentIndex);\n    view.context.$implicit = value;\n    return view;\n  }\n  /**\n   * Cache the given detached view. If the cache is full, the view will be\n   * destroyed.\n   */\n  _maybeCacheView(view, viewContainerRef) {\n    if (this._viewCache.length < this.viewCacheSize) {\n      this._viewCache.push(view);\n    } else {\n      const index = viewContainerRef.indexOf(view);\n      // The host component could remove views from the container outside of\n      // the view repeater. It's unlikely this will occur, but just in case,\n      // destroy the view on its own, otherwise destroy it through the\n      // container to ensure that all the references are removed.\n      if (index === -1) {\n        view.destroy();\n      } else {\n        viewContainerRef.remove(index);\n      }\n    }\n  }\n  /** Inserts a recycled view from the cache at the given index. */\n  _insertViewFromCache(index, viewContainerRef) {\n    const cachedView = this._viewCache.pop();\n    if (cachedView) {\n      viewContainerRef.insert(cachedView, index);\n    }\n    return cachedView || null;\n  }\n}\n\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nclass SelectionModel {\n  /** Selected values. */\n  get selected() {\n    if (!this._selected) {\n      this._selected = Array.from(this._selection.values());\n    }\n    return this._selected;\n  }\n  constructor(_multiple = false, initiallySelectedValues, _emitChanges = true, compareWith) {\n    this._multiple = _multiple;\n    this._emitChanges = _emitChanges;\n    this.compareWith = compareWith;\n    /** Currently-selected values. */\n    this._selection = new Set();\n    /** Keeps track of the deselected options that haven't been emitted by the change event. */\n    this._deselectedToEmit = [];\n    /** Keeps track of the selected options that haven't been emitted by the change event. */\n    this._selectedToEmit = [];\n    /** Event emitted when the value has changed. */\n    this.changed = new Subject();\n    if (initiallySelectedValues && initiallySelectedValues.length) {\n      if (_multiple) {\n        initiallySelectedValues.forEach(value => this._markSelected(value));\n      } else {\n        this._markSelected(initiallySelectedValues[0]);\n      }\n      // Clear the array in order to avoid firing the change event for preselected values.\n      this._selectedToEmit.length = 0;\n    }\n  }\n  /**\n   * Selects a value or an array of values.\n   * @param values The values to select\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  select(...values) {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._markSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n  /**\n   * Deselects a value or an array of values.\n   * @param values The values to deselect\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  deselect(...values) {\n    this._verifyValueAssignment(values);\n    values.forEach(value => this._unmarkSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n  /**\n   * Sets the selected values\n   * @param values The new selected values\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  setSelection(...values) {\n    this._verifyValueAssignment(values);\n    const oldValues = this.selected;\n    const newSelectedSet = new Set(values);\n    values.forEach(value => this._markSelected(value));\n    oldValues.filter(value => !newSelectedSet.has(this._getConcreteValue(value, newSelectedSet))).forEach(value => this._unmarkSelected(value));\n    const changed = this._hasQueuedChanges();\n    this._emitChangeEvent();\n    return changed;\n  }\n  /**\n   * Toggles a value between selected and deselected.\n   * @param value The value to toggle\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  toggle(value) {\n    return this.isSelected(value) ? this.deselect(value) : this.select(value);\n  }\n  /**\n   * Clears all of the selected values.\n   * @param flushEvent Whether to flush the changes in an event.\n   *   If false, the changes to the selection will be flushed along with the next event.\n   * @return Whether the selection changed as a result of this call\n   * @breaking-change 16.0.0 make return type boolean\n   */\n  clear(flushEvent = true) {\n    this._unmarkAll();\n    const changed = this._hasQueuedChanges();\n    if (flushEvent) {\n      this._emitChangeEvent();\n    }\n    return changed;\n  }\n  /**\n   * Determines whether a value is selected.\n   */\n  isSelected(value) {\n    return this._selection.has(this._getConcreteValue(value));\n  }\n  /**\n   * Determines whether the model does not have a value.\n   */\n  isEmpty() {\n    return this._selection.size === 0;\n  }\n  /**\n   * Determines whether the model has a value.\n   */\n  hasValue() {\n    return !this.isEmpty();\n  }\n  /**\n   * Sorts the selected values based on a predicate function.\n   */\n  sort(predicate) {\n    if (this._multiple && this.selected) {\n      this._selected.sort(predicate);\n    }\n  }\n  /**\n   * Gets whether multiple values can be selected.\n   */\n  isMultipleSelection() {\n    return this._multiple;\n  }\n  /** Emits a change event and clears the records of selected and deselected values. */\n  _emitChangeEvent() {\n    // Clear the selected values so they can be re-cached.\n    this._selected = null;\n    if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n      this.changed.next({\n        source: this,\n        added: this._selectedToEmit,\n        removed: this._deselectedToEmit\n      });\n      this._deselectedToEmit = [];\n      this._selectedToEmit = [];\n    }\n  }\n  /** Selects a value. */\n  _markSelected(value) {\n    value = this._getConcreteValue(value);\n    if (!this.isSelected(value)) {\n      if (!this._multiple) {\n        this._unmarkAll();\n      }\n      if (!this.isSelected(value)) {\n        this._selection.add(value);\n      }\n      if (this._emitChanges) {\n        this._selectedToEmit.push(value);\n      }\n    }\n  }\n  /** Deselects a value. */\n  _unmarkSelected(value) {\n    value = this._getConcreteValue(value);\n    if (this.isSelected(value)) {\n      this._selection.delete(value);\n      if (this._emitChanges) {\n        this._deselectedToEmit.push(value);\n      }\n    }\n  }\n  /** Clears out the selected values. */\n  _unmarkAll() {\n    if (!this.isEmpty()) {\n      this._selection.forEach(value => this._unmarkSelected(value));\n    }\n  }\n  /**\n   * Verifies the value assignment and throws an error if the specified value array is\n   * including multiple values while the selection model is not supporting multiple values.\n   */\n  _verifyValueAssignment(values) {\n    if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMultipleValuesInSingleSelectionError();\n    }\n  }\n  /** Whether there are queued up change to be emitted. */\n  _hasQueuedChanges() {\n    return !!(this._deselectedToEmit.length || this._selectedToEmit.length);\n  }\n  /** Returns a value that is comparable to inputValue by applying compareWith function, returns the same inputValue otherwise. */\n  _getConcreteValue(inputValue, selection) {\n    if (!this.compareWith) {\n      return inputValue;\n    } else {\n      selection = selection ?? this._selection;\n      for (let selectedValue of selection) {\n        if (this.compareWith(inputValue, selectedValue)) {\n          return selectedValue;\n        }\n      }\n      return inputValue;\n    }\n  }\n}\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nfunction getMultipleValuesInSingleSelectionError() {\n  return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\nclass UniqueSelectionDispatcher {\n  constructor() {\n    this._listeners = [];\n  }\n  /**\n   * Notify other items that selection for the given name has been set.\n   * @param id ID of the item.\n   * @param name Name of the item.\n   */\n  notify(id, name) {\n    for (let listener of this._listeners) {\n      listener(id, name);\n    }\n  }\n  /**\n   * Listen for future changes to item selection.\n   * @return Function used to deregister listener\n   */\n  listen(listener) {\n    this._listeners.push(listener);\n    return () => {\n      this._listeners = this._listeners.filter(registered => {\n        return listener !== registered;\n      });\n    };\n  }\n  ngOnDestroy() {\n    this._listeners = [];\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: UniqueSelectionDispatcher,\n      deps: [],\n      target: i0.ɵɵFactoryTarget.Injectable\n    });\n  }\n  static {\n    this.ɵprov = i0.ɵɵngDeclareInjectable({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: UniqueSelectionDispatcher,\n      providedIn: 'root'\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: UniqueSelectionDispatcher,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }]\n});\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ArrayDataSource, DataSource, SelectionModel, UniqueSelectionDispatcher, _DisposeViewRepeaterStrategy, _RecycleViewRepeaterStrategy, _VIEW_REPEATER_STRATEGY, _ViewRepeaterOperation, getMultipleValuesInSingleSelectionError, isDataSource };\n","import { coerceNumberProperty, coerceElement } from '@angular/cdk/coercion';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, forwardRef, Directive, Input, Injectable, Optional, Inject, inject, Injector, afterNextRender, booleanAttribute, Component, ViewEncapsulation, ChangeDetectionStrategy, Output, ViewChild, SkipSelf, ElementRef, NgModule } from '@angular/core';\nimport { Subject, of, Observable, fromEvent, animationFrameScheduler, asapScheduler, Subscription, isObservable } from 'rxjs';\nimport { distinctUntilChanged, auditTime, filter, takeUntil, startWith, pairwise, switchMap, shareReplay } from 'rxjs/operators';\nimport * as i1 from '@angular/cdk/platform';\nimport { getRtlScrollAxisType, RtlScrollAxisType, supportsScrollBehavior, Platform } from '@angular/cdk/platform';\nimport { DOCUMENT } from '@angular/common';\nimport * as i2 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport * as i2$1 from '@angular/cdk/collections';\nimport { isDataSource, ArrayDataSource, _VIEW_REPEATER_STRATEGY, _RecycleViewRepeaterStrategy } from '@angular/cdk/collections';\n\n/** The injection token used to specify the virtual scrolling strategy. */\nconst VIRTUAL_SCROLL_STRATEGY = new InjectionToken('VIRTUAL_SCROLL_STRATEGY');\n\n/** Virtual scrolling strategy for lists with items of known fixed size. */\nclass FixedSizeVirtualScrollStrategy {\n  /**\n   * @param itemSize The size of the items in the virtually scrolling list.\n   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n   */\n  constructor(itemSize, minBufferPx, maxBufferPx) {\n    this._scrolledIndexChange = new Subject();\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());\n    /** The attached viewport. */\n    this._viewport = null;\n    this._itemSize = itemSize;\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n  }\n  /**\n   * Attaches this scroll strategy to a viewport.\n   * @param viewport The viewport to attach this strategy to.\n   */\n  attach(viewport) {\n    this._viewport = viewport;\n    this._updateTotalContentSize();\n    this._updateRenderedRange();\n  }\n  /** Detaches this scroll strategy from the currently attached viewport. */\n  detach() {\n    this._scrolledIndexChange.complete();\n    this._viewport = null;\n  }\n  /**\n   * Update the item size and buffer size.\n   * @param itemSize The size of the items in the virtually scrolling list.\n   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n   */\n  updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\n    if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n    }\n    this._itemSize = itemSize;\n    this._minBufferPx = minBufferPx;\n    this._maxBufferPx = maxBufferPx;\n    this._updateTotalContentSize();\n    this._updateRenderedRange();\n  }\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentScrolled() {\n    this._updateRenderedRange();\n  }\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onDataLengthChanged() {\n    this._updateTotalContentSize();\n    this._updateRenderedRange();\n  }\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onContentRendered() {\n    /* no-op */\n  }\n  /** @docs-private Implemented as part of VirtualScrollStrategy. */\n  onRenderedOffsetChanged() {\n    /* no-op */\n  }\n  /**\n   * Scroll to the offset for the given index.\n   * @param index The index of the element to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling.\n   */\n  scrollToIndex(index, behavior) {\n    if (this._viewport) {\n      this._viewport.scrollToOffset(index * this._itemSize, behavior);\n    }\n  }\n  /** Update the viewport's total content size. */\n  _updateTotalContentSize() {\n    if (!this._viewport) {\n      return;\n    }\n    this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\n  }\n  /** Update the viewport's rendered range. */\n  _updateRenderedRange() {\n    if (!this._viewport) {\n      return;\n    }\n    const renderedRange = this._viewport.getRenderedRange();\n    const newRange = {\n      start: renderedRange.start,\n      end: renderedRange.end\n    };\n    const viewportSize = this._viewport.getViewportSize();\n    const dataLength = this._viewport.getDataLength();\n    let scrollOffset = this._viewport.measureScrollOffset();\n    // Prevent NaN as result when dividing by zero.\n    let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;\n    // If user scrolls to the bottom of the list and data changes to a smaller list\n    if (newRange.end > dataLength) {\n      // We have to recalculate the first visible index based on new data length and viewport size.\n      const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\n      const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));\n      // If first visible index changed we must update scroll offset to handle start/end buffers\n      // Current range must also be adjusted to cover the new position (bottom of new list).\n      if (firstVisibleIndex != newVisibleIndex) {\n        firstVisibleIndex = newVisibleIndex;\n        scrollOffset = newVisibleIndex * this._itemSize;\n        newRange.start = Math.floor(firstVisibleIndex);\n      }\n      newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\n    }\n    const startBuffer = scrollOffset - newRange.start * this._itemSize;\n    if (startBuffer < this._minBufferPx && newRange.start != 0) {\n      const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\n      newRange.start = Math.max(0, newRange.start - expandStart);\n      newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\n    } else {\n      const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\n      if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\n        const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\n        if (expandEnd > 0) {\n          newRange.end = Math.min(dataLength, newRange.end + expandEnd);\n          newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\n        }\n      }\n    }\n    this._viewport.setRenderedRange(newRange);\n    this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\n    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n  }\n}\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\n  return fixedSizeDir._scrollStrategy;\n}\n/** A virtual scroll strategy that supports fixed-size items. */\nclass CdkFixedSizeVirtualScroll {\n  constructor() {\n    this._itemSize = 20;\n    this._minBufferPx = 100;\n    this._maxBufferPx = 200;\n    /** The scroll strategy used by this directive. */\n    this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\n  }\n  /** The size of the items in the list (in pixels). */\n  get itemSize() {\n    return this._itemSize;\n  }\n  set itemSize(value) {\n    this._itemSize = coerceNumberProperty(value);\n  }\n  /**\n   * The minimum amount of buffer rendered beyond the viewport (in pixels).\n   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n   */\n  get minBufferPx() {\n    return this._minBufferPx;\n  }\n  set minBufferPx(value) {\n    this._minBufferPx = coerceNumberProperty(value);\n  }\n  /**\n   * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n   */\n  get maxBufferPx() {\n    return this._maxBufferPx;\n  }\n  set maxBufferPx(value) {\n    this._maxBufferPx = coerceNumberProperty(value);\n  }\n  ngOnChanges() {\n    this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkFixedSizeVirtualScroll,\n      deps: [],\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: CdkFixedSizeVirtualScroll,\n      isStandalone: true,\n      selector: \"cdk-virtual-scroll-viewport[itemSize]\",\n      inputs: {\n        itemSize: \"itemSize\",\n        minBufferPx: \"minBufferPx\",\n        maxBufferPx: \"maxBufferPx\"\n      },\n      providers: [{\n        provide: VIRTUAL_SCROLL_STRATEGY,\n        useFactory: _fixedSizeVirtualScrollStrategyFactory,\n        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]\n      }],\n      usesOnChanges: true,\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkFixedSizeVirtualScroll,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'cdk-virtual-scroll-viewport[itemSize]',\n      standalone: true,\n      providers: [{\n        provide: VIRTUAL_SCROLL_STRATEGY,\n        useFactory: _fixedSizeVirtualScrollStrategyFactory,\n        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]\n      }]\n    }]\n  }],\n  propDecorators: {\n    itemSize: [{\n      type: Input\n    }],\n    minBufferPx: [{\n      type: Input\n    }],\n    maxBufferPx: [{\n      type: Input\n    }]\n  }\n});\n\n/** Time in ms to throttle the scrolling events by default. */\nconst DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nclass ScrollDispatcher {\n  constructor(_ngZone, _platform, document) {\n    this._ngZone = _ngZone;\n    this._platform = _platform;\n    /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n    this._scrolled = new Subject();\n    /** Keeps track of the global `scroll` and `resize` subscriptions. */\n    this._globalSubscription = null;\n    /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n    this._scrolledCount = 0;\n    /**\n     * Map of all the scrollable references that are registered with the service and their\n     * scroll event subscriptions.\n     */\n    this.scrollContainers = new Map();\n    this._document = document;\n  }\n  /**\n   * Registers a scrollable instance with the service and listens for its scrolled events. When the\n   * scrollable is scrolled, the service emits the event to its scrolled observable.\n   * @param scrollable Scrollable instance to be registered.\n   */\n  register(scrollable) {\n    if (!this.scrollContainers.has(scrollable)) {\n      this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));\n    }\n  }\n  /**\n   * De-registers a Scrollable reference and unsubscribes from its scroll event observable.\n   * @param scrollable Scrollable instance to be deregistered.\n   */\n  deregister(scrollable) {\n    const scrollableReference = this.scrollContainers.get(scrollable);\n    if (scrollableReference) {\n      scrollableReference.unsubscribe();\n      this.scrollContainers.delete(scrollable);\n    }\n  }\n  /**\n   * Returns an observable that emits an event whenever any of the registered Scrollable\n   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n   * to override the default \"throttle\" time.\n   *\n   * **Note:** in order to avoid hitting change detection for every scroll event,\n   * all of the events emitted from this stream will be run outside the Angular zone.\n   * If you need to update any data bindings as a result of a scroll event, you have\n   * to run the callback using `NgZone.run`.\n   */\n  scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {\n    if (!this._platform.isBrowser) {\n      return of();\n    }\n    return new Observable(observer => {\n      if (!this._globalSubscription) {\n        this._addGlobalListener();\n      }\n      // In the case of a 0ms delay, use an observable without auditTime\n      // since it does add a perceptible delay in processing overhead.\n      const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);\n      this._scrolledCount++;\n      return () => {\n        subscription.unsubscribe();\n        this._scrolledCount--;\n        if (!this._scrolledCount) {\n          this._removeGlobalListener();\n        }\n      };\n    });\n  }\n  ngOnDestroy() {\n    this._removeGlobalListener();\n    this.scrollContainers.forEach((_, container) => this.deregister(container));\n    this._scrolled.complete();\n  }\n  /**\n   * Returns an observable that emits whenever any of the\n   * scrollable ancestors of an element are scrolled.\n   * @param elementOrElementRef Element whose ancestors to listen for.\n   * @param auditTimeInMs Time to throttle the scroll events.\n   */\n  ancestorScrolled(elementOrElementRef, auditTimeInMs) {\n    const ancestors = this.getAncestorScrollContainers(elementOrElementRef);\n    return this.scrolled(auditTimeInMs).pipe(filter(target => {\n      return !target || ancestors.indexOf(target) > -1;\n    }));\n  }\n  /** Returns all registered Scrollables that contain the provided element. */\n  getAncestorScrollContainers(elementOrElementRef) {\n    const scrollingContainers = [];\n    this.scrollContainers.forEach((_subscription, scrollable) => {\n      if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {\n        scrollingContainers.push(scrollable);\n      }\n    });\n    return scrollingContainers;\n  }\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  _getWindow() {\n    return this._document.defaultView || window;\n  }\n  /** Returns true if the element is contained within the provided Scrollable. */\n  _scrollableContainsElement(scrollable, elementOrElementRef) {\n    let element = coerceElement(elementOrElementRef);\n    let scrollableElement = scrollable.getElementRef().nativeElement;\n    // Traverse through the element parents until we reach null, checking if any of the elements\n    // are the scrollable's element.\n    do {\n      if (element == scrollableElement) {\n        return true;\n      }\n    } while (element = element.parentElement);\n    return false;\n  }\n  /** Sets up the global scroll listeners. */\n  _addGlobalListener() {\n    this._globalSubscription = this._ngZone.runOutsideAngular(() => {\n      const window = this._getWindow();\n      return fromEvent(window.document, 'scroll').subscribe(() => this._scrolled.next());\n    });\n  }\n  /** Cleans up the global scroll listener. */\n  _removeGlobalListener() {\n    if (this._globalSubscription) {\n      this._globalSubscription.unsubscribe();\n      this._globalSubscription = null;\n    }\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: ScrollDispatcher,\n      deps: [{\n        token: i0.NgZone\n      }, {\n        token: i1.Platform\n      }, {\n        token: DOCUMENT,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Injectable\n    });\n  }\n  static {\n    this.ɵprov = i0.ɵɵngDeclareInjectable({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: ScrollDispatcher,\n      providedIn: 'root'\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: ScrollDispatcher,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.NgZone\n  }, {\n    type: i1.Platform\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }]\n});\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nclass CdkScrollable {\n  constructor(elementRef, scrollDispatcher, ngZone, dir) {\n    this.elementRef = elementRef;\n    this.scrollDispatcher = scrollDispatcher;\n    this.ngZone = ngZone;\n    this.dir = dir;\n    this._destroyed = new Subject();\n    this._elementScrolled = new Observable(observer => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, 'scroll').pipe(takeUntil(this._destroyed)).subscribe(observer)));\n  }\n  ngOnInit() {\n    this.scrollDispatcher.register(this);\n  }\n  ngOnDestroy() {\n    this.scrollDispatcher.deregister(this);\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n  /** Returns observable that emits when a scroll event is fired on the host element. */\n  elementScrolled() {\n    return this._elementScrolled;\n  }\n  /** Gets the ElementRef for the viewport. */\n  getElementRef() {\n    return this.elementRef;\n  }\n  /**\n   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n   * left and right always refer to the left and right side of the scrolling container irrespective\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n   * in an RTL context.\n   * @param options specified the offsets to scroll to.\n   */\n  scrollTo(options) {\n    const el = this.elementRef.nativeElement;\n    const isRtl = this.dir && this.dir.value == 'rtl';\n    // Rewrite start & end offsets as right or left offsets.\n    if (options.left == null) {\n      options.left = isRtl ? options.end : options.start;\n    }\n    if (options.right == null) {\n      options.right = isRtl ? options.start : options.end;\n    }\n    // Rewrite the bottom offset as a top offset.\n    if (options.bottom != null) {\n      options.top = el.scrollHeight - el.clientHeight - options.bottom;\n    }\n    // Rewrite the right offset as a left offset.\n    if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {\n      if (options.left != null) {\n        options.right = el.scrollWidth - el.clientWidth - options.left;\n      }\n      if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\n        options.left = options.right;\n      } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\n        options.left = options.right ? -options.right : options.right;\n      }\n    } else {\n      if (options.right != null) {\n        options.left = el.scrollWidth - el.clientWidth - options.right;\n      }\n    }\n    this._applyScrollToOptions(options);\n  }\n  _applyScrollToOptions(options) {\n    const el = this.elementRef.nativeElement;\n    if (supportsScrollBehavior()) {\n      el.scrollTo(options);\n    } else {\n      if (options.top != null) {\n        el.scrollTop = options.top;\n      }\n      if (options.left != null) {\n        el.scrollLeft = options.left;\n      }\n    }\n  }\n  /**\n   * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n   * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n   * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n   * left and right always refer to the left and right side of the scrolling container irrespective\n   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n   * in an RTL context.\n   * @param from The edge to measure from.\n   */\n  measureScrollOffset(from) {\n    const LEFT = 'left';\n    const RIGHT = 'right';\n    const el = this.elementRef.nativeElement;\n    if (from == 'top') {\n      return el.scrollTop;\n    }\n    if (from == 'bottom') {\n      return el.scrollHeight - el.clientHeight - el.scrollTop;\n    }\n    // Rewrite start & end as left or right offsets.\n    const isRtl = this.dir && this.dir.value == 'rtl';\n    if (from == 'start') {\n      from = isRtl ? RIGHT : LEFT;\n    } else if (from == 'end') {\n      from = isRtl ? LEFT : RIGHT;\n    }\n    if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {\n      // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\n      // 0 when scrolled all the way right.\n      if (from == LEFT) {\n        return el.scrollWidth - el.clientWidth - el.scrollLeft;\n      } else {\n        return el.scrollLeft;\n      }\n    } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {\n      // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\n      // 0 when scrolled all the way right.\n      if (from == LEFT) {\n        return el.scrollLeft + el.scrollWidth - el.clientWidth;\n      } else {\n        return -el.scrollLeft;\n      }\n    } else {\n      // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\n      // (scrollWidth - clientWidth) when scrolled all the way right.\n      if (from == LEFT) {\n        return el.scrollLeft;\n      } else {\n        return el.scrollWidth - el.clientWidth - el.scrollLeft;\n      }\n    }\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkScrollable,\n      deps: [{\n        token: i0.ElementRef\n      }, {\n        token: ScrollDispatcher\n      }, {\n        token: i0.NgZone\n      }, {\n        token: i2.Directionality,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: CdkScrollable,\n      isStandalone: true,\n      selector: \"[cdk-scrollable], [cdkScrollable]\",\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkScrollable,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[cdk-scrollable], [cdkScrollable]',\n      standalone: true\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.ElementRef\n  }, {\n    type: ScrollDispatcher\n  }, {\n    type: i0.NgZone\n  }, {\n    type: i2.Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }]\n});\n\n/** Time in ms to throttle the resize events by default. */\nconst DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * @docs-private\n */\nclass ViewportRuler {\n  constructor(_platform, ngZone, document) {\n    this._platform = _platform;\n    /** Stream of viewport change events. */\n    this._change = new Subject();\n    /** Event listener that will be used to handle the viewport change events. */\n    this._changeListener = event => {\n      this._change.next(event);\n    };\n    this._document = document;\n    ngZone.runOutsideAngular(() => {\n      if (_platform.isBrowser) {\n        const window = this._getWindow();\n        // Note that bind the events ourselves, rather than going through something like RxJS's\n        // `fromEvent` so that we can ensure that they're bound outside of the NgZone.\n        window.addEventListener('resize', this._changeListener);\n        window.addEventListener('orientationchange', this._changeListener);\n      }\n      // Clear the cached position so that the viewport is re-measured next time it is required.\n      // We don't need to keep track of the subscription, because it is completed on destroy.\n      this.change().subscribe(() => this._viewportSize = null);\n    });\n  }\n  ngOnDestroy() {\n    if (this._platform.isBrowser) {\n      const window = this._getWindow();\n      window.removeEventListener('resize', this._changeListener);\n      window.removeEventListener('orientationchange', this._changeListener);\n    }\n    this._change.complete();\n  }\n  /** Returns the viewport's width and height. */\n  getViewportSize() {\n    if (!this._viewportSize) {\n      this._updateViewportSize();\n    }\n    const output = {\n      width: this._viewportSize.width,\n      height: this._viewportSize.height\n    };\n    // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n    if (!this._platform.isBrowser) {\n      this._viewportSize = null;\n    }\n    return output;\n  }\n  /** Gets a DOMRect for the viewport's bounds. */\n  getViewportRect() {\n    // Use the document element's bounding rect rather than the window scroll properties\n    // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n    // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n    // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n    // can disagree when the page is pinch-zoomed (on devices that support touch).\n    // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n    // We use the documentElement instead of the body because, by default (without a css reset)\n    // browsers typically give the document body an 8px margin, which is not included in\n    // getBoundingClientRect().\n    const scrollPosition = this.getViewportScrollPosition();\n    const {\n      width,\n      height\n    } = this.getViewportSize();\n    return {\n      top: scrollPosition.top,\n      left: scrollPosition.left,\n      bottom: scrollPosition.top + height,\n      right: scrollPosition.left + width,\n      height,\n      width\n    };\n  }\n  /** Gets the (top, left) scroll position of the viewport. */\n  getViewportScrollPosition() {\n    // While we can get a reference to the fake document\n    // during SSR, it doesn't have getBoundingClientRect.\n    if (!this._platform.isBrowser) {\n      return {\n        top: 0,\n        left: 0\n      };\n    }\n    // The top-left-corner of the viewport is determined by the scroll position of the document\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n    // `document.documentElement` works consistently, where the `top` and `left` values will\n    // equal negative the scroll position.\n    const document = this._document;\n    const window = this._getWindow();\n    const documentElement = document.documentElement;\n    const documentRect = documentElement.getBoundingClientRect();\n    const top = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;\n    const left = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;\n    return {\n      top,\n      left\n    };\n  }\n  /**\n   * Returns a stream that emits whenever the size of the viewport changes.\n   * This stream emits outside of the Angular zone.\n   * @param throttleTime Time in milliseconds to throttle the stream.\n   */\n  change(throttleTime = DEFAULT_RESIZE_TIME) {\n    return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n  }\n  /** Use defaultView of injected document if available or fallback to global window reference */\n  _getWindow() {\n    return this._document.defaultView || window;\n  }\n  /** Updates the cached viewport size. */\n  _updateViewportSize() {\n    const window = this._getWindow();\n    this._viewportSize = this._platform.isBrowser ? {\n      width: window.innerWidth,\n      height: window.innerHeight\n    } : {\n      width: 0,\n      height: 0\n    };\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: ViewportRuler,\n      deps: [{\n        token: i1.Platform\n      }, {\n        token: i0.NgZone\n      }, {\n        token: DOCUMENT,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Injectable\n    });\n  }\n  static {\n    this.ɵprov = i0.ɵɵngDeclareInjectable({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: ViewportRuler,\n      providedIn: 'root'\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: ViewportRuler,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i1.Platform\n  }, {\n    type: i0.NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }]\n});\nconst VIRTUAL_SCROLLABLE = new InjectionToken('VIRTUAL_SCROLLABLE');\n/**\n * Extending the {@link CdkScrollable} to be used as scrolling container for virtual scrolling.\n */\nclass CdkVirtualScrollable extends CdkScrollable {\n  constructor(elementRef, scrollDispatcher, ngZone, dir) {\n    super(elementRef, scrollDispatcher, ngZone, dir);\n  }\n  /**\n   * Measure the viewport size for the provided orientation.\n   *\n   * @param orientation The orientation to measure the size from.\n   */\n  measureViewportSize(orientation) {\n    const viewportEl = this.elementRef.nativeElement;\n    return orientation === 'horizontal' ? viewportEl.clientWidth : viewportEl.clientHeight;\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkVirtualScrollable,\n      deps: [{\n        token: i0.ElementRef\n      }, {\n        token: ScrollDispatcher\n      }, {\n        token: i0.NgZone\n      }, {\n        token: i2.Directionality,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: CdkVirtualScrollable,\n      usesInheritance: true,\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkVirtualScrollable,\n  decorators: [{\n    type: Directive\n  }],\n  ctorParameters: () => [{\n    type: i0.ElementRef\n  }, {\n    type: ScrollDispatcher\n  }, {\n    type: i0.NgZone\n  }, {\n    type: i2.Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }]\n});\n\n/** Checks if the given ranges are equal. */\nfunction rangesEqual(r1, r2) {\n  return r1.start == r2.start && r1.end == r2.end;\n}\n/**\n * Scheduler to be used for scroll events. Needs to fall back to\n * something that doesn't rely on requestAnimationFrame on environments\n * that don't support it (e.g. server-side rendering).\n */\nconst SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\nclass CdkVirtualScrollViewport extends CdkVirtualScrollable {\n  /** The direction the viewport scrolls. */\n  get orientation() {\n    return this._orientation;\n  }\n  set orientation(orientation) {\n    if (this._orientation !== orientation) {\n      this._orientation = orientation;\n      this._calculateSpacerSize();\n    }\n  }\n  constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler, scrollable) {\n    super(elementRef, scrollDispatcher, ngZone, dir);\n    this.elementRef = elementRef;\n    this._changeDetectorRef = _changeDetectorRef;\n    this._scrollStrategy = _scrollStrategy;\n    this.scrollable = scrollable;\n    this._platform = inject(Platform);\n    /** Emits when the viewport is detached from a CdkVirtualForOf. */\n    this._detachedSubject = new Subject();\n    /** Emits when the rendered range changes. */\n    this._renderedRangeSubject = new Subject();\n    this._orientation = 'vertical';\n    /**\n     * Whether rendered items should persist in the DOM after scrolling out of view. By default, items\n     * will be removed.\n     */\n    this.appendOnly = false;\n    // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n    // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n    // depending on how the strategy calculates the scrolled index, it may come at a cost to\n    // performance.\n    /** Emits when the index of the first element visible in the viewport changes. */\n    this.scrolledIndexChange = new Observable(observer => this._scrollStrategy.scrolledIndexChange.subscribe(index => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\n    /** A stream that emits whenever the rendered range changes. */\n    this.renderedRangeStream = this._renderedRangeSubject;\n    /**\n     * The total size of all content (in pixels), including content that is not currently rendered.\n     */\n    this._totalContentSize = 0;\n    /** A string representing the `style.width` property value to be used for the spacer element. */\n    this._totalContentWidth = '';\n    /** A string representing the `style.height` property value to be used for the spacer element. */\n    this._totalContentHeight = '';\n    /** The currently rendered range of indices. */\n    this._renderedRange = {\n      start: 0,\n      end: 0\n    };\n    /** The length of the data bound to this viewport (in number of items). */\n    this._dataLength = 0;\n    /** The size of the viewport (in pixels). */\n    this._viewportSize = 0;\n    /** The last rendered content offset that was set. */\n    this._renderedContentOffset = 0;\n    /**\n     * Whether the last rendered content offset was to the end of the content (and therefore needs to\n     * be rewritten as an offset to the start of the content).\n     */\n    this._renderedContentOffsetNeedsRewrite = false;\n    /** Whether there is a pending change detection cycle. */\n    this._isChangeDetectionPending = false;\n    /** A list of functions to run after the next change detection cycle. */\n    this._runAfterChangeDetection = [];\n    /** Subscription to changes in the viewport size. */\n    this._viewportChanges = Subscription.EMPTY;\n    this._injector = inject(Injector);\n    this._isDestroyed = false;\n    if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n    }\n    this._viewportChanges = viewportRuler.change().subscribe(() => {\n      this.checkViewportSize();\n    });\n    if (!this.scrollable) {\n      // No scrollable is provided, so the virtual-scroll-viewport needs to become a scrollable\n      this.elementRef.nativeElement.classList.add('cdk-virtual-scrollable');\n      this.scrollable = this;\n    }\n  }\n  ngOnInit() {\n    // Scrolling depends on the element dimensions which we can't get during SSR.\n    if (!this._platform.isBrowser) {\n      return;\n    }\n    if (this.scrollable === this) {\n      super.ngOnInit();\n    }\n    // It's still too early to measure the viewport at this point. Deferring with a promise allows\n    // the Viewport to be rendered with the correct size before we measure. We run this outside the\n    // zone to avoid causing more change detection cycles. We handle the change detection loop\n    // ourselves instead.\n    this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n      this._measureViewportSize();\n      this._scrollStrategy.attach(this);\n      this.scrollable.elementScrolled().pipe(\n      // Start off with a fake scroll event so we properly detect our initial position.\n      startWith(null),\n      // Collect multiple events into one until the next animation frame. This way if\n      // there are multiple scroll events in the same frame we only need to recheck\n      // our layout once.\n      auditTime(0, SCROLL_SCHEDULER),\n      // Usually `elementScrolled` is completed when the scrollable is destroyed, but\n      // that may not be the case if a `CdkVirtualScrollableElement` is used so we have\n      // to unsubscribe here just in case.\n      takeUntil(this._destroyed)).subscribe(() => this._scrollStrategy.onContentScrolled());\n      this._markChangeDetectionNeeded();\n    }));\n  }\n  ngOnDestroy() {\n    this.detach();\n    this._scrollStrategy.detach();\n    // Complete all subjects\n    this._renderedRangeSubject.complete();\n    this._detachedSubject.complete();\n    this._viewportChanges.unsubscribe();\n    this._isDestroyed = true;\n    super.ngOnDestroy();\n  }\n  /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\n  attach(forOf) {\n    if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('CdkVirtualScrollViewport is already attached.');\n    }\n    // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n    // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n    // change detection loop ourselves.\n    this.ngZone.runOutsideAngular(() => {\n      this._forOf = forOf;\n      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\n        const newLength = data.length;\n        if (newLength !== this._dataLength) {\n          this._dataLength = newLength;\n          this._scrollStrategy.onDataLengthChanged();\n        }\n        this._doChangeDetection();\n      });\n    });\n  }\n  /** Detaches the current `CdkVirtualForOf`. */\n  detach() {\n    this._forOf = null;\n    this._detachedSubject.next();\n  }\n  /** Gets the length of the data bound to this viewport (in number of items). */\n  getDataLength() {\n    return this._dataLength;\n  }\n  /** Gets the size of the viewport (in pixels). */\n  getViewportSize() {\n    return this._viewportSize;\n  }\n  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n  // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n  // setting it to something else, but its error prone and should probably be split into\n  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n  /** Get the current rendered range of items. */\n  getRenderedRange() {\n    return this._renderedRange;\n  }\n  measureBoundingClientRectWithScrollOffset(from) {\n    return this.getElementRef().nativeElement.getBoundingClientRect()[from];\n  }\n  /**\n   * Sets the total size of all content (in pixels), including content that is not currently\n   * rendered.\n   */\n  setTotalContentSize(size) {\n    if (this._totalContentSize !== size) {\n      this._totalContentSize = size;\n      this._calculateSpacerSize();\n      this._markChangeDetectionNeeded();\n    }\n  }\n  /** Sets the currently rendered range of indices. */\n  setRenderedRange(range) {\n    if (!rangesEqual(this._renderedRange, range)) {\n      if (this.appendOnly) {\n        range = {\n          start: 0,\n          end: Math.max(this._renderedRange.end, range.end)\n        };\n      }\n      this._renderedRangeSubject.next(this._renderedRange = range);\n      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\n    }\n  }\n  /**\n   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n   */\n  getOffsetToRenderedContentStart() {\n    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n  }\n  /**\n   * Sets the offset from the start of the viewport to either the start or end of the rendered data\n   * (in pixels).\n   */\n  setRenderedContentOffset(offset, to = 'to-start') {\n    // In appendOnly, we always start from the top\n    offset = this.appendOnly && to === 'to-start' ? 0 : offset;\n    // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n    // in the negative direction.\n    const isRtl = this.dir && this.dir.value == 'rtl';\n    const isHorizontal = this.orientation == 'horizontal';\n    const axis = isHorizontal ? 'X' : 'Y';\n    const axisDirection = isHorizontal && isRtl ? -1 : 1;\n    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\n    this._renderedContentOffset = offset;\n    if (to === 'to-end') {\n      transform += ` translate${axis}(-100%)`;\n      // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n      // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n      // expand upward).\n      this._renderedContentOffsetNeedsRewrite = true;\n    }\n    if (this._renderedContentTransform != transform) {\n      // We know this value is safe because we parse `offset` with `Number()` before passing it\n      // into the string.\n      this._renderedContentTransform = transform;\n      this._markChangeDetectionNeeded(() => {\n        if (this._renderedContentOffsetNeedsRewrite) {\n          this._renderedContentOffset -= this.measureRenderedContentSize();\n          this._renderedContentOffsetNeedsRewrite = false;\n          this.setRenderedContentOffset(this._renderedContentOffset);\n        } else {\n          this._scrollStrategy.onRenderedOffsetChanged();\n        }\n      });\n    }\n  }\n  /**\n   * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n   * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n   * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n   * @param offset The offset to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n   */\n  scrollToOffset(offset, behavior = 'auto') {\n    const options = {\n      behavior\n    };\n    if (this.orientation === 'horizontal') {\n      options.start = offset;\n    } else {\n      options.top = offset;\n    }\n    this.scrollable.scrollTo(options);\n  }\n  /**\n   * Scrolls to the offset for the given index.\n   * @param index The index of the element to scroll to.\n   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n   */\n  scrollToIndex(index, behavior = 'auto') {\n    this._scrollStrategy.scrollToIndex(index, behavior);\n  }\n  /**\n   * Gets the current scroll offset from the start of the scrollable (in pixels).\n   * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n   *     in horizontal mode.\n   */\n  measureScrollOffset(from) {\n    // This is to break the call cycle\n    let measureScrollOffset;\n    if (this.scrollable == this) {\n      measureScrollOffset = _from => super.measureScrollOffset(_from);\n    } else {\n      measureScrollOffset = _from => this.scrollable.measureScrollOffset(_from);\n    }\n    return Math.max(0, measureScrollOffset(from ?? (this.orientation === 'horizontal' ? 'start' : 'top')) - this.measureViewportOffset());\n  }\n  /**\n   * Measures the offset of the viewport from the scrolling container\n   * @param from The edge to measure from.\n   */\n  measureViewportOffset(from) {\n    let fromRect;\n    const LEFT = 'left';\n    const RIGHT = 'right';\n    const isRtl = this.dir?.value == 'rtl';\n    if (from == 'start') {\n      fromRect = isRtl ? RIGHT : LEFT;\n    } else if (from == 'end') {\n      fromRect = isRtl ? LEFT : RIGHT;\n    } else if (from) {\n      fromRect = from;\n    } else {\n      fromRect = this.orientation === 'horizontal' ? 'left' : 'top';\n    }\n    const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);\n    const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];\n    return viewportClientRect - scrollerClientRect;\n  }\n  /** Measure the combined size of all of the rendered items. */\n  measureRenderedContentSize() {\n    const contentEl = this._contentWrapper.nativeElement;\n    return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n  }\n  /**\n   * Measure the total combined size of the given range. Throws if the range includes items that are\n   * not rendered.\n   */\n  measureRangeSize(range) {\n    if (!this._forOf) {\n      return 0;\n    }\n    return this._forOf.measureRangeSize(range, this.orientation);\n  }\n  /** Update the viewport dimensions and re-render. */\n  checkViewportSize() {\n    // TODO: Cleanup later when add logic for handling content resize\n    this._measureViewportSize();\n    this._scrollStrategy.onDataLengthChanged();\n  }\n  /** Measure the viewport size. */\n  _measureViewportSize() {\n    this._viewportSize = this.scrollable.measureViewportSize(this.orientation);\n  }\n  /** Queue up change detection to run. */\n  _markChangeDetectionNeeded(runAfter) {\n    if (runAfter) {\n      this._runAfterChangeDetection.push(runAfter);\n    }\n    // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n    // properties sequentially we only have to run `_doChangeDetection` once at the end.\n    if (!this._isChangeDetectionPending) {\n      this._isChangeDetectionPending = true;\n      this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n        this._doChangeDetection();\n      }));\n    }\n  }\n  /** Run change detection. */\n  _doChangeDetection() {\n    if (this._isDestroyed) {\n      return;\n    }\n    this.ngZone.run(() => {\n      // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n      // from the root, since the repeated items are content projected in. Calling `detectChanges`\n      // instead does not properly check the projected content.\n      this._changeDetectorRef.markForCheck();\n      // Apply the content transform. The transform can't be set via an Angular binding because\n      // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n      // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n      // the `Number` function first to coerce it to a numeric value.\n      this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\n      afterNextRender(() => {\n        this._isChangeDetectionPending = false;\n        const runAfterChangeDetection = this._runAfterChangeDetection;\n        this._runAfterChangeDetection = [];\n        for (const fn of runAfterChangeDetection) {\n          fn();\n        }\n      }, {\n        injector: this._injector\n      });\n    });\n  }\n  /** Calculates the `style.width` and `style.height` for the spacer element. */\n  _calculateSpacerSize() {\n    this._totalContentHeight = this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\n    this._totalContentWidth = this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkVirtualScrollViewport,\n      deps: [{\n        token: i0.ElementRef\n      }, {\n        token: i0.ChangeDetectorRef\n      }, {\n        token: i0.NgZone\n      }, {\n        token: VIRTUAL_SCROLL_STRATEGY,\n        optional: true\n      }, {\n        token: i2.Directionality,\n        optional: true\n      }, {\n        token: ScrollDispatcher\n      }, {\n        token: ViewportRuler\n      }, {\n        token: VIRTUAL_SCROLLABLE,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Component\n    });\n  }\n  static {\n    this.ɵcmp = i0.ɵɵngDeclareComponent({\n      minVersion: \"16.1.0\",\n      version: \"18.2.0-next.2\",\n      type: CdkVirtualScrollViewport,\n      isStandalone: true,\n      selector: \"cdk-virtual-scroll-viewport\",\n      inputs: {\n        orientation: \"orientation\",\n        appendOnly: [\"appendOnly\", \"appendOnly\", booleanAttribute]\n      },\n      outputs: {\n        scrolledIndexChange: \"scrolledIndexChange\"\n      },\n      host: {\n        properties: {\n          \"class.cdk-virtual-scroll-orientation-horizontal\": \"orientation === \\\"horizontal\\\"\",\n          \"class.cdk-virtual-scroll-orientation-vertical\": \"orientation !== \\\"horizontal\\\"\"\n        },\n        classAttribute: \"cdk-virtual-scroll-viewport\"\n      },\n      providers: [{\n        provide: CdkScrollable,\n        useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,\n        deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]\n      }],\n      viewQueries: [{\n        propertyName: \"_contentWrapper\",\n        first: true,\n        predicate: [\"contentWrapper\"],\n        descendants: true,\n        static: true\n      }],\n      usesInheritance: true,\n      ngImport: i0,\n      template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\",\n      styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\"],\n      changeDetection: i0.ChangeDetectionStrategy.OnPush,\n      encapsulation: i0.ViewEncapsulation.None\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkVirtualScrollViewport,\n  decorators: [{\n    type: Component,\n    args: [{\n      selector: 'cdk-virtual-scroll-viewport',\n      host: {\n        'class': 'cdk-virtual-scroll-viewport',\n        '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\n        '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"'\n      },\n      encapsulation: ViewEncapsulation.None,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      standalone: true,\n      providers: [{\n        provide: CdkScrollable,\n        useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,\n        deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]\n      }],\n      template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\",\n      styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\"]\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.ElementRef\n  }, {\n    type: i0.ChangeDetectorRef\n  }, {\n    type: i0.NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [VIRTUAL_SCROLL_STRATEGY]\n    }]\n  }, {\n    type: i2.Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: ScrollDispatcher\n  }, {\n    type: ViewportRuler\n  }, {\n    type: CdkVirtualScrollable,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [VIRTUAL_SCROLLABLE]\n    }]\n  }],\n  propDecorators: {\n    orientation: [{\n      type: Input\n    }],\n    appendOnly: [{\n      type: Input,\n      args: [{\n        transform: booleanAttribute\n      }]\n    }],\n    scrolledIndexChange: [{\n      type: Output\n    }],\n    _contentWrapper: [{\n      type: ViewChild,\n      args: ['contentWrapper', {\n        static: true\n      }]\n    }]\n  }\n});\n\n/** Helper to extract the offset of a DOM Node in a certain direction. */\nfunction getOffset(orientation, direction, node) {\n  const el = node;\n  if (!el.getBoundingClientRect) {\n    return 0;\n  }\n  const rect = el.getBoundingClientRect();\n  if (orientation === 'horizontal') {\n    return direction === 'start' ? rect.left : rect.right;\n  }\n  return direction === 'start' ? rect.top : rect.bottom;\n}\n/**\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\n * container.\n */\nclass CdkVirtualForOf {\n  /** The DataSource to display. */\n  get cdkVirtualForOf() {\n    return this._cdkVirtualForOf;\n  }\n  set cdkVirtualForOf(value) {\n    this._cdkVirtualForOf = value;\n    if (isDataSource(value)) {\n      this._dataSourceChanges.next(value);\n    } else {\n      // If value is an an NgIterable, convert it to an array.\n      this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));\n    }\n  }\n  /**\n   * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n   * the item and produces a value to be used as the item's identity when tracking changes.\n   */\n  get cdkVirtualForTrackBy() {\n    return this._cdkVirtualForTrackBy;\n  }\n  set cdkVirtualForTrackBy(fn) {\n    this._needsUpdate = true;\n    this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : undefined;\n  }\n  /** The template used to stamp out new elements. */\n  set cdkVirtualForTemplate(value) {\n    if (value) {\n      this._needsUpdate = true;\n      this._template = value;\n    }\n  }\n  /**\n   * The size of the cache used to store templates that are not being used for re-use later.\n   * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n   */\n  get cdkVirtualForTemplateCacheSize() {\n    return this._viewRepeater.viewCacheSize;\n  }\n  set cdkVirtualForTemplateCacheSize(size) {\n    this._viewRepeater.viewCacheSize = coerceNumberProperty(size);\n  }\n  constructor( /** The view container to add items to. */\n  _viewContainerRef, /** The template to use when stamping out new items. */\n  _template, /** The set of available differs. */\n  _differs, /** The strategy used to render items in the virtual scroll viewport. */\n  _viewRepeater, /** The virtual scrolling viewport that these items are being rendered in. */\n  _viewport, ngZone) {\n    this._viewContainerRef = _viewContainerRef;\n    this._template = _template;\n    this._differs = _differs;\n    this._viewRepeater = _viewRepeater;\n    this._viewport = _viewport;\n    /** Emits when the rendered view of the data changes. */\n    this.viewChange = new Subject();\n    /** Subject that emits when a new DataSource instance is given. */\n    this._dataSourceChanges = new Subject();\n    /** Emits whenever the data in the current DataSource changes. */\n    this.dataStream = this._dataSourceChanges.pipe(\n    // Start off with null `DataSource`.\n    startWith(null),\n    // Bundle up the previous and current data sources so we can work with both.\n    pairwise(),\n    // Use `_changeDataSource` to disconnect from the previous data source and connect to the\n    // new one, passing back a stream of data changes which we run through `switchMap` to give\n    // us a data stream that emits the latest data from whatever the current `DataSource` is.\n    switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),\n    // Replay the last emitted data when someone subscribes.\n    shareReplay(1));\n    /** The differ used to calculate changes to the data. */\n    this._differ = null;\n    /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n    this._needsUpdate = false;\n    this._destroyed = new Subject();\n    this.dataStream.subscribe(data => {\n      this._data = data;\n      this._onRenderedDataChange();\n    });\n    this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe(range => {\n      this._renderedRange = range;\n      if (this.viewChange.observers.length) {\n        ngZone.run(() => this.viewChange.next(this._renderedRange));\n      }\n      this._onRenderedDataChange();\n    });\n    this._viewport.attach(this);\n  }\n  /**\n   * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n   * in the specified range. Throws an error if the range includes items that are not currently\n   * rendered.\n   */\n  measureRangeSize(range, orientation) {\n    if (range.start >= range.end) {\n      return 0;\n    }\n    if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error(`Error: attempted to measure an item that isn't rendered.`);\n    }\n    // The index into the list of rendered views for the first item in the range.\n    const renderedStartIndex = range.start - this._renderedRange.start;\n    // The length of the range we're measuring.\n    const rangeLen = range.end - range.start;\n    // Loop over all the views, find the first and land node and compute the size by subtracting\n    // the top of the first node from the bottom of the last one.\n    let firstNode;\n    let lastNode;\n    // Find the first node by starting from the beginning and going forwards.\n    for (let i = 0; i < rangeLen; i++) {\n      const view = this._viewContainerRef.get(i + renderedStartIndex);\n      if (view && view.rootNodes.length) {\n        firstNode = lastNode = view.rootNodes[0];\n        break;\n      }\n    }\n    // Find the last node by starting from the end and going backwards.\n    for (let i = rangeLen - 1; i > -1; i--) {\n      const view = this._viewContainerRef.get(i + renderedStartIndex);\n      if (view && view.rootNodes.length) {\n        lastNode = view.rootNodes[view.rootNodes.length - 1];\n        break;\n      }\n    }\n    return firstNode && lastNode ? getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode) : 0;\n  }\n  ngDoCheck() {\n    if (this._differ && this._needsUpdate) {\n      // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\n      // this list being rendered (can use simpler algorithm) vs needs update due to data actually\n      // changing (need to do this diff).\n      const changes = this._differ.diff(this._renderedItems);\n      if (!changes) {\n        this._updateContext();\n      } else {\n        this._applyChanges(changes);\n      }\n      this._needsUpdate = false;\n    }\n  }\n  ngOnDestroy() {\n    this._viewport.detach();\n    this._dataSourceChanges.next(undefined);\n    this._dataSourceChanges.complete();\n    this.viewChange.complete();\n    this._destroyed.next();\n    this._destroyed.complete();\n    this._viewRepeater.detach();\n  }\n  /** React to scroll state changes in the viewport. */\n  _onRenderedDataChange() {\n    if (!this._renderedRange) {\n      return;\n    }\n    this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\n    if (!this._differ) {\n      // Use a wrapper function for the `trackBy` so any new values are\n      // picked up automatically without having to recreate the differ.\n      this._differ = this._differs.find(this._renderedItems).create((index, item) => {\n        return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;\n      });\n    }\n    this._needsUpdate = true;\n  }\n  /** Swap out one `DataSource` for another. */\n  _changeDataSource(oldDs, newDs) {\n    if (oldDs) {\n      oldDs.disconnect(this);\n    }\n    this._needsUpdate = true;\n    return newDs ? newDs.connect(this) : of();\n  }\n  /** Update the `CdkVirtualForOfContext` for all views. */\n  _updateContext() {\n    const count = this._data.length;\n    let i = this._viewContainerRef.length;\n    while (i--) {\n      const view = this._viewContainerRef.get(i);\n      view.context.index = this._renderedRange.start + i;\n      view.context.count = count;\n      this._updateComputedContextProperties(view.context);\n      view.detectChanges();\n    }\n  }\n  /** Apply changes to the DOM. */\n  _applyChanges(changes) {\n    this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), record => record.item);\n    // Update $implicit for any items that had an identity change.\n    changes.forEachIdentityChange(record => {\n      const view = this._viewContainerRef.get(record.currentIndex);\n      view.context.$implicit = record.item;\n    });\n    // Update the context variables on all items.\n    const count = this._data.length;\n    let i = this._viewContainerRef.length;\n    while (i--) {\n      const view = this._viewContainerRef.get(i);\n      view.context.index = this._renderedRange.start + i;\n      view.context.count = count;\n      this._updateComputedContextProperties(view.context);\n    }\n  }\n  /** Update the computed properties on the `CdkVirtualForOfContext`. */\n  _updateComputedContextProperties(context) {\n    context.first = context.index === 0;\n    context.last = context.index === context.count - 1;\n    context.even = context.index % 2 === 0;\n    context.odd = !context.even;\n  }\n  _getEmbeddedViewArgs(record, index) {\n    // Note that it's important that we insert the item directly at the proper index,\n    // rather than inserting it and the moving it in place, because if there's a directive\n    // on the same node that injects the `ViewContainerRef`, Angular will insert another\n    // comment node which can throw off the move when it's being repeated for all items.\n    return {\n      templateRef: this._template,\n      context: {\n        $implicit: record.item,\n        // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\n        // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\n        cdkVirtualForOf: this._cdkVirtualForOf,\n        index: -1,\n        count: -1,\n        first: false,\n        last: false,\n        odd: false,\n        even: false\n      },\n      index\n    };\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkVirtualForOf,\n      deps: [{\n        token: i0.ViewContainerRef\n      }, {\n        token: i0.TemplateRef\n      }, {\n        token: i0.IterableDiffers\n      }, {\n        token: _VIEW_REPEATER_STRATEGY\n      }, {\n        token: CdkVirtualScrollViewport,\n        skipSelf: true\n      }, {\n        token: i0.NgZone\n      }],\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: CdkVirtualForOf,\n      isStandalone: true,\n      selector: \"[cdkVirtualFor][cdkVirtualForOf]\",\n      inputs: {\n        cdkVirtualForOf: \"cdkVirtualForOf\",\n        cdkVirtualForTrackBy: \"cdkVirtualForTrackBy\",\n        cdkVirtualForTemplate: \"cdkVirtualForTemplate\",\n        cdkVirtualForTemplateCacheSize: \"cdkVirtualForTemplateCacheSize\"\n      },\n      providers: [{\n        provide: _VIEW_REPEATER_STRATEGY,\n        useClass: _RecycleViewRepeaterStrategy\n      }],\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkVirtualForOf,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[cdkVirtualFor][cdkVirtualForOf]',\n      providers: [{\n        provide: _VIEW_REPEATER_STRATEGY,\n        useClass: _RecycleViewRepeaterStrategy\n      }],\n      standalone: true\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.ViewContainerRef\n  }, {\n    type: i0.TemplateRef\n  }, {\n    type: i0.IterableDiffers\n  }, {\n    type: i2$1._RecycleViewRepeaterStrategy,\n    decorators: [{\n      type: Inject,\n      args: [_VIEW_REPEATER_STRATEGY]\n    }]\n  }, {\n    type: CdkVirtualScrollViewport,\n    decorators: [{\n      type: SkipSelf\n    }]\n  }, {\n    type: i0.NgZone\n  }],\n  propDecorators: {\n    cdkVirtualForOf: [{\n      type: Input\n    }],\n    cdkVirtualForTrackBy: [{\n      type: Input\n    }],\n    cdkVirtualForTemplate: [{\n      type: Input\n    }],\n    cdkVirtualForTemplateCacheSize: [{\n      type: Input\n    }]\n  }\n});\n\n/**\n * Provides a virtual scrollable for the element it is attached to.\n */\nclass CdkVirtualScrollableElement extends CdkVirtualScrollable {\n  constructor(elementRef, scrollDispatcher, ngZone, dir) {\n    super(elementRef, scrollDispatcher, ngZone, dir);\n  }\n  measureBoundingClientRectWithScrollOffset(from) {\n    return this.getElementRef().nativeElement.getBoundingClientRect()[from] - this.measureScrollOffset(from);\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkVirtualScrollableElement,\n      deps: [{\n        token: i0.ElementRef\n      }, {\n        token: ScrollDispatcher\n      }, {\n        token: i0.NgZone\n      }, {\n        token: i2.Directionality,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: CdkVirtualScrollableElement,\n      isStandalone: true,\n      selector: \"[cdkVirtualScrollingElement]\",\n      host: {\n        classAttribute: \"cdk-virtual-scrollable\"\n      },\n      providers: [{\n        provide: VIRTUAL_SCROLLABLE,\n        useExisting: CdkVirtualScrollableElement\n      }],\n      usesInheritance: true,\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkVirtualScrollableElement,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[cdkVirtualScrollingElement]',\n      providers: [{\n        provide: VIRTUAL_SCROLLABLE,\n        useExisting: CdkVirtualScrollableElement\n      }],\n      standalone: true,\n      host: {\n        'class': 'cdk-virtual-scrollable'\n      }\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.ElementRef\n  }, {\n    type: ScrollDispatcher\n  }, {\n    type: i0.NgZone\n  }, {\n    type: i2.Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }]\n});\n\n/**\n * Provides as virtual scrollable for the global / window scrollbar.\n */\nclass CdkVirtualScrollableWindow extends CdkVirtualScrollable {\n  constructor(scrollDispatcher, ngZone, dir) {\n    super(new ElementRef(document.documentElement), scrollDispatcher, ngZone, dir);\n    this._elementScrolled = new Observable(observer => this.ngZone.runOutsideAngular(() => fromEvent(document, 'scroll').pipe(takeUntil(this._destroyed)).subscribe(observer)));\n  }\n  measureBoundingClientRectWithScrollOffset(from) {\n    return this.getElementRef().nativeElement.getBoundingClientRect()[from];\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkVirtualScrollableWindow,\n      deps: [{\n        token: ScrollDispatcher\n      }, {\n        token: i0.NgZone\n      }, {\n        token: i2.Directionality,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: CdkVirtualScrollableWindow,\n      isStandalone: true,\n      selector: \"cdk-virtual-scroll-viewport[scrollWindow]\",\n      providers: [{\n        provide: VIRTUAL_SCROLLABLE,\n        useExisting: CdkVirtualScrollableWindow\n      }],\n      usesInheritance: true,\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkVirtualScrollableWindow,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: 'cdk-virtual-scroll-viewport[scrollWindow]',\n      providers: [{\n        provide: VIRTUAL_SCROLLABLE,\n        useExisting: CdkVirtualScrollableWindow\n      }],\n      standalone: true\n    }]\n  }],\n  ctorParameters: () => [{\n    type: ScrollDispatcher\n  }, {\n    type: i0.NgZone\n  }, {\n    type: i2.Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }]\n});\nclass CdkScrollableModule {\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkScrollableModule,\n      deps: [],\n      target: i0.ɵɵFactoryTarget.NgModule\n    });\n  }\n  static {\n    this.ɵmod = i0.ɵɵngDeclareNgModule({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkScrollableModule,\n      imports: [CdkScrollable],\n      exports: [CdkScrollable]\n    });\n  }\n  static {\n    this.ɵinj = i0.ɵɵngDeclareInjector({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkScrollableModule\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkScrollableModule,\n  decorators: [{\n    type: NgModule,\n    args: [{\n      exports: [CdkScrollable],\n      imports: [CdkScrollable]\n    }]\n  }]\n});\n/**\n * @docs-primary-export\n */\nclass ScrollingModule {\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: ScrollingModule,\n      deps: [],\n      target: i0.ɵɵFactoryTarget.NgModule\n    });\n  }\n  static {\n    this.ɵmod = i0.ɵɵngDeclareNgModule({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: ScrollingModule,\n      imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],\n      exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]\n    });\n  }\n  static {\n    this.ɵinj = i0.ɵɵngDeclareInjector({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: ScrollingModule,\n      imports: [BidiModule, CdkScrollableModule, BidiModule, CdkScrollableModule]\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: ScrollingModule,\n  decorators: [{\n    type: NgModule,\n    args: [{\n      imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],\n      exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]\n    }]\n  }]\n});\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkFixedSizeVirtualScroll, CdkScrollable, CdkScrollableModule, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollable, CdkVirtualScrollableElement, CdkVirtualScrollableWindow, DEFAULT_RESIZE_TIME, DEFAULT_SCROLL_TIME, FixedSizeVirtualScrollStrategy, ScrollDispatcher, ScrollingModule, VIRTUAL_SCROLLABLE, VIRTUAL_SCROLL_STRATEGY, ViewportRuler, _fixedSizeVirtualScrollStrategyFactory };\n","import * as i0 from '@angular/core';\nimport { ElementRef, Injector, Directive, EventEmitter, Inject, Input, Output, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\nfunction throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nfunction throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nfunction throwUnknownPortalTypeError() {\n  throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' + 'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nfunction throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nfunction throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nclass Portal {\n  /** Attach this portal to a host. */\n  attach(host) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (host == null) {\n        throwNullPortalOutletError();\n      }\n      if (host.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n    }\n    this._attachedHost = host;\n    return host.attach(this);\n  }\n  /** Detach this portal from its host */\n  detach() {\n    let host = this._attachedHost;\n    if (host != null) {\n      this._attachedHost = null;\n      host.detach();\n    } else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throwNoPortalAttachedError();\n    }\n  }\n  /** Whether this portal is attached to a host. */\n  get isAttached() {\n    return this._attachedHost != null;\n  }\n  /**\n   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n   * the PortalOutlet when it is performing an `attach()` or `detach()`.\n   */\n  setAttachedHost(host) {\n    this._attachedHost = host;\n  }\n}\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nclass ComponentPortal extends Portal {\n  constructor(component, viewContainerRef, injector, componentFactoryResolver, projectableNodes) {\n    super();\n    this.component = component;\n    this.viewContainerRef = viewContainerRef;\n    this.injector = injector;\n    this.componentFactoryResolver = componentFactoryResolver;\n    this.projectableNodes = projectableNodes;\n  }\n}\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nclass TemplatePortal extends Portal {\n  constructor( /** The embedded template that will be used to instantiate an embedded View in the host. */\n  templateRef, /** Reference to the ViewContainer into which the template will be stamped out. */\n  viewContainerRef, /** Contextual data to be passed in to the embedded view. */\n  context, /** The injector to use for the embedded view. */\n  injector) {\n    super();\n    this.templateRef = templateRef;\n    this.viewContainerRef = viewContainerRef;\n    this.context = context;\n    this.injector = injector;\n  }\n  get origin() {\n    return this.templateRef.elementRef;\n  }\n  /**\n   * Attach the portal to the provided `PortalOutlet`.\n   * When a context is provided it will override the `context` property of the `TemplatePortal`\n   * instance.\n   */\n  attach(host, context = this.context) {\n    this.context = context;\n    return super.attach(host);\n  }\n  detach() {\n    this.context = undefined;\n    return super.detach();\n  }\n}\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\nclass DomPortal extends Portal {\n  constructor(element) {\n    super();\n    this.element = element instanceof ElementRef ? element.nativeElement : element;\n  }\n}\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nclass BasePortalOutlet {\n  constructor() {\n    /** Whether this host has already been permanently disposed. */\n    this._isDisposed = false;\n    // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.\n    this.attachDomPortal = null;\n  }\n  /** Whether this host has an attached portal. */\n  hasAttached() {\n    return !!this._attachedPortal;\n  }\n  /** Attaches a portal. */\n  attach(portal) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!portal) {\n        throwNullPortalError();\n      }\n      if (this.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n      if (this._isDisposed) {\n        throwPortalOutletAlreadyDisposedError();\n      }\n    }\n    if (portal instanceof ComponentPortal) {\n      this._attachedPortal = portal;\n      return this.attachComponentPortal(portal);\n    } else if (portal instanceof TemplatePortal) {\n      this._attachedPortal = portal;\n      return this.attachTemplatePortal(portal);\n      // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.\n    } else if (this.attachDomPortal && portal instanceof DomPortal) {\n      this._attachedPortal = portal;\n      return this.attachDomPortal(portal);\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throwUnknownPortalTypeError();\n    }\n  }\n  /** Detaches a previously attached portal. */\n  detach() {\n    if (this._attachedPortal) {\n      this._attachedPortal.setAttachedHost(null);\n      this._attachedPortal = null;\n    }\n    this._invokeDisposeFn();\n  }\n  /** Permanently dispose of this portal host. */\n  dispose() {\n    if (this.hasAttached()) {\n      this.detach();\n    }\n    this._invokeDisposeFn();\n    this._isDisposed = true;\n  }\n  /** @docs-private */\n  setDisposeFn(fn) {\n    this._disposeFn = fn;\n  }\n  _invokeDisposeFn() {\n    if (this._disposeFn) {\n      this._disposeFn();\n      this._disposeFn = null;\n    }\n  }\n}\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass BasePortalHost extends BasePortalOutlet {}\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nclass DomPortalOutlet extends BasePortalOutlet {\n  /**\n   * @param outletElement Element into which the content is projected.\n   * @param _componentFactoryResolver Used to resolve the component factory.\n   *   Only required when attaching component portals.\n   * @param _appRef Reference to the application. Only used in component portals when there\n   *   is no `ViewContainerRef` available.\n   * @param _defaultInjector Injector to use as a fallback when the portal being attached doesn't\n   *   have one. Only used for component portals.\n   * @param _document Reference to the document. Used when attaching a DOM portal. Will eventually\n   *   become a required parameter.\n   */\n  constructor( /** Element into which the content is projected. */\n  outletElement, _componentFactoryResolver, _appRef, _defaultInjector,\n  /**\n   * @deprecated `_document` Parameter to be made required.\n   * @breaking-change 10.0.0\n   */\n  _document) {\n    super();\n    this.outletElement = outletElement;\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._appRef = _appRef;\n    this._defaultInjector = _defaultInjector;\n    /**\n     * Attaches a DOM portal by transferring its content into the outlet.\n     * @param portal Portal to be attached.\n     * @deprecated To be turned into a method.\n     * @breaking-change 10.0.0\n     */\n    this.attachDomPortal = portal => {\n      // @breaking-change 10.0.0 Remove check and error once the\n      // `_document` constructor parameter is required.\n      if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Cannot attach DOM portal without _document constructor parameter');\n      }\n      const element = portal.element;\n      if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('DOM portal content must be attached to a parent node.');\n      }\n      // Anchor used to save the element's previous position so\n      // that we can restore it when the portal is detached.\n      const anchorNode = this._document.createComment('dom-portal');\n      element.parentNode.insertBefore(anchorNode, element);\n      this.outletElement.appendChild(element);\n      this._attachedPortal = portal;\n      super.setDisposeFn(() => {\n        // We can't use `replaceWith` here because IE doesn't support it.\n        if (anchorNode.parentNode) {\n          anchorNode.parentNode.replaceChild(element, anchorNode);\n        }\n      });\n    };\n    this._document = _document;\n  }\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @param portal Portal to be attached\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal(portal) {\n    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !resolver) {\n      throw Error('Cannot attach component portal to outlet without a ComponentFactoryResolver.');\n    }\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    let componentRef;\n    // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n    // for the component (in terms of Angular's component tree, not rendering).\n    // When the ViewContainerRef is missing, we use the factory to create the component directly\n    // and then manually attach the view to the application.\n    if (portal.viewContainerRef) {\n      componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector, portal.projectableNodes || undefined);\n      this.setDisposeFn(() => componentRef.destroy());\n    } else {\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && !this._appRef) {\n        throw Error('Cannot attach component portal to outlet without an ApplicationRef.');\n      }\n      componentRef = componentFactory.create(portal.injector || this._defaultInjector || Injector.NULL);\n      this._appRef.attachView(componentRef.hostView);\n      this.setDisposeFn(() => {\n        // Verify that the ApplicationRef has registered views before trying to detach a host view.\n        // This check also protects the `detachView` from being called on a destroyed ApplicationRef.\n        if (this._appRef.viewCount > 0) {\n          this._appRef.detachView(componentRef.hostView);\n        }\n        componentRef.destroy();\n      });\n    }\n    // At this point the component has been instantiated, so we move it to the location in the DOM\n    // where we want it to be rendered.\n    this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n    this._attachedPortal = portal;\n    return componentRef;\n  }\n  /**\n   * Attaches a template portal to the DOM as an embedded view.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal(portal) {\n    let viewContainer = portal.viewContainerRef;\n    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context, {\n      injector: portal.injector\n    });\n    // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n    // But for the DomPortalOutlet the view can be added everywhere in the DOM\n    // (e.g Overlay Container) To move the view to the specified host element. We just\n    // re-append the existing root nodes.\n    viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n    // Note that we want to detect changes after the nodes have been moved so that\n    // any directives inside the portal that are looking at the DOM inside a lifecycle\n    // hook won't be invoked too early.\n    viewRef.detectChanges();\n    this.setDisposeFn(() => {\n      let index = viewContainer.indexOf(viewRef);\n      if (index !== -1) {\n        viewContainer.remove(index);\n      }\n    });\n    this._attachedPortal = portal;\n    // TODO(jelbourn): Return locals from view.\n    return viewRef;\n  }\n  /**\n   * Clears out a portal from the DOM.\n   */\n  dispose() {\n    super.dispose();\n    this.outletElement.remove();\n  }\n  /** Gets the root HTMLElement for an instantiated component. */\n  _getComponentRootNode(componentRef) {\n    return componentRef.hostView.rootNodes[0];\n  }\n}\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass DomPortalHost extends DomPortalOutlet {}\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nclass CdkPortal extends TemplatePortal {\n  constructor(templateRef, viewContainerRef) {\n    super(templateRef, viewContainerRef);\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkPortal,\n      deps: [{\n        token: i0.TemplateRef\n      }, {\n        token: i0.ViewContainerRef\n      }],\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: CdkPortal,\n      isStandalone: true,\n      selector: \"[cdkPortal]\",\n      exportAs: [\"cdkPortal\"],\n      usesInheritance: true,\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkPortal,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortal]',\n      exportAs: 'cdkPortal',\n      standalone: true\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.TemplateRef\n  }, {\n    type: i0.ViewContainerRef\n  }]\n});\n/**\n * @deprecated Use `CdkPortal` instead.\n * @breaking-change 9.0.0\n */\nclass TemplatePortalDirective extends CdkPortal {\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: TemplatePortalDirective,\n      deps: null,\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: TemplatePortalDirective,\n      isStandalone: true,\n      selector: \"[cdk-portal], [portal]\",\n      providers: [{\n        provide: CdkPortal,\n        useExisting: TemplatePortalDirective\n      }],\n      exportAs: [\"cdkPortal\"],\n      usesInheritance: true,\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: TemplatePortalDirective,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[cdk-portal], [portal]',\n      exportAs: 'cdkPortal',\n      providers: [{\n        provide: CdkPortal,\n        useExisting: TemplatePortalDirective\n      }],\n      standalone: true\n    }]\n  }]\n});\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\nclass CdkPortalOutlet extends BasePortalOutlet {\n  constructor(_componentFactoryResolver, _viewContainerRef,\n  /**\n   * @deprecated `_document` parameter to be made required.\n   * @breaking-change 9.0.0\n   */\n  _document) {\n    super();\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._viewContainerRef = _viewContainerRef;\n    /** Whether the portal component is initialized. */\n    this._isInitialized = false;\n    /** Emits when a portal is attached to the outlet. */\n    this.attached = new EventEmitter();\n    /**\n     * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n     * @param portal Portal to be attached.\n     * @deprecated To be turned into a method.\n     * @breaking-change 10.0.0\n     */\n    this.attachDomPortal = portal => {\n      // @breaking-change 9.0.0 Remove check and error once the\n      // `_document` constructor parameter is required.\n      if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Cannot attach DOM portal without _document constructor parameter');\n      }\n      const element = portal.element;\n      if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('DOM portal content must be attached to a parent node.');\n      }\n      // Anchor used to save the element's previous position so\n      // that we can restore it when the portal is detached.\n      const anchorNode = this._document.createComment('dom-portal');\n      portal.setAttachedHost(this);\n      element.parentNode.insertBefore(anchorNode, element);\n      this._getRootNode().appendChild(element);\n      this._attachedPortal = portal;\n      super.setDisposeFn(() => {\n        if (anchorNode.parentNode) {\n          anchorNode.parentNode.replaceChild(element, anchorNode);\n        }\n      });\n    };\n    this._document = _document;\n  }\n  /** Portal associated with the Portal outlet. */\n  get portal() {\n    return this._attachedPortal;\n  }\n  set portal(portal) {\n    // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n    // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n    // and attach a portal programmatically in the parent component. When Angular does the first CD\n    // round, it will fire the setter with empty string, causing the user's content to be cleared.\n    if (this.hasAttached() && !portal && !this._isInitialized) {\n      return;\n    }\n    if (this.hasAttached()) {\n      super.detach();\n    }\n    if (portal) {\n      super.attach(portal);\n    }\n    this._attachedPortal = portal || null;\n  }\n  /** Component or view reference that is attached to the portal. */\n  get attachedRef() {\n    return this._attachedRef;\n  }\n  ngOnInit() {\n    this._isInitialized = true;\n  }\n  ngOnDestroy() {\n    super.dispose();\n    this._attachedRef = this._attachedPortal = null;\n  }\n  /**\n   * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n   *\n   * @param portal Portal to be attached to the portal outlet.\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal(portal) {\n    portal.setAttachedHost(this);\n    // If the portal specifies an origin, use that as the logical location of the component\n    // in the application tree. Otherwise use the location of this PortalOutlet.\n    const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;\n    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector, portal.projectableNodes || undefined);\n    // If we're using a view container that's different from the injected one (e.g. when the portal\n    // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered\n    // inside of the alternate view container.\n    if (viewContainerRef !== this._viewContainerRef) {\n      this._getRootNode().appendChild(ref.hostView.rootNodes[0]);\n    }\n    super.setDisposeFn(() => ref.destroy());\n    this._attachedPortal = portal;\n    this._attachedRef = ref;\n    this.attached.emit(ref);\n    return ref;\n  }\n  /**\n   * Attach the given TemplatePortal to this PortalHost as an embedded View.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal(portal) {\n    portal.setAttachedHost(this);\n    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context, {\n      injector: portal.injector\n    });\n    super.setDisposeFn(() => this._viewContainerRef.clear());\n    this._attachedPortal = portal;\n    this._attachedRef = viewRef;\n    this.attached.emit(viewRef);\n    return viewRef;\n  }\n  /** Gets the root node of the portal outlet. */\n  _getRootNode() {\n    const nativeElement = this._viewContainerRef.element.nativeElement;\n    // The directive could be set on a template which will result in a comment\n    // node being the root. Use the comment's parent node if that is the case.\n    return nativeElement.nodeType === nativeElement.ELEMENT_NODE ? nativeElement : nativeElement.parentNode;\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkPortalOutlet,\n      deps: [{\n        token: i0.ComponentFactoryResolver\n      }, {\n        token: i0.ViewContainerRef\n      }, {\n        token: DOCUMENT\n      }],\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: CdkPortalOutlet,\n      isStandalone: true,\n      selector: \"[cdkPortalOutlet]\",\n      inputs: {\n        portal: [\"cdkPortalOutlet\", \"portal\"]\n      },\n      outputs: {\n        attached: \"attached\"\n      },\n      exportAs: [\"cdkPortalOutlet\"],\n      usesInheritance: true,\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkPortalOutlet,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortalOutlet]',\n      exportAs: 'cdkPortalOutlet',\n      standalone: true\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.ComponentFactoryResolver\n  }, {\n    type: i0.ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }],\n  propDecorators: {\n    portal: [{\n      type: Input,\n      args: ['cdkPortalOutlet']\n    }],\n    attached: [{\n      type: Output\n    }]\n  }\n});\n/**\n * @deprecated Use `CdkPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass PortalHostDirective extends CdkPortalOutlet {\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: PortalHostDirective,\n      deps: null,\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: PortalHostDirective,\n      isStandalone: true,\n      selector: \"[cdkPortalHost], [portalHost]\",\n      inputs: {\n        portal: [\"cdkPortalHost\", \"portal\"]\n      },\n      providers: [{\n        provide: CdkPortalOutlet,\n        useExisting: PortalHostDirective\n      }],\n      exportAs: [\"cdkPortalHost\"],\n      usesInheritance: true,\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: PortalHostDirective,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortalHost], [portalHost]',\n      exportAs: 'cdkPortalHost',\n      inputs: [{\n        name: 'portal',\n        alias: 'cdkPortalHost'\n      }],\n      providers: [{\n        provide: CdkPortalOutlet,\n        useExisting: PortalHostDirective\n      }],\n      standalone: true\n    }]\n  }]\n});\nclass PortalModule {\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: PortalModule,\n      deps: [],\n      target: i0.ɵɵFactoryTarget.NgModule\n    });\n  }\n  static {\n    this.ɵmod = i0.ɵɵngDeclareNgModule({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: PortalModule,\n      imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n      exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]\n    });\n  }\n  static {\n    this.ɵinj = i0.ɵɵngDeclareInjector({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: PortalModule\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: PortalModule,\n  decorators: [{\n    type: NgModule,\n    args: [{\n      imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n      exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]\n    }]\n  }]\n});\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n * @deprecated Use `Injector.create` instead.\n * @breaking-change 11.0.0\n */\nclass PortalInjector {\n  constructor(_parentInjector, _customTokens) {\n    this._parentInjector = _parentInjector;\n    this._customTokens = _customTokens;\n  }\n  get(token, notFoundValue) {\n    const value = this._customTokens.get(token);\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n    return this._parentInjector.get(token, notFoundValue);\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BasePortalHost, BasePortalOutlet, CdkPortal, CdkPortalOutlet, ComponentPortal, DomPortal, DomPortalHost, DomPortalOutlet, Portal, PortalHostDirective, PortalInjector, PortalModule, TemplatePortal, TemplatePortalDirective };\n","import * as i1 from '@angular/cdk/scrolling';\nimport { ScrollingModule } from '@angular/cdk/scrolling';\nexport { CdkScrollable, ScrollDispatcher, ViewportRuler } from '@angular/cdk/scrolling';\nimport * as i6 from '@angular/common';\nimport { DOCUMENT } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, Optional, untracked, afterRender, afterNextRender, ElementRef, EnvironmentInjector, ApplicationRef, ANIMATION_MODULE_TYPE, InjectionToken, inject, Directive, NgZone, EventEmitter, booleanAttribute, Input, Output, NgModule } from '@angular/core';\nimport { coerceCssPixelValue, coerceArray } from '@angular/cdk/coercion';\nimport * as i1$1 from '@angular/cdk/platform';\nimport { supportsScrollBehavior, _getEventTarget, _isTestEnvironment } from '@angular/cdk/platform';\nimport { filter, takeUntil, takeWhile } from 'rxjs/operators';\nimport * as i5 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { Subject, Subscription, merge } from 'rxjs';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\nconst scrollBehaviorSupported = supportsScrollBehavior();\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nclass BlockScrollStrategy {\n  constructor(_viewportRuler, document) {\n    this._viewportRuler = _viewportRuler;\n    this._previousHTMLStyles = {\n      top: '',\n      left: ''\n    };\n    this._isEnabled = false;\n    this._document = document;\n  }\n  /** Attaches this scroll strategy to an overlay. */\n  attach() {}\n  /** Blocks page-level scroll while the attached overlay is open. */\n  enable() {\n    if (this._canBeEnabled()) {\n      const root = this._document.documentElement;\n      this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n      // Cache the previous inline styles in case the user had set them.\n      this._previousHTMLStyles.left = root.style.left || '';\n      this._previousHTMLStyles.top = root.style.top || '';\n      // Note: we're using the `html` node, instead of the `body`, because the `body` may\n      // have the user agent margin, whereas the `html` is guaranteed not to have one.\n      root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);\n      root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);\n      root.classList.add('cdk-global-scrollblock');\n      this._isEnabled = true;\n    }\n  }\n  /** Unblocks page-level scroll while the attached overlay is open. */\n  disable() {\n    if (this._isEnabled) {\n      const html = this._document.documentElement;\n      const body = this._document.body;\n      const htmlStyle = html.style;\n      const bodyStyle = body.style;\n      const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';\n      const previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';\n      this._isEnabled = false;\n      htmlStyle.left = this._previousHTMLStyles.left;\n      htmlStyle.top = this._previousHTMLStyles.top;\n      html.classList.remove('cdk-global-scrollblock');\n      // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n      // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n      // Note that we don't mutate the property if the browser doesn't support `scroll-behavior`,\n      // because it can throw off feature detections in `supportsScrollBehavior` which\n      // checks for `'scrollBehavior' in documentElement.style`.\n      if (scrollBehaviorSupported) {\n        htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';\n      }\n      window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n      if (scrollBehaviorSupported) {\n        htmlStyle.scrollBehavior = previousHtmlScrollBehavior;\n        bodyStyle.scrollBehavior = previousBodyScrollBehavior;\n      }\n    }\n  }\n  _canBeEnabled() {\n    // Since the scroll strategies can't be singletons, we have to use a global CSS class\n    // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n    // scrolling multiple times.\n    const html = this._document.documentElement;\n    if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n      return false;\n    }\n    const body = this._document.body;\n    const viewport = this._viewportRuler.getViewportSize();\n    return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n  }\n}\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n  return Error(`Scroll strategy has already been attached.`);\n}\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nclass CloseScrollStrategy {\n  constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n    this._scrollDispatcher = _scrollDispatcher;\n    this._ngZone = _ngZone;\n    this._viewportRuler = _viewportRuler;\n    this._config = _config;\n    this._scrollSubscription = null;\n    /** Detaches the overlay ref and disables the scroll strategy. */\n    this._detach = () => {\n      this.disable();\n      if (this._overlayRef.hasAttached()) {\n        this._ngZone.run(() => this._overlayRef.detach());\n      }\n    };\n  }\n  /** Attaches this scroll strategy to an overlay. */\n  attach(overlayRef) {\n    if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatScrollStrategyAlreadyAttachedError();\n    }\n    this._overlayRef = overlayRef;\n  }\n  /** Enables the closing of the attached overlay on scroll. */\n  enable() {\n    if (this._scrollSubscription) {\n      return;\n    }\n    const stream = this._scrollDispatcher.scrolled(0).pipe(filter(scrollable => {\n      return !scrollable || !this._overlayRef.overlayElement.contains(scrollable.getElementRef().nativeElement);\n    }));\n    if (this._config && this._config.threshold && this._config.threshold > 1) {\n      this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n      this._scrollSubscription = stream.subscribe(() => {\n        const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n        if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {\n          this._detach();\n        } else {\n          this._overlayRef.updatePosition();\n        }\n      });\n    } else {\n      this._scrollSubscription = stream.subscribe(this._detach);\n    }\n  }\n  /** Disables the closing the attached overlay on scroll. */\n  disable() {\n    if (this._scrollSubscription) {\n      this._scrollSubscription.unsubscribe();\n      this._scrollSubscription = null;\n    }\n  }\n  detach() {\n    this.disable();\n    this._overlayRef = null;\n  }\n}\n\n/** Scroll strategy that doesn't do anything. */\nclass NoopScrollStrategy {\n  /** Does nothing, as this scroll strategy is a no-op. */\n  enable() {}\n  /** Does nothing, as this scroll strategy is a no-op. */\n  disable() {}\n  /** Does nothing, as this scroll strategy is a no-op. */\n  attach() {}\n}\n\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is scrolled out of view\n * @docs-private\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n  return scrollContainers.some(containerBounds => {\n    const outsideAbove = element.bottom < containerBounds.top;\n    const outsideBelow = element.top > containerBounds.bottom;\n    const outsideLeft = element.right < containerBounds.left;\n    const outsideRight = element.left > containerBounds.right;\n    return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n  });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is clipped\n * @docs-private\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n  return scrollContainers.some(scrollContainerRect => {\n    const clippedAbove = element.top < scrollContainerRect.top;\n    const clippedBelow = element.bottom > scrollContainerRect.bottom;\n    const clippedLeft = element.left < scrollContainerRect.left;\n    const clippedRight = element.right > scrollContainerRect.right;\n    return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n  });\n}\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nclass RepositionScrollStrategy {\n  constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n    this._scrollDispatcher = _scrollDispatcher;\n    this._viewportRuler = _viewportRuler;\n    this._ngZone = _ngZone;\n    this._config = _config;\n    this._scrollSubscription = null;\n  }\n  /** Attaches this scroll strategy to an overlay. */\n  attach(overlayRef) {\n    if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatScrollStrategyAlreadyAttachedError();\n    }\n    this._overlayRef = overlayRef;\n  }\n  /** Enables repositioning of the attached overlay on scroll. */\n  enable() {\n    if (!this._scrollSubscription) {\n      const throttle = this._config ? this._config.scrollThrottle : 0;\n      this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {\n        this._overlayRef.updatePosition();\n        // TODO(crisbeto): make `close` on by default once all components can handle it.\n        if (this._config && this._config.autoClose) {\n          const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();\n          const {\n            width,\n            height\n          } = this._viewportRuler.getViewportSize();\n          // TODO(crisbeto): include all ancestor scroll containers here once\n          // we have a way of exposing the trigger element to the scroll strategy.\n          const parentRects = [{\n            width,\n            height,\n            bottom: height,\n            right: width,\n            top: 0,\n            left: 0\n          }];\n          if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n            this.disable();\n            this._ngZone.run(() => this._overlayRef.detach());\n          }\n        }\n      });\n    }\n  }\n  /** Disables repositioning of the attached overlay on scroll. */\n  disable() {\n    if (this._scrollSubscription) {\n      this._scrollSubscription.unsubscribe();\n      this._scrollSubscription = null;\n    }\n  }\n  detach() {\n    this.disable();\n    this._overlayRef = null;\n  }\n}\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nclass ScrollStrategyOptions {\n  constructor(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n    this._scrollDispatcher = _scrollDispatcher;\n    this._viewportRuler = _viewportRuler;\n    this._ngZone = _ngZone;\n    /** Do nothing on scroll. */\n    this.noop = () => new NoopScrollStrategy();\n    /**\n     * Close the overlay as soon as the user scrolls.\n     * @param config Configuration to be used inside the scroll strategy.\n     */\n    this.close = config => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);\n    /** Block scrolling. */\n    this.block = () => new BlockScrollStrategy(this._viewportRuler, this._document);\n    /**\n     * Update the overlay's position on scroll.\n     * @param config Configuration to be used inside the scroll strategy.\n     * Allows debouncing the reposition calls.\n     */\n    this.reposition = config => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);\n    this._document = document;\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: ScrollStrategyOptions,\n      deps: [{\n        token: i1.ScrollDispatcher\n      }, {\n        token: i1.ViewportRuler\n      }, {\n        token: i0.NgZone\n      }, {\n        token: DOCUMENT\n      }],\n      target: i0.ɵɵFactoryTarget.Injectable\n    });\n  }\n  static {\n    this.ɵprov = i0.ɵɵngDeclareInjectable({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: ScrollStrategyOptions,\n      providedIn: 'root'\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: ScrollStrategyOptions,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i1.ScrollDispatcher\n  }, {\n    type: i1.ViewportRuler\n  }, {\n    type: i0.NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }]\n});\n\n/** Initial configuration used when creating an overlay. */\nclass OverlayConfig {\n  constructor(config) {\n    /** Strategy to be used when handling scroll events while the overlay is open. */\n    this.scrollStrategy = new NoopScrollStrategy();\n    /** Custom class to add to the overlay pane. */\n    this.panelClass = '';\n    /** Whether the overlay has a backdrop. */\n    this.hasBackdrop = false;\n    /** Custom class to add to the backdrop */\n    this.backdropClass = 'cdk-overlay-dark-backdrop';\n    /**\n     * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n     * Note that this usually doesn't include clicking on links (unless the user is using\n     * the `HashLocationStrategy`).\n     */\n    this.disposeOnNavigation = false;\n    if (config) {\n      // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n      // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n      // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n      const configKeys = Object.keys(config);\n      for (const key of configKeys) {\n        if (config[key] !== undefined) {\n          // TypeScript, as of version 3.5, sees the left-hand-side of this expression\n          // as \"I don't know *which* key this is, so the only valid value is the intersection\n          // of all the possible values.\" In this case, that happens to be `undefined`. TypeScript\n          // is not smart enough to see that the right-hand-side is actually an access of the same\n          // exact type with the same exact key, meaning that the value type must be identical.\n          // So we use `any` to work around this.\n          this[key] = config[key];\n        }\n      }\n    }\n  }\n}\n\n/** The points of the origin element and the overlay element to connect. */\nclass ConnectionPositionPair {\n  constructor(origin, overlay, /** Offset along the X axis. */\n  offsetX, /** Offset along the Y axis. */\n  offsetY, /** Class(es) to be applied to the panel while this position is active. */\n  panelClass) {\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    this.panelClass = panelClass;\n    this.originX = origin.originX;\n    this.originY = origin.originY;\n    this.overlayX = overlay.overlayX;\n    this.overlayY = overlay.overlayY;\n  }\n}\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  @docs-private\n */\nclass ScrollingVisibility {}\n/** The change event emitted by the strategy when a fallback position is used. */\nclass ConnectedOverlayPositionChange {\n  constructor( /** The position used as a result of this change. */\n  connectionPair, /** @docs-private */\n  scrollableViewProperties) {\n    this.connectionPair = connectionPair;\n    this.scrollableViewProperties = scrollableViewProperties;\n  }\n}\n/**\n * Validates whether a vertical position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateVerticalPosition(property, value) {\n  if (value !== 'top' && value !== 'bottom' && value !== 'center') {\n    throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` + `Expected \"top\", \"bottom\" or \"center\".`);\n  }\n}\n/**\n * Validates whether a horizontal position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateHorizontalPosition(property, value) {\n  if (value !== 'start' && value !== 'end' && value !== 'center') {\n    throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` + `Expected \"start\", \"end\" or \"center\".`);\n  }\n}\n\n/**\n * Service for dispatching events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass BaseOverlayDispatcher {\n  constructor(document) {\n    /** Currently attached overlays in the order they were attached. */\n    this._attachedOverlays = [];\n    this._document = document;\n  }\n  ngOnDestroy() {\n    this.detach();\n  }\n  /** Add a new overlay to the list of attached overlay refs. */\n  add(overlayRef) {\n    // Ensure that we don't get the same overlay multiple times.\n    this.remove(overlayRef);\n    this._attachedOverlays.push(overlayRef);\n  }\n  /** Remove an overlay from the list of attached overlay refs. */\n  remove(overlayRef) {\n    const index = this._attachedOverlays.indexOf(overlayRef);\n    if (index > -1) {\n      this._attachedOverlays.splice(index, 1);\n    }\n    // Remove the global listener once there are no more overlays.\n    if (this._attachedOverlays.length === 0) {\n      this.detach();\n    }\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: BaseOverlayDispatcher,\n      deps: [{\n        token: DOCUMENT\n      }],\n      target: i0.ɵɵFactoryTarget.Injectable\n    });\n  }\n  static {\n    this.ɵprov = i0.ɵɵngDeclareInjectable({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: BaseOverlayDispatcher,\n      providedIn: 'root'\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: BaseOverlayDispatcher,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }],\n  ctorParameters: () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }]\n});\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayKeyboardDispatcher extends BaseOverlayDispatcher {\n  constructor(document, /** @breaking-change 14.0.0 _ngZone will be required. */\n  _ngZone) {\n    super(document);\n    this._ngZone = _ngZone;\n    /** Keyboard event listener that will be attached to the body. */\n    this._keydownListener = event => {\n      const overlays = this._attachedOverlays;\n      for (let i = overlays.length - 1; i > -1; i--) {\n        // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.\n        // We want to target the most recent overlay, rather than trying to match where the event came\n        // from, because some components might open an overlay, but keep focus on a trigger element\n        // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,\n        // because we don't want overlays that don't handle keyboard events to block the ones below\n        // them that do.\n        if (overlays[i]._keydownEvents.observers.length > 0) {\n          const keydownEvents = overlays[i]._keydownEvents;\n          /** @breaking-change 14.0.0 _ngZone will be required. */\n          if (this._ngZone) {\n            this._ngZone.run(() => keydownEvents.next(event));\n          } else {\n            keydownEvents.next(event);\n          }\n          break;\n        }\n      }\n    };\n  }\n  /** Add a new overlay to the list of attached overlay refs. */\n  add(overlayRef) {\n    super.add(overlayRef);\n    // Lazily start dispatcher once first overlay is added\n    if (!this._isAttached) {\n      /** @breaking-change 14.0.0 _ngZone will be required. */\n      if (this._ngZone) {\n        this._ngZone.runOutsideAngular(() => this._document.body.addEventListener('keydown', this._keydownListener));\n      } else {\n        this._document.body.addEventListener('keydown', this._keydownListener);\n      }\n      this._isAttached = true;\n    }\n  }\n  /** Detaches the global keyboard event listener. */\n  detach() {\n    if (this._isAttached) {\n      this._document.body.removeEventListener('keydown', this._keydownListener);\n      this._isAttached = false;\n    }\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: OverlayKeyboardDispatcher,\n      deps: [{\n        token: DOCUMENT\n      }, {\n        token: i0.NgZone,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Injectable\n    });\n  }\n  static {\n    this.ɵprov = i0.ɵɵngDeclareInjectable({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: OverlayKeyboardDispatcher,\n      providedIn: 'root'\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: OverlayKeyboardDispatcher,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }],\n  ctorParameters: () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i0.NgZone,\n    decorators: [{\n      type: Optional\n    }]\n  }]\n});\n\n/**\n * Service for dispatching mouse click events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {\n  constructor(document, _platform, /** @breaking-change 14.0.0 _ngZone will be required. */\n  _ngZone) {\n    super(document);\n    this._platform = _platform;\n    this._ngZone = _ngZone;\n    this._cursorStyleIsSet = false;\n    /** Store pointerdown event target to track origin of click. */\n    this._pointerDownListener = event => {\n      this._pointerDownEventTarget = _getEventTarget(event);\n    };\n    /** Click event listener that will be attached to the body propagate phase. */\n    this._clickListener = event => {\n      const target = _getEventTarget(event);\n      // In case of a click event, we want to check the origin of the click\n      // (e.g. in case where a user starts a click inside the overlay and\n      // releases the click outside of it).\n      // This is done by using the event target of the preceding pointerdown event.\n      // Every click event caused by a pointer device has a preceding pointerdown\n      // event, unless the click was programmatically triggered (e.g. in a unit test).\n      const origin = event.type === 'click' && this._pointerDownEventTarget ? this._pointerDownEventTarget : target;\n      // Reset the stored pointerdown event target, to avoid having it interfere\n      // in subsequent events.\n      this._pointerDownEventTarget = null;\n      // We copy the array because the original may be modified asynchronously if the\n      // outsidePointerEvents listener decides to detach overlays resulting in index errors inside\n      // the for loop.\n      const overlays = this._attachedOverlays.slice();\n      // Dispatch the mouse event to the top overlay which has subscribers to its mouse events.\n      // We want to target all overlays for which the click could be considered as outside click.\n      // As soon as we reach an overlay for which the click is not outside click we break off\n      // the loop.\n      for (let i = overlays.length - 1; i > -1; i--) {\n        const overlayRef = overlays[i];\n        if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {\n          continue;\n        }\n        // If it's a click inside the overlay, just break - we should do nothing\n        // If it's an outside click (both origin and target of the click) dispatch the mouse event,\n        // and proceed with the next overlay\n        if (containsPierceShadowDom(overlayRef.overlayElement, target) || containsPierceShadowDom(overlayRef.overlayElement, origin)) {\n          break;\n        }\n        const outsidePointerEvents = overlayRef._outsidePointerEvents;\n        /** @breaking-change 14.0.0 _ngZone will be required. */\n        if (this._ngZone) {\n          this._ngZone.run(() => outsidePointerEvents.next(event));\n        } else {\n          outsidePointerEvents.next(event);\n        }\n      }\n    };\n  }\n  /** Add a new overlay to the list of attached overlay refs. */\n  add(overlayRef) {\n    super.add(overlayRef);\n    // Safari on iOS does not generate click events for non-interactive\n    // elements. However, we want to receive a click for any element outside\n    // the overlay. We can force a \"clickable\" state by setting\n    // `cursor: pointer` on the document body. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event#Safari_Mobile\n    // https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html\n    if (!this._isAttached) {\n      const body = this._document.body;\n      /** @breaking-change 14.0.0 _ngZone will be required. */\n      if (this._ngZone) {\n        this._ngZone.runOutsideAngular(() => this._addEventListeners(body));\n      } else {\n        this._addEventListeners(body);\n      }\n      // click event is not fired on iOS. To make element \"clickable\" we are\n      // setting the cursor to pointer\n      if (this._platform.IOS && !this._cursorStyleIsSet) {\n        this._cursorOriginalValue = body.style.cursor;\n        body.style.cursor = 'pointer';\n        this._cursorStyleIsSet = true;\n      }\n      this._isAttached = true;\n    }\n  }\n  /** Detaches the global keyboard event listener. */\n  detach() {\n    if (this._isAttached) {\n      const body = this._document.body;\n      body.removeEventListener('pointerdown', this._pointerDownListener, true);\n      body.removeEventListener('click', this._clickListener, true);\n      body.removeEventListener('auxclick', this._clickListener, true);\n      body.removeEventListener('contextmenu', this._clickListener, true);\n      if (this._platform.IOS && this._cursorStyleIsSet) {\n        body.style.cursor = this._cursorOriginalValue;\n        this._cursorStyleIsSet = false;\n      }\n      this._isAttached = false;\n    }\n  }\n  _addEventListeners(body) {\n    body.addEventListener('pointerdown', this._pointerDownListener, true);\n    body.addEventListener('click', this._clickListener, true);\n    body.addEventListener('auxclick', this._clickListener, true);\n    body.addEventListener('contextmenu', this._clickListener, true);\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: OverlayOutsideClickDispatcher,\n      deps: [{\n        token: DOCUMENT\n      }, {\n        token: i1$1.Platform\n      }, {\n        token: i0.NgZone,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Injectable\n    });\n  }\n  static {\n    this.ɵprov = i0.ɵɵngDeclareInjectable({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: OverlayOutsideClickDispatcher,\n      providedIn: 'root'\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: OverlayOutsideClickDispatcher,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }],\n  ctorParameters: () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i1$1.Platform\n  }, {\n    type: i0.NgZone,\n    decorators: [{\n      type: Optional\n    }]\n  }]\n});\n/** Version of `Element.contains` that transcends shadow DOM boundaries. */\nfunction containsPierceShadowDom(parent, child) {\n  const supportsShadowRoot = typeof ShadowRoot !== 'undefined' && ShadowRoot;\n  let current = child;\n  while (current) {\n    if (current === parent) {\n      return true;\n    }\n    current = supportsShadowRoot && current instanceof ShadowRoot ? current.host : current.parentNode;\n  }\n  return false;\n}\n\n/** Container inside which all overlays will render. */\nclass OverlayContainer {\n  constructor(document, _platform) {\n    this._platform = _platform;\n    this._document = document;\n  }\n  ngOnDestroy() {\n    this._containerElement?.remove();\n  }\n  /**\n   * This method returns the overlay container element. It will lazily\n   * create the element the first time it is called to facilitate using\n   * the container in non-browser environments.\n   * @returns the container element\n   */\n  getContainerElement() {\n    if (!this._containerElement) {\n      this._createContainer();\n    }\n    return this._containerElement;\n  }\n  /**\n   * Create the overlay container element, which is simply a div\n   * with the 'cdk-overlay-container' class on the document body.\n   */\n  _createContainer() {\n    const containerClass = 'cdk-overlay-container';\n    // TODO(crisbeto): remove the testing check once we have an overlay testing\n    // module or Angular starts tearing down the testing `NgModule`. See:\n    // https://github.com/angular/angular/issues/18831\n    if (this._platform.isBrowser || _isTestEnvironment()) {\n      const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform=\"server\"], ` + `.${containerClass}[platform=\"test\"]`);\n      // Remove any old containers from the opposite platform.\n      // This can happen when transitioning from the server to the client.\n      for (let i = 0; i < oppositePlatformContainers.length; i++) {\n        oppositePlatformContainers[i].remove();\n      }\n    }\n    const container = this._document.createElement('div');\n    container.classList.add(containerClass);\n    // A long time ago we kept adding new overlay containers whenever a new app was instantiated,\n    // but at some point we added logic which clears the duplicate ones in order to avoid leaks.\n    // The new logic was a little too aggressive since it was breaking some legitimate use cases.\n    // To mitigate the problem we made it so that only containers from a different platform are\n    // cleared, but the side-effect was that people started depending on the overly-aggressive\n    // logic to clean up their tests for them. Until we can introduce an overlay-specific testing\n    // module which does the cleanup, we try to detect that we're in a test environment and we\n    // always clear the container. See #17006.\n    // TODO(crisbeto): remove the test environment check once we have an overlay testing module.\n    if (_isTestEnvironment()) {\n      container.setAttribute('platform', 'test');\n    } else if (!this._platform.isBrowser) {\n      container.setAttribute('platform', 'server');\n    }\n    this._document.body.appendChild(container);\n    this._containerElement = container;\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: OverlayContainer,\n      deps: [{\n        token: DOCUMENT\n      }, {\n        token: i1$1.Platform\n      }],\n      target: i0.ɵɵFactoryTarget.Injectable\n    });\n  }\n  static {\n    this.ɵprov = i0.ɵɵngDeclareInjectable({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: OverlayContainer,\n      providedIn: 'root'\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: OverlayContainer,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }],\n  ctorParameters: () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i1$1.Platform\n  }]\n});\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nclass OverlayRef {\n  constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location, _outsideClickDispatcher, _animationsDisabled = false, _injector) {\n    this._portalOutlet = _portalOutlet;\n    this._host = _host;\n    this._pane = _pane;\n    this._config = _config;\n    this._ngZone = _ngZone;\n    this._keyboardDispatcher = _keyboardDispatcher;\n    this._document = _document;\n    this._location = _location;\n    this._outsideClickDispatcher = _outsideClickDispatcher;\n    this._animationsDisabled = _animationsDisabled;\n    this._injector = _injector;\n    this._backdropElement = null;\n    this._backdropClick = new Subject();\n    this._attachments = new Subject();\n    this._detachments = new Subject();\n    this._locationChanges = Subscription.EMPTY;\n    this._backdropClickHandler = event => this._backdropClick.next(event);\n    this._backdropTransitionendHandler = event => {\n      this._disposeBackdrop(event.target);\n    };\n    /** Stream of keydown events dispatched to this overlay. */\n    this._keydownEvents = new Subject();\n    /** Stream of mouse outside events dispatched to this overlay. */\n    this._outsidePointerEvents = new Subject();\n    this._renders = new Subject();\n    if (_config.scrollStrategy) {\n      this._scrollStrategy = _config.scrollStrategy;\n      this._scrollStrategy.attach(this);\n    }\n    this._positionStrategy = _config.positionStrategy;\n    // Users could open the overlay from an `effect`, in which case we need to\n    // run the `afterRender` as `untracked`. We don't recommend that users do\n    // this, but we also don't want to break users who are doing it.\n    this._afterRenderRef = untracked(() => afterRender(() => {\n      this._renders.next();\n    }, {\n      injector: this._injector\n    }));\n  }\n  /** The overlay's HTML element */\n  get overlayElement() {\n    return this._pane;\n  }\n  /** The overlay's backdrop HTML element. */\n  get backdropElement() {\n    return this._backdropElement;\n  }\n  /**\n   * Wrapper around the panel element. Can be used for advanced\n   * positioning where a wrapper with specific styling is\n   * required around the overlay pane.\n   */\n  get hostElement() {\n    return this._host;\n  }\n  /**\n   * Attaches content, given via a Portal, to the overlay.\n   * If the overlay is configured to have a backdrop, it will be created.\n   *\n   * @param portal Portal instance to which to attach the overlay.\n   * @returns The portal attachment result.\n   */\n  attach(portal) {\n    // Insert the host into the DOM before attaching the portal, otherwise\n    // the animations module will skip animations on repeat attachments.\n    if (!this._host.parentElement && this._previousHostParent) {\n      this._previousHostParent.appendChild(this._host);\n    }\n    const attachResult = this._portalOutlet.attach(portal);\n    if (this._positionStrategy) {\n      this._positionStrategy.attach(this);\n    }\n    this._updateStackingOrder();\n    this._updateElementSize();\n    this._updateElementDirection();\n    if (this._scrollStrategy) {\n      this._scrollStrategy.enable();\n    }\n    // Update the position once the overlay is fully rendered before attempting to position it,\n    // as the position may depend on the size of the rendered content.\n    afterNextRender(() => {\n      // The overlay could've been detached before the callback executed.\n      if (this.hasAttached()) {\n        this.updatePosition();\n      }\n    }, {\n      injector: this._injector\n    });\n    // Enable pointer events for the overlay pane element.\n    this._togglePointerEvents(true);\n    if (this._config.hasBackdrop) {\n      this._attachBackdrop();\n    }\n    if (this._config.panelClass) {\n      this._toggleClasses(this._pane, this._config.panelClass, true);\n    }\n    // Only emit the `attachments` event once all other setup is done.\n    this._attachments.next();\n    // Track this overlay by the keyboard dispatcher\n    this._keyboardDispatcher.add(this);\n    if (this._config.disposeOnNavigation) {\n      this._locationChanges = this._location.subscribe(() => this.dispose());\n    }\n    this._outsideClickDispatcher.add(this);\n    // TODO(crisbeto): the null check is here, because the portal outlet returns `any`.\n    // We should be guaranteed for the result to be `ComponentRef | EmbeddedViewRef`, but\n    // `instanceof EmbeddedViewRef` doesn't appear to work at the moment.\n    if (typeof attachResult?.onDestroy === 'function') {\n      // In most cases we control the portal and we know when it is being detached so that\n      // we can finish the disposal process. The exception is if the user passes in a custom\n      // `ViewContainerRef` that isn't destroyed through the overlay API. Note that we use\n      // `detach` here instead of `dispose`, because we don't know if the user intends to\n      // reattach the overlay at a later point. It also has the advantage of waiting for animations.\n      attachResult.onDestroy(() => {\n        if (this.hasAttached()) {\n          // We have to delay the `detach` call, because detaching immediately prevents\n          // other destroy hooks from running. This is likely a framework bug similar to\n          // https://github.com/angular/angular/issues/46119\n          this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()));\n        }\n      });\n    }\n    return attachResult;\n  }\n  /**\n   * Detaches an overlay from a portal.\n   * @returns The portal detachment result.\n   */\n  detach() {\n    if (!this.hasAttached()) {\n      return;\n    }\n    this.detachBackdrop();\n    // When the overlay is detached, the pane element should disable pointer events.\n    // This is necessary because otherwise the pane element will cover the page and disable\n    // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n    this._togglePointerEvents(false);\n    if (this._positionStrategy && this._positionStrategy.detach) {\n      this._positionStrategy.detach();\n    }\n    if (this._scrollStrategy) {\n      this._scrollStrategy.disable();\n    }\n    const detachmentResult = this._portalOutlet.detach();\n    // Only emit after everything is detached.\n    this._detachments.next();\n    // Remove this overlay from keyboard dispatcher tracking.\n    this._keyboardDispatcher.remove(this);\n    // Keeping the host element in the DOM can cause scroll jank, because it still gets\n    // rendered, even though it's transparent and unclickable which is why we remove it.\n    this._detachContentWhenEmpty();\n    this._locationChanges.unsubscribe();\n    this._outsideClickDispatcher.remove(this);\n    return detachmentResult;\n  }\n  /** Cleans up the overlay from the DOM. */\n  dispose() {\n    const isAttached = this.hasAttached();\n    if (this._positionStrategy) {\n      this._positionStrategy.dispose();\n    }\n    this._disposeScrollStrategy();\n    this._disposeBackdrop(this._backdropElement);\n    this._locationChanges.unsubscribe();\n    this._keyboardDispatcher.remove(this);\n    this._portalOutlet.dispose();\n    this._attachments.complete();\n    this._backdropClick.complete();\n    this._keydownEvents.complete();\n    this._outsidePointerEvents.complete();\n    this._outsideClickDispatcher.remove(this);\n    this._host?.remove();\n    this._previousHostParent = this._pane = this._host = null;\n    if (isAttached) {\n      this._detachments.next();\n    }\n    this._detachments.complete();\n    this._afterRenderRef.destroy();\n    this._renders.complete();\n  }\n  /** Whether the overlay has attached content. */\n  hasAttached() {\n    return this._portalOutlet.hasAttached();\n  }\n  /** Gets an observable that emits when the backdrop has been clicked. */\n  backdropClick() {\n    return this._backdropClick;\n  }\n  /** Gets an observable that emits when the overlay has been attached. */\n  attachments() {\n    return this._attachments;\n  }\n  /** Gets an observable that emits when the overlay has been detached. */\n  detachments() {\n    return this._detachments;\n  }\n  /** Gets an observable of keydown events targeted to this overlay. */\n  keydownEvents() {\n    return this._keydownEvents;\n  }\n  /** Gets an observable of pointer events targeted outside this overlay. */\n  outsidePointerEvents() {\n    return this._outsidePointerEvents;\n  }\n  /** Gets the current overlay configuration, which is immutable. */\n  getConfig() {\n    return this._config;\n  }\n  /** Updates the position of the overlay based on the position strategy. */\n  updatePosition() {\n    if (this._positionStrategy) {\n      this._positionStrategy.apply();\n    }\n  }\n  /** Switches to a new position strategy and updates the overlay position. */\n  updatePositionStrategy(strategy) {\n    if (strategy === this._positionStrategy) {\n      return;\n    }\n    if (this._positionStrategy) {\n      this._positionStrategy.dispose();\n    }\n    this._positionStrategy = strategy;\n    if (this.hasAttached()) {\n      strategy.attach(this);\n      this.updatePosition();\n    }\n  }\n  /** Update the size properties of the overlay. */\n  updateSize(sizeConfig) {\n    this._config = {\n      ...this._config,\n      ...sizeConfig\n    };\n    this._updateElementSize();\n  }\n  /** Sets the LTR/RTL direction for the overlay. */\n  setDirection(dir) {\n    this._config = {\n      ...this._config,\n      direction: dir\n    };\n    this._updateElementDirection();\n  }\n  /** Add a CSS class or an array of classes to the overlay pane. */\n  addPanelClass(classes) {\n    if (this._pane) {\n      this._toggleClasses(this._pane, classes, true);\n    }\n  }\n  /** Remove a CSS class or an array of classes from the overlay pane. */\n  removePanelClass(classes) {\n    if (this._pane) {\n      this._toggleClasses(this._pane, classes, false);\n    }\n  }\n  /**\n   * Returns the layout direction of the overlay panel.\n   */\n  getDirection() {\n    const direction = this._config.direction;\n    if (!direction) {\n      return 'ltr';\n    }\n    return typeof direction === 'string' ? direction : direction.value;\n  }\n  /** Switches to a new scroll strategy. */\n  updateScrollStrategy(strategy) {\n    if (strategy === this._scrollStrategy) {\n      return;\n    }\n    this._disposeScrollStrategy();\n    this._scrollStrategy = strategy;\n    if (this.hasAttached()) {\n      strategy.attach(this);\n      strategy.enable();\n    }\n  }\n  /** Updates the text direction of the overlay panel. */\n  _updateElementDirection() {\n    this._host.setAttribute('dir', this.getDirection());\n  }\n  /** Updates the size of the overlay element based on the overlay config. */\n  _updateElementSize() {\n    if (!this._pane) {\n      return;\n    }\n    const style = this._pane.style;\n    style.width = coerceCssPixelValue(this._config.width);\n    style.height = coerceCssPixelValue(this._config.height);\n    style.minWidth = coerceCssPixelValue(this._config.minWidth);\n    style.minHeight = coerceCssPixelValue(this._config.minHeight);\n    style.maxWidth = coerceCssPixelValue(this._config.maxWidth);\n    style.maxHeight = coerceCssPixelValue(this._config.maxHeight);\n  }\n  /** Toggles the pointer events for the overlay pane element. */\n  _togglePointerEvents(enablePointer) {\n    this._pane.style.pointerEvents = enablePointer ? '' : 'none';\n  }\n  /** Attaches a backdrop for this overlay. */\n  _attachBackdrop() {\n    const showingClass = 'cdk-overlay-backdrop-showing';\n    this._backdropElement = this._document.createElement('div');\n    this._backdropElement.classList.add('cdk-overlay-backdrop');\n    if (this._animationsDisabled) {\n      this._backdropElement.classList.add('cdk-overlay-backdrop-noop-animation');\n    }\n    if (this._config.backdropClass) {\n      this._toggleClasses(this._backdropElement, this._config.backdropClass, true);\n    }\n    // Insert the backdrop before the pane in the DOM order,\n    // in order to handle stacked overlays properly.\n    this._host.parentElement.insertBefore(this._backdropElement, this._host);\n    // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n    // action desired when such a click occurs (usually closing the overlay).\n    this._backdropElement.addEventListener('click', this._backdropClickHandler);\n    // Add class to fade-in the backdrop after one frame.\n    if (!this._animationsDisabled && typeof requestAnimationFrame !== 'undefined') {\n      this._ngZone.runOutsideAngular(() => {\n        requestAnimationFrame(() => {\n          if (this._backdropElement) {\n            this._backdropElement.classList.add(showingClass);\n          }\n        });\n      });\n    } else {\n      this._backdropElement.classList.add(showingClass);\n    }\n  }\n  /**\n   * Updates the stacking order of the element, moving it to the top if necessary.\n   * This is required in cases where one overlay was detached, while another one,\n   * that should be behind it, was destroyed. The next time both of them are opened,\n   * the stacking will be wrong, because the detached element's pane will still be\n   * in its original DOM position.\n   */\n  _updateStackingOrder() {\n    if (this._host.nextSibling) {\n      this._host.parentNode.appendChild(this._host);\n    }\n  }\n  /** Detaches the backdrop (if any) associated with the overlay. */\n  detachBackdrop() {\n    const backdropToDetach = this._backdropElement;\n    if (!backdropToDetach) {\n      return;\n    }\n    if (this._animationsDisabled) {\n      this._disposeBackdrop(backdropToDetach);\n      return;\n    }\n    backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n    this._ngZone.runOutsideAngular(() => {\n      backdropToDetach.addEventListener('transitionend', this._backdropTransitionendHandler);\n    });\n    // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n    // In this case we make it unclickable and we try to remove it after a delay.\n    backdropToDetach.style.pointerEvents = 'none';\n    // Run this outside the Angular zone because there's nothing that Angular cares about.\n    // If it were to run inside the Angular zone, every test that used Overlay would have to be\n    // either async or fakeAsync.\n    this._backdropTimeout = this._ngZone.runOutsideAngular(() => setTimeout(() => {\n      this._disposeBackdrop(backdropToDetach);\n    }, 500));\n  }\n  /** Toggles a single CSS class or an array of classes on an element. */\n  _toggleClasses(element, cssClasses, isAdd) {\n    const classes = coerceArray(cssClasses || []).filter(c => !!c);\n    if (classes.length) {\n      isAdd ? element.classList.add(...classes) : element.classList.remove(...classes);\n    }\n  }\n  /** Detaches the overlay content next time the zone stabilizes. */\n  _detachContentWhenEmpty() {\n    // Normally we wouldn't have to explicitly run this outside the `NgZone`, however\n    // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will\n    // be patched to run inside the zone, which will throw us into an infinite loop.\n    this._ngZone.runOutsideAngular(() => {\n      // We can't remove the host here immediately, because the overlay pane's content\n      // might still be animating. This stream helps us avoid interrupting the animation\n      // by waiting for the pane to become empty.\n      const subscription = this._renders.pipe(takeUntil(merge(this._attachments, this._detachments))).subscribe(() => {\n        // Needs a couple of checks for the pane and host, because\n        // they may have been removed by the time the zone stabilizes.\n        if (!this._pane || !this._host || this._pane.children.length === 0) {\n          if (this._pane && this._config.panelClass) {\n            this._toggleClasses(this._pane, this._config.panelClass, false);\n          }\n          if (this._host && this._host.parentElement) {\n            this._previousHostParent = this._host.parentElement;\n            this._host.remove();\n          }\n          subscription.unsubscribe();\n        }\n      });\n    });\n  }\n  /** Disposes of a scroll strategy. */\n  _disposeScrollStrategy() {\n    const scrollStrategy = this._scrollStrategy;\n    if (scrollStrategy) {\n      scrollStrategy.disable();\n      if (scrollStrategy.detach) {\n        scrollStrategy.detach();\n      }\n    }\n  }\n  /** Removes a backdrop element from the DOM. */\n  _disposeBackdrop(backdrop) {\n    if (backdrop) {\n      backdrop.removeEventListener('click', this._backdropClickHandler);\n      backdrop.removeEventListener('transitionend', this._backdropTransitionendHandler);\n      backdrop.remove();\n      // It is possible that a new portal has been attached to this overlay since we started\n      // removing the backdrop. If that is the case, only clear the backdrop reference if it\n      // is still the same instance that we started to remove.\n      if (this._backdropElement === backdrop) {\n        this._backdropElement = null;\n      }\n    }\n    if (this._backdropTimeout) {\n      clearTimeout(this._backdropTimeout);\n      this._backdropTimeout = undefined;\n    }\n  }\n}\n\n// TODO: refactor clipping detection into a separate thing (part of scrolling module)\n// TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n/** Class to be added to the overlay bounding box. */\nconst boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nclass FlexibleConnectedPositionStrategy {\n  /** Ordered list of preferred positions, from most to least desirable. */\n  get positions() {\n    return this._preferredPositions;\n  }\n  constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {\n    this._viewportRuler = _viewportRuler;\n    this._document = _document;\n    this._platform = _platform;\n    this._overlayContainer = _overlayContainer;\n    /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n    this._lastBoundingBoxSize = {\n      width: 0,\n      height: 0\n    };\n    /** Whether the overlay was pushed in a previous positioning. */\n    this._isPushed = false;\n    /** Whether the overlay can be pushed on-screen on the initial open. */\n    this._canPush = true;\n    /** Whether the overlay can grow via flexible width/height after the initial open. */\n    this._growAfterOpen = false;\n    /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n    this._hasFlexibleDimensions = true;\n    /** Whether the overlay position is locked. */\n    this._positionLocked = false;\n    /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n    this._viewportMargin = 0;\n    /** The Scrollable containers used to check scrollable view properties on position change. */\n    this._scrollables = [];\n    /** Ordered list of preferred positions, from most to least desirable. */\n    this._preferredPositions = [];\n    /** Subject that emits whenever the position changes. */\n    this._positionChanges = new Subject();\n    /** Subscription to viewport size changes. */\n    this._resizeSubscription = Subscription.EMPTY;\n    /** Default offset for the overlay along the x axis. */\n    this._offsetX = 0;\n    /** Default offset for the overlay along the y axis. */\n    this._offsetY = 0;\n    /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n    this._appliedPanelClasses = [];\n    /** Observable sequence of position changes. */\n    this.positionChanges = this._positionChanges;\n    this.setOrigin(connectedTo);\n  }\n  /** Attaches this position strategy to an overlay. */\n  attach(overlayRef) {\n    if (this._overlayRef && overlayRef !== this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('This position strategy is already attached to an overlay');\n    }\n    this._validatePositions();\n    overlayRef.hostElement.classList.add(boundingBoxClass);\n    this._overlayRef = overlayRef;\n    this._boundingBox = overlayRef.hostElement;\n    this._pane = overlayRef.overlayElement;\n    this._isDisposed = false;\n    this._isInitialRender = true;\n    this._lastPosition = null;\n    this._resizeSubscription.unsubscribe();\n    this._resizeSubscription = this._viewportRuler.change().subscribe(() => {\n      // When the window is resized, we want to trigger the next reposition as if it\n      // was an initial render, in order for the strategy to pick a new optimal position,\n      // otherwise position locking will cause it to stay at the old one.\n      this._isInitialRender = true;\n      this.apply();\n    });\n  }\n  /**\n   * Updates the position of the overlay element, using whichever preferred position relative\n   * to the origin best fits on-screen.\n   *\n   * The selection of a position goes as follows:\n   *  - If any positions fit completely within the viewport as-is,\n   *      choose the first position that does so.\n   *  - If flexible dimensions are enabled and at least one satisfies the given minimum width/height,\n   *      choose the position with the greatest available size modified by the positions' weight.\n   *  - If pushing is enabled, take the position that went off-screen the least and push it\n   *      on-screen.\n   *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n   * @docs-private\n   */\n  apply() {\n    // We shouldn't do anything if the strategy was disposed or we're on the server.\n    if (this._isDisposed || !this._platform.isBrowser) {\n      return;\n    }\n    // If the position has been applied already (e.g. when the overlay was opened) and the\n    // consumer opted into locking in the position, re-use the old position, in order to\n    // prevent the overlay from jumping around.\n    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n      this.reapplyLastPosition();\n      return;\n    }\n    this._clearPanelClasses();\n    this._resetOverlayElementStyles();\n    this._resetBoundingBoxStyles();\n    // We need the bounding rects for the origin, the overlay and the container to determine how to position\n    // the overlay relative to the origin.\n    // We use the viewport rect to determine whether a position would go off-screen.\n    this._viewportRect = this._getNarrowedViewportRect();\n    this._originRect = this._getOriginRect();\n    this._overlayRect = this._pane.getBoundingClientRect();\n    this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();\n    const originRect = this._originRect;\n    const overlayRect = this._overlayRect;\n    const viewportRect = this._viewportRect;\n    const containerRect = this._containerRect;\n    // Positions where the overlay will fit with flexible dimensions.\n    const flexibleFits = [];\n    // Fallback if none of the preferred positions fit within the viewport.\n    let fallback;\n    // Go through each of the preferred positions looking for a good fit.\n    // If a good fit is found, it will be applied immediately.\n    for (let pos of this._preferredPositions) {\n      // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n      let originPoint = this._getOriginPoint(originRect, containerRect, pos);\n      // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n      // overlay in this position. We use the top-left corner for calculations and later translate\n      // this into an appropriate (top, left, bottom, right) style.\n      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n      // Calculate how well the overlay would fit into the viewport with this point.\n      let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n      // If the overlay, without any further work, fits into the viewport, use this position.\n      if (overlayFit.isCompletelyWithinViewport) {\n        this._isPushed = false;\n        this._applyPosition(pos, originPoint);\n        return;\n      }\n      // If the overlay has flexible dimensions, we can use this position\n      // so long as there's enough space for the minimum dimensions.\n      if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n        // Save positions where the overlay will fit with flexible dimensions. We will use these\n        // if none of the positions fit *without* flexible dimensions.\n        flexibleFits.push({\n          position: pos,\n          origin: originPoint,\n          overlayRect,\n          boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)\n        });\n        continue;\n      }\n      // If the current preferred position does not fit on the screen, remember the position\n      // if it has more visible area on-screen than we've seen and move onto the next preferred\n      // position.\n      if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n        fallback = {\n          overlayFit,\n          overlayPoint,\n          originPoint,\n          position: pos,\n          overlayRect\n        };\n      }\n    }\n    // If there are any positions where the overlay would fit with flexible dimensions, choose the\n    // one that has the greatest area available modified by the position's weight\n    if (flexibleFits.length) {\n      let bestFit = null;\n      let bestScore = -1;\n      for (const fit of flexibleFits) {\n        const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n        if (score > bestScore) {\n          bestScore = score;\n          bestFit = fit;\n        }\n      }\n      this._isPushed = false;\n      this._applyPosition(bestFit.position, bestFit.origin);\n      return;\n    }\n    // When none of the preferred positions fit within the viewport, take the position\n    // that went off-screen the least and attempt to push it on-screen.\n    if (this._canPush) {\n      // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n      this._isPushed = true;\n      this._applyPosition(fallback.position, fallback.originPoint);\n      return;\n    }\n    // All options for getting the overlay within the viewport have been exhausted, so go with the\n    // position that went off-screen the least.\n    this._applyPosition(fallback.position, fallback.originPoint);\n  }\n  detach() {\n    this._clearPanelClasses();\n    this._lastPosition = null;\n    this._previousPushAmount = null;\n    this._resizeSubscription.unsubscribe();\n  }\n  /** Cleanup after the element gets destroyed. */\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n    // We can't use `_resetBoundingBoxStyles` here, because it resets\n    // some properties to zero, rather than removing them.\n    if (this._boundingBox) {\n      extendStyles(this._boundingBox.style, {\n        top: '',\n        left: '',\n        right: '',\n        bottom: '',\n        height: '',\n        width: '',\n        alignItems: '',\n        justifyContent: ''\n      });\n    }\n    if (this._pane) {\n      this._resetOverlayElementStyles();\n    }\n    if (this._overlayRef) {\n      this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n    }\n    this.detach();\n    this._positionChanges.complete();\n    this._overlayRef = this._boundingBox = null;\n    this._isDisposed = true;\n  }\n  /**\n   * This re-aligns the overlay element with the trigger in its last calculated position,\n   * even if a position higher in the \"preferred positions\" list would now fit. This\n   * allows one to re-align the panel without changing the orientation of the panel.\n   */\n  reapplyLastPosition() {\n    if (this._isDisposed || !this._platform.isBrowser) {\n      return;\n    }\n    const lastPosition = this._lastPosition;\n    if (lastPosition) {\n      this._originRect = this._getOriginRect();\n      this._overlayRect = this._pane.getBoundingClientRect();\n      this._viewportRect = this._getNarrowedViewportRect();\n      this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();\n      const originPoint = this._getOriginPoint(this._originRect, this._containerRect, lastPosition);\n      this._applyPosition(lastPosition, originPoint);\n    } else {\n      this.apply();\n    }\n  }\n  /**\n   * Sets the list of Scrollable containers that host the origin element so that\n   * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n   * Scrollable must be an ancestor element of the strategy's origin element.\n   */\n  withScrollableContainers(scrollables) {\n    this._scrollables = scrollables;\n    return this;\n  }\n  /**\n   * Adds new preferred positions.\n   * @param positions List of positions options for this overlay.\n   */\n  withPositions(positions) {\n    this._preferredPositions = positions;\n    // If the last calculated position object isn't part of the positions anymore, clear\n    // it in order to avoid it being picked up if the consumer tries to re-apply.\n    if (positions.indexOf(this._lastPosition) === -1) {\n      this._lastPosition = null;\n    }\n    this._validatePositions();\n    return this;\n  }\n  /**\n   * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n   * @param margin Required margin between the overlay and the viewport edge in pixels.\n   */\n  withViewportMargin(margin) {\n    this._viewportMargin = margin;\n    return this;\n  }\n  /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n  withFlexibleDimensions(flexibleDimensions = true) {\n    this._hasFlexibleDimensions = flexibleDimensions;\n    return this;\n  }\n  /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n  withGrowAfterOpen(growAfterOpen = true) {\n    this._growAfterOpen = growAfterOpen;\n    return this;\n  }\n  /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n  withPush(canPush = true) {\n    this._canPush = canPush;\n    return this;\n  }\n  /**\n   * Sets whether the overlay's position should be locked in after it is positioned\n   * initially. When an overlay is locked in, it won't attempt to reposition itself\n   * when the position is re-applied (e.g. when the user scrolls away).\n   * @param isLocked Whether the overlay should locked in.\n   */\n  withLockedPosition(isLocked = true) {\n    this._positionLocked = isLocked;\n    return this;\n  }\n  /**\n   * Sets the origin, relative to which to position the overlay.\n   * Using an element origin is useful for building components that need to be positioned\n   * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n   * used for cases like contextual menus which open relative to the user's pointer.\n   * @param origin Reference to the new origin.\n   */\n  setOrigin(origin) {\n    this._origin = origin;\n    return this;\n  }\n  /**\n   * Sets the default offset for the overlay's connection point on the x-axis.\n   * @param offset New offset in the X axis.\n   */\n  withDefaultOffsetX(offset) {\n    this._offsetX = offset;\n    return this;\n  }\n  /**\n   * Sets the default offset for the overlay's connection point on the y-axis.\n   * @param offset New offset in the Y axis.\n   */\n  withDefaultOffsetY(offset) {\n    this._offsetY = offset;\n    return this;\n  }\n  /**\n   * Configures that the position strategy should set a `transform-origin` on some elements\n   * inside the overlay, depending on the current position that is being applied. This is\n   * useful for the cases where the origin of an animation can change depending on the\n   * alignment of the overlay.\n   * @param selector CSS selector that will be used to find the target\n   *    elements onto which to set the transform origin.\n   */\n  withTransformOriginOn(selector) {\n    this._transformOriginSelector = selector;\n    return this;\n  }\n  /**\n   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n   */\n  _getOriginPoint(originRect, containerRect, pos) {\n    let x;\n    if (pos.originX == 'center') {\n      // Note: when centering we should always use the `left`\n      // offset, otherwise the position will be wrong in RTL.\n      x = originRect.left + originRect.width / 2;\n    } else {\n      const startX = this._isRtl() ? originRect.right : originRect.left;\n      const endX = this._isRtl() ? originRect.left : originRect.right;\n      x = pos.originX == 'start' ? startX : endX;\n    }\n    // When zooming in Safari the container rectangle contains negative values for the position\n    // and we need to re-add them to the calculated coordinates.\n    if (containerRect.left < 0) {\n      x -= containerRect.left;\n    }\n    let y;\n    if (pos.originY == 'center') {\n      y = originRect.top + originRect.height / 2;\n    } else {\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n    }\n    // Normally the containerRect's top value would be zero, however when the overlay is attached to an input\n    // (e.g. in an autocomplete), mobile browsers will shift everything in order to put the input in the middle\n    // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n    // otherwise our positioning will be thrown off.\n    // Additionally, when zooming in Safari this fixes the vertical position.\n    if (containerRect.top < 0) {\n      y -= containerRect.top;\n    }\n    return {\n      x,\n      y\n    };\n  }\n  /**\n   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n   * origin point to which the overlay should be connected.\n   */\n  _getOverlayPoint(originPoint, overlayRect, pos) {\n    // Calculate the (overlayStartX, overlayStartY), the start of the\n    // potential overlay position relative to the origin point.\n    let overlayStartX;\n    if (pos.overlayX == 'center') {\n      overlayStartX = -overlayRect.width / 2;\n    } else if (pos.overlayX === 'start') {\n      overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n    } else {\n      overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n    }\n    let overlayStartY;\n    if (pos.overlayY == 'center') {\n      overlayStartY = -overlayRect.height / 2;\n    } else {\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n    }\n    // The (x, y) coordinates of the overlay.\n    return {\n      x: originPoint.x + overlayStartX,\n      y: originPoint.y + overlayStartY\n    };\n  }\n  /** Gets how well an overlay at the given point will fit within the viewport. */\n  _getOverlayFit(point, rawOverlayRect, viewport, position) {\n    // Round the overlay rect when comparing against the\n    // viewport, because the viewport is always rounded.\n    const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n    let {\n      x,\n      y\n    } = point;\n    let offsetX = this._getOffset(position, 'x');\n    let offsetY = this._getOffset(position, 'y');\n    // Account for the offsets since they could push the overlay out of the viewport.\n    if (offsetX) {\n      x += offsetX;\n    }\n    if (offsetY) {\n      y += offsetY;\n    }\n    // How much the overlay would overflow at this position, on each side.\n    let leftOverflow = 0 - x;\n    let rightOverflow = x + overlay.width - viewport.width;\n    let topOverflow = 0 - y;\n    let bottomOverflow = y + overlay.height - viewport.height;\n    // Visible parts of the element on each axis.\n    let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n    let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n    let visibleArea = visibleWidth * visibleHeight;\n    return {\n      visibleArea,\n      isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,\n      fitsInViewportVertically: visibleHeight === overlay.height,\n      fitsInViewportHorizontally: visibleWidth == overlay.width\n    };\n  }\n  /**\n   * Whether the overlay can fit within the viewport when it may resize either its width or height.\n   * @param fit How well the overlay fits in the viewport at some position.\n   * @param point The (x, y) coordinates of the overlay at some position.\n   * @param viewport The geometry of the viewport.\n   */\n  _canFitWithFlexibleDimensions(fit, point, viewport) {\n    if (this._hasFlexibleDimensions) {\n      const availableHeight = viewport.bottom - point.y;\n      const availableWidth = viewport.right - point.x;\n      const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);\n      const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);\n      const verticalFit = fit.fitsInViewportVertically || minHeight != null && minHeight <= availableHeight;\n      const horizontalFit = fit.fitsInViewportHorizontally || minWidth != null && minWidth <= availableWidth;\n      return verticalFit && horizontalFit;\n    }\n    return false;\n  }\n  /**\n   * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n   * the viewport, the top-left corner will be pushed on-screen (with overflow occurring on the\n   * right and bottom).\n   *\n   * @param start Starting point from which the overlay is pushed.\n   * @param rawOverlayRect Dimensions of the overlay.\n   * @param scrollPosition Current viewport scroll position.\n   * @returns The point at which to position the overlay after pushing. This is effectively a new\n   *     originPoint.\n   */\n  _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {\n    // If the position is locked and we've pushed the overlay already, reuse the previous push\n    // amount, rather than pushing it again. If we were to continue pushing, the element would\n    // remain in the viewport, which goes against the expectations when position locking is enabled.\n    if (this._previousPushAmount && this._positionLocked) {\n      return {\n        x: start.x + this._previousPushAmount.x,\n        y: start.y + this._previousPushAmount.y\n      };\n    }\n    // Round the overlay rect when comparing against the\n    // viewport, because the viewport is always rounded.\n    const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n    const viewport = this._viewportRect;\n    // Determine how much the overlay goes outside the viewport on each\n    // side, which we'll use to decide which direction to push it.\n    const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);\n    const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);\n    const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n    const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n    // Amount by which to push the overlay in each axis such that it remains on-screen.\n    let pushX = 0;\n    let pushY = 0;\n    // If the overlay fits completely within the bounds of the viewport, push it from whichever\n    // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n    // viewport and allow for the trailing end of the overlay to go out of bounds.\n    if (overlay.width <= viewport.width) {\n      pushX = overflowLeft || -overflowRight;\n    } else {\n      pushX = start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0;\n    }\n    if (overlay.height <= viewport.height) {\n      pushY = overflowTop || -overflowBottom;\n    } else {\n      pushY = start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0;\n    }\n    this._previousPushAmount = {\n      x: pushX,\n      y: pushY\n    };\n    return {\n      x: start.x + pushX,\n      y: start.y + pushY\n    };\n  }\n  /**\n   * Applies a computed position to the overlay and emits a position change.\n   * @param position The position preference\n   * @param originPoint The point on the origin element where the overlay is connected.\n   */\n  _applyPosition(position, originPoint) {\n    this._setTransformOrigin(position);\n    this._setOverlayElementStyles(originPoint, position);\n    this._setBoundingBoxStyles(originPoint, position);\n    if (position.panelClass) {\n      this._addPanelClasses(position.panelClass);\n    }\n    // Notify that the position has been changed along with its change properties.\n    // We only emit if we've got any subscriptions, because the scroll visibility\n    // calculations can be somewhat expensive.\n    if (this._positionChanges.observers.length) {\n      const scrollVisibility = this._getScrollVisibility();\n      // We're recalculating on scroll, but we only want to emit if anything\n      // changed since downstream code might be hitting the `NgZone`.\n      if (position !== this._lastPosition || !this._lastScrollVisibility || !compareScrollVisibility(this._lastScrollVisibility, scrollVisibility)) {\n        const changeEvent = new ConnectedOverlayPositionChange(position, scrollVisibility);\n        this._positionChanges.next(changeEvent);\n      }\n      this._lastScrollVisibility = scrollVisibility;\n    }\n    // Save the last connected position in case the position needs to be re-calculated.\n    this._lastPosition = position;\n    this._isInitialRender = false;\n  }\n  /** Sets the transform origin based on the configured selector and the passed-in position.  */\n  _setTransformOrigin(position) {\n    if (!this._transformOriginSelector) {\n      return;\n    }\n    const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);\n    let xOrigin;\n    let yOrigin = position.overlayY;\n    if (position.overlayX === 'center') {\n      xOrigin = 'center';\n    } else if (this._isRtl()) {\n      xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n    } else {\n      xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n    }\n    for (let i = 0; i < elements.length; i++) {\n      elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;\n    }\n  }\n  /**\n   * Gets the position and size of the overlay's sizing container.\n   *\n   * This method does no measuring and applies no styles so that we can cheaply compute the\n   * bounds for all positions and choose the best fit based on these results.\n   */\n  _calculateBoundingBoxRect(origin, position) {\n    const viewport = this._viewportRect;\n    const isRtl = this._isRtl();\n    let height, top, bottom;\n    if (position.overlayY === 'top') {\n      // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n      top = origin.y;\n      height = viewport.height - top + this._viewportMargin;\n    } else if (position.overlayY === 'bottom') {\n      // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n      // the viewport margin back in, because the viewport rect is narrowed down to remove the\n      // margin, whereas the `origin` position is calculated based on its `DOMRect`.\n      bottom = viewport.height - origin.y + this._viewportMargin * 2;\n      height = viewport.height - bottom + this._viewportMargin;\n    } else {\n      // If neither top nor bottom, it means that the overlay is vertically centered on the\n      // origin point. Note that we want the position relative to the viewport, rather than\n      // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n      // `origin.y - viewport.top`.\n      const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);\n      const previousHeight = this._lastBoundingBoxSize.height;\n      height = smallestDistanceToViewportEdge * 2;\n      top = origin.y - smallestDistanceToViewportEdge;\n      if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n        top = origin.y - previousHeight / 2;\n      }\n    }\n    // The overlay is opening 'right-ward' (the content flows to the right).\n    const isBoundedByRightViewportEdge = position.overlayX === 'start' && !isRtl || position.overlayX === 'end' && isRtl;\n    // The overlay is opening 'left-ward' (the content flows to the left).\n    const isBoundedByLeftViewportEdge = position.overlayX === 'end' && !isRtl || position.overlayX === 'start' && isRtl;\n    let width, left, right;\n    if (isBoundedByLeftViewportEdge) {\n      right = viewport.width - origin.x + this._viewportMargin * 2;\n      width = origin.x - this._viewportMargin;\n    } else if (isBoundedByRightViewportEdge) {\n      left = origin.x;\n      width = viewport.right - origin.x;\n    } else {\n      // If neither start nor end, it means that the overlay is horizontally centered on the\n      // origin point. Note that we want the position relative to the viewport, rather than\n      // the page, which is why we don't use something like `viewport.right - origin.x` and\n      // `origin.x - viewport.left`.\n      const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);\n      const previousWidth = this._lastBoundingBoxSize.width;\n      width = smallestDistanceToViewportEdge * 2;\n      left = origin.x - smallestDistanceToViewportEdge;\n      if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n        left = origin.x - previousWidth / 2;\n      }\n    }\n    return {\n      top: top,\n      left: left,\n      bottom: bottom,\n      right: right,\n      width,\n      height\n    };\n  }\n  /**\n   * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n   * origin's connection point and stretches to the bounds of the viewport.\n   *\n   * @param origin The point on the origin element where the overlay is connected.\n   * @param position The position preference\n   */\n  _setBoundingBoxStyles(origin, position) {\n    const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n    // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n    // when applying a new size.\n    if (!this._isInitialRender && !this._growAfterOpen) {\n      boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n      boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n    }\n    const styles = {};\n    if (this._hasExactPosition()) {\n      styles.top = styles.left = '0';\n      styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = '';\n      styles.width = styles.height = '100%';\n    } else {\n      const maxHeight = this._overlayRef.getConfig().maxHeight;\n      const maxWidth = this._overlayRef.getConfig().maxWidth;\n      styles.height = coerceCssPixelValue(boundingBoxRect.height);\n      styles.top = coerceCssPixelValue(boundingBoxRect.top);\n      styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);\n      styles.width = coerceCssPixelValue(boundingBoxRect.width);\n      styles.left = coerceCssPixelValue(boundingBoxRect.left);\n      styles.right = coerceCssPixelValue(boundingBoxRect.right);\n      // Push the pane content towards the proper direction.\n      if (position.overlayX === 'center') {\n        styles.alignItems = 'center';\n      } else {\n        styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n      }\n      if (position.overlayY === 'center') {\n        styles.justifyContent = 'center';\n      } else {\n        styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n      }\n      if (maxHeight) {\n        styles.maxHeight = coerceCssPixelValue(maxHeight);\n      }\n      if (maxWidth) {\n        styles.maxWidth = coerceCssPixelValue(maxWidth);\n      }\n    }\n    this._lastBoundingBoxSize = boundingBoxRect;\n    extendStyles(this._boundingBox.style, styles);\n  }\n  /** Resets the styles for the bounding box so that a new positioning can be computed. */\n  _resetBoundingBoxStyles() {\n    extendStyles(this._boundingBox.style, {\n      top: '0',\n      left: '0',\n      right: '0',\n      bottom: '0',\n      height: '',\n      width: '',\n      alignItems: '',\n      justifyContent: ''\n    });\n  }\n  /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n  _resetOverlayElementStyles() {\n    extendStyles(this._pane.style, {\n      top: '',\n      left: '',\n      bottom: '',\n      right: '',\n      position: '',\n      transform: ''\n    });\n  }\n  /** Sets positioning styles to the overlay element. */\n  _setOverlayElementStyles(originPoint, position) {\n    const styles = {};\n    const hasExactPosition = this._hasExactPosition();\n    const hasFlexibleDimensions = this._hasFlexibleDimensions;\n    const config = this._overlayRef.getConfig();\n    if (hasExactPosition) {\n      const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n      extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n      extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n    } else {\n      styles.position = 'static';\n    }\n    // Use a transform to apply the offsets. We do this because the `center` positions rely on\n    // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n    // off the position. We also can't use margins, because they won't have an effect in some\n    // cases where the element doesn't have anything to \"push off of\". Finally, this works\n    // better both with flexible and non-flexible positioning.\n    let transformString = '';\n    let offsetX = this._getOffset(position, 'x');\n    let offsetY = this._getOffset(position, 'y');\n    if (offsetX) {\n      transformString += `translateX(${offsetX}px) `;\n    }\n    if (offsetY) {\n      transformString += `translateY(${offsetY}px)`;\n    }\n    styles.transform = transformString.trim();\n    // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n    // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n    // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n    // Note that this doesn't apply when we have an exact position, in which case we do want to\n    // apply them because they'll be cleared from the bounding box.\n    if (config.maxHeight) {\n      if (hasExactPosition) {\n        styles.maxHeight = coerceCssPixelValue(config.maxHeight);\n      } else if (hasFlexibleDimensions) {\n        styles.maxHeight = '';\n      }\n    }\n    if (config.maxWidth) {\n      if (hasExactPosition) {\n        styles.maxWidth = coerceCssPixelValue(config.maxWidth);\n      } else if (hasFlexibleDimensions) {\n        styles.maxWidth = '';\n      }\n    }\n    extendStyles(this._pane.style, styles);\n  }\n  /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n  _getExactOverlayY(position, originPoint, scrollPosition) {\n    // Reset any existing styles. This is necessary in case the\n    // preferred position has changed since the last `apply`.\n    let styles = {\n      top: '',\n      bottom: ''\n    };\n    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n    if (this._isPushed) {\n      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n    }\n    // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n    // above or below the origin and the direction in which the element will expand.\n    if (position.overlayY === 'bottom') {\n      // When using `bottom`, we adjust the y position such that it is the distance\n      // from the bottom of the viewport rather than the top.\n      const documentHeight = this._document.documentElement.clientHeight;\n      styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;\n    } else {\n      styles.top = coerceCssPixelValue(overlayPoint.y);\n    }\n    return styles;\n  }\n  /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n  _getExactOverlayX(position, originPoint, scrollPosition) {\n    // Reset any existing styles. This is necessary in case the preferred position has\n    // changed since the last `apply`.\n    let styles = {\n      left: '',\n      right: ''\n    };\n    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n    if (this._isPushed) {\n      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n    }\n    // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n    // or \"after\" the origin, which determines the direction in which the element will expand.\n    // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n    // page is in RTL or LTR.\n    let horizontalStyleProperty;\n    if (this._isRtl()) {\n      horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n    } else {\n      horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n    }\n    // When we're setting `right`, we adjust the x position such that it is the distance\n    // from the right edge of the viewport rather than the left edge.\n    if (horizontalStyleProperty === 'right') {\n      const documentWidth = this._document.documentElement.clientWidth;\n      styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;\n    } else {\n      styles.left = coerceCssPixelValue(overlayPoint.x);\n    }\n    return styles;\n  }\n  /**\n   * Gets the view properties of the trigger and overlay, including whether they are clipped\n   * or completely outside the view of any of the strategy's scrollables.\n   */\n  _getScrollVisibility() {\n    // Note: needs fresh rects since the position could've changed.\n    const originBounds = this._getOriginRect();\n    const overlayBounds = this._pane.getBoundingClientRect();\n    // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n    // every time, we should be able to use the scrollTop of the containers if the size of those\n    // containers hasn't changed.\n    const scrollContainerBounds = this._scrollables.map(scrollable => {\n      return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n    });\n    return {\n      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds)\n    };\n  }\n  /** Subtracts the amount that an element is overflowing on an axis from its length. */\n  _subtractOverflows(length, ...overflows) {\n    return overflows.reduce((currentValue, currentOverflow) => {\n      return currentValue - Math.max(currentOverflow, 0);\n    }, length);\n  }\n  /** Narrows the given viewport rect by the current _viewportMargin. */\n  _getNarrowedViewportRect() {\n    // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n    // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n    // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n    // and `innerHeight` that do. This is necessary, because the overlay container uses\n    // 100% `width` and `height` which don't include the scrollbar either.\n    const width = this._document.documentElement.clientWidth;\n    const height = this._document.documentElement.clientHeight;\n    const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n    return {\n      top: scrollPosition.top + this._viewportMargin,\n      left: scrollPosition.left + this._viewportMargin,\n      right: scrollPosition.left + width - this._viewportMargin,\n      bottom: scrollPosition.top + height - this._viewportMargin,\n      width: width - 2 * this._viewportMargin,\n      height: height - 2 * this._viewportMargin\n    };\n  }\n  /** Whether the we're dealing with an RTL context */\n  _isRtl() {\n    return this._overlayRef.getDirection() === 'rtl';\n  }\n  /** Determines whether the overlay uses exact or flexible positioning. */\n  _hasExactPosition() {\n    return !this._hasFlexibleDimensions || this._isPushed;\n  }\n  /** Retrieves the offset of a position along the x or y axis. */\n  _getOffset(position, axis) {\n    if (axis === 'x') {\n      // We don't do something like `position['offset' + axis]` in\n      // order to avoid breaking minifiers that rename properties.\n      return position.offsetX == null ? this._offsetX : position.offsetX;\n    }\n    return position.offsetY == null ? this._offsetY : position.offsetY;\n  }\n  /** Validates that the current position match the expected values. */\n  _validatePositions() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._preferredPositions.length) {\n        throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n      }\n      // TODO(crisbeto): remove these once Angular's template type\n      // checking is advanced enough to catch these cases.\n      this._preferredPositions.forEach(pair => {\n        validateHorizontalPosition('originX', pair.originX);\n        validateVerticalPosition('originY', pair.originY);\n        validateHorizontalPosition('overlayX', pair.overlayX);\n        validateVerticalPosition('overlayY', pair.overlayY);\n      });\n    }\n  }\n  /** Adds a single CSS class or an array of classes on the overlay panel. */\n  _addPanelClasses(cssClasses) {\n    if (this._pane) {\n      coerceArray(cssClasses).forEach(cssClass => {\n        if (cssClass !== '' && this._appliedPanelClasses.indexOf(cssClass) === -1) {\n          this._appliedPanelClasses.push(cssClass);\n          this._pane.classList.add(cssClass);\n        }\n      });\n    }\n  }\n  /** Clears the classes that the position strategy has applied from the overlay panel. */\n  _clearPanelClasses() {\n    if (this._pane) {\n      this._appliedPanelClasses.forEach(cssClass => {\n        this._pane.classList.remove(cssClass);\n      });\n      this._appliedPanelClasses = [];\n    }\n  }\n  /** Returns the DOMRect of the current origin. */\n  _getOriginRect() {\n    const origin = this._origin;\n    if (origin instanceof ElementRef) {\n      return origin.nativeElement.getBoundingClientRect();\n    }\n    // Check for Element so SVG elements are also supported.\n    if (origin instanceof Element) {\n      return origin.getBoundingClientRect();\n    }\n    const width = origin.width || 0;\n    const height = origin.height || 0;\n    // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n    return {\n      top: origin.y,\n      bottom: origin.y + height,\n      left: origin.x,\n      right: origin.x + width,\n      height,\n      width\n    };\n  }\n}\n/** Shallow-extends a stylesheet object with another stylesheet object. */\nfunction extendStyles(destination, source) {\n  for (let key in source) {\n    if (source.hasOwnProperty(key)) {\n      destination[key] = source[key];\n    }\n  }\n  return destination;\n}\n/**\n * Extracts the pixel value as a number from a value, if it's a number\n * or a CSS pixel string (e.g. `1337px`). Otherwise returns null.\n */\nfunction getPixelValue(input) {\n  if (typeof input !== 'number' && input != null) {\n    const [value, units] = input.split(cssUnitPattern);\n    return !units || units === 'px' ? parseFloat(value) : null;\n  }\n  return input || null;\n}\n/**\n * Gets a version of an element's bounding `DOMRect` where all the values are rounded down to\n * the nearest pixel. This allows us to account for the cases where there may be sub-pixel\n * deviations in the `DOMRect` returned by the browser (e.g. when zoomed in with a percentage\n * size, see #21350).\n */\nfunction getRoundedBoundingClientRect(clientRect) {\n  return {\n    top: Math.floor(clientRect.top),\n    right: Math.floor(clientRect.right),\n    bottom: Math.floor(clientRect.bottom),\n    left: Math.floor(clientRect.left),\n    width: Math.floor(clientRect.width),\n    height: Math.floor(clientRect.height)\n  };\n}\n/** Returns whether two `ScrollingVisibility` objects are identical. */\nfunction compareScrollVisibility(a, b) {\n  if (a === b) {\n    return true;\n  }\n  return a.isOriginClipped === b.isOriginClipped && a.isOriginOutsideView === b.isOriginOutsideView && a.isOverlayClipped === b.isOverlayClipped && a.isOverlayOutsideView === b.isOverlayOutsideView;\n}\nconst STANDARD_DROPDOWN_BELOW_POSITIONS = [{\n  originX: 'start',\n  originY: 'bottom',\n  overlayX: 'start',\n  overlayY: 'top'\n}, {\n  originX: 'start',\n  originY: 'top',\n  overlayX: 'start',\n  overlayY: 'bottom'\n}, {\n  originX: 'end',\n  originY: 'bottom',\n  overlayX: 'end',\n  overlayY: 'top'\n}, {\n  originX: 'end',\n  originY: 'top',\n  overlayX: 'end',\n  overlayY: 'bottom'\n}];\nconst STANDARD_DROPDOWN_ADJACENT_POSITIONS = [{\n  originX: 'end',\n  originY: 'top',\n  overlayX: 'start',\n  overlayY: 'top'\n}, {\n  originX: 'end',\n  originY: 'bottom',\n  overlayX: 'start',\n  overlayY: 'bottom'\n}, {\n  originX: 'start',\n  originY: 'top',\n  overlayX: 'end',\n  overlayY: 'top'\n}, {\n  originX: 'start',\n  originY: 'bottom',\n  overlayX: 'end',\n  overlayY: 'bottom'\n}];\n\n/** Class to be added to the overlay pane wrapper. */\nconst wrapperClass = 'cdk-global-overlay-wrapper';\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nclass GlobalPositionStrategy {\n  constructor() {\n    this._cssPosition = 'static';\n    this._topOffset = '';\n    this._bottomOffset = '';\n    this._alignItems = '';\n    this._xPosition = '';\n    this._xOffset = '';\n    this._width = '';\n    this._height = '';\n    this._isDisposed = false;\n  }\n  attach(overlayRef) {\n    const config = overlayRef.getConfig();\n    this._overlayRef = overlayRef;\n    if (this._width && !config.width) {\n      overlayRef.updateSize({\n        width: this._width\n      });\n    }\n    if (this._height && !config.height) {\n      overlayRef.updateSize({\n        height: this._height\n      });\n    }\n    overlayRef.hostElement.classList.add(wrapperClass);\n    this._isDisposed = false;\n  }\n  /**\n   * Sets the top position of the overlay. Clears any previously set vertical position.\n   * @param value New top offset.\n   */\n  top(value = '') {\n    this._bottomOffset = '';\n    this._topOffset = value;\n    this._alignItems = 'flex-start';\n    return this;\n  }\n  /**\n   * Sets the left position of the overlay. Clears any previously set horizontal position.\n   * @param value New left offset.\n   */\n  left(value = '') {\n    this._xOffset = value;\n    this._xPosition = 'left';\n    return this;\n  }\n  /**\n   * Sets the bottom position of the overlay. Clears any previously set vertical position.\n   * @param value New bottom offset.\n   */\n  bottom(value = '') {\n    this._topOffset = '';\n    this._bottomOffset = value;\n    this._alignItems = 'flex-end';\n    return this;\n  }\n  /**\n   * Sets the right position of the overlay. Clears any previously set horizontal position.\n   * @param value New right offset.\n   */\n  right(value = '') {\n    this._xOffset = value;\n    this._xPosition = 'right';\n    return this;\n  }\n  /**\n   * Sets the overlay to the start of the viewport, depending on the overlay direction.\n   * This will be to the left in LTR layouts and to the right in RTL.\n   * @param offset Offset from the edge of the screen.\n   */\n  start(value = '') {\n    this._xOffset = value;\n    this._xPosition = 'start';\n    return this;\n  }\n  /**\n   * Sets the overlay to the end of the viewport, depending on the overlay direction.\n   * This will be to the right in LTR layouts and to the left in RTL.\n   * @param offset Offset from the edge of the screen.\n   */\n  end(value = '') {\n    this._xOffset = value;\n    this._xPosition = 'end';\n    return this;\n  }\n  /**\n   * Sets the overlay width and clears any previously set width.\n   * @param value New width for the overlay\n   * @deprecated Pass the `width` through the `OverlayConfig`.\n   * @breaking-change 8.0.0\n   */\n  width(value = '') {\n    if (this._overlayRef) {\n      this._overlayRef.updateSize({\n        width: value\n      });\n    } else {\n      this._width = value;\n    }\n    return this;\n  }\n  /**\n   * Sets the overlay height and clears any previously set height.\n   * @param value New height for the overlay\n   * @deprecated Pass the `height` through the `OverlayConfig`.\n   * @breaking-change 8.0.0\n   */\n  height(value = '') {\n    if (this._overlayRef) {\n      this._overlayRef.updateSize({\n        height: value\n      });\n    } else {\n      this._height = value;\n    }\n    return this;\n  }\n  /**\n   * Centers the overlay horizontally with an optional offset.\n   * Clears any previously set horizontal position.\n   *\n   * @param offset Overlay offset from the horizontal center.\n   */\n  centerHorizontally(offset = '') {\n    this.left(offset);\n    this._xPosition = 'center';\n    return this;\n  }\n  /**\n   * Centers the overlay vertically with an optional offset.\n   * Clears any previously set vertical position.\n   *\n   * @param offset Overlay offset from the vertical center.\n   */\n  centerVertically(offset = '') {\n    this.top(offset);\n    this._alignItems = 'center';\n    return this;\n  }\n  /**\n   * Apply the position to the element.\n   * @docs-private\n   */\n  apply() {\n    // Since the overlay ref applies the strategy asynchronously, it could\n    // have been disposed before it ends up being applied. If that is the\n    // case, we shouldn't do anything.\n    if (!this._overlayRef || !this._overlayRef.hasAttached()) {\n      return;\n    }\n    const styles = this._overlayRef.overlayElement.style;\n    const parentStyles = this._overlayRef.hostElement.style;\n    const config = this._overlayRef.getConfig();\n    const {\n      width,\n      height,\n      maxWidth,\n      maxHeight\n    } = config;\n    const shouldBeFlushHorizontally = (width === '100%' || width === '100vw') && (!maxWidth || maxWidth === '100%' || maxWidth === '100vw');\n    const shouldBeFlushVertically = (height === '100%' || height === '100vh') && (!maxHeight || maxHeight === '100%' || maxHeight === '100vh');\n    const xPosition = this._xPosition;\n    const xOffset = this._xOffset;\n    const isRtl = this._overlayRef.getConfig().direction === 'rtl';\n    let marginLeft = '';\n    let marginRight = '';\n    let justifyContent = '';\n    if (shouldBeFlushHorizontally) {\n      justifyContent = 'flex-start';\n    } else if (xPosition === 'center') {\n      justifyContent = 'center';\n      if (isRtl) {\n        marginRight = xOffset;\n      } else {\n        marginLeft = xOffset;\n      }\n    } else if (isRtl) {\n      if (xPosition === 'left' || xPosition === 'end') {\n        justifyContent = 'flex-end';\n        marginLeft = xOffset;\n      } else if (xPosition === 'right' || xPosition === 'start') {\n        justifyContent = 'flex-start';\n        marginRight = xOffset;\n      }\n    } else if (xPosition === 'left' || xPosition === 'start') {\n      justifyContent = 'flex-start';\n      marginLeft = xOffset;\n    } else if (xPosition === 'right' || xPosition === 'end') {\n      justifyContent = 'flex-end';\n      marginRight = xOffset;\n    }\n    styles.position = this._cssPosition;\n    styles.marginLeft = shouldBeFlushHorizontally ? '0' : marginLeft;\n    styles.marginTop = shouldBeFlushVertically ? '0' : this._topOffset;\n    styles.marginBottom = this._bottomOffset;\n    styles.marginRight = shouldBeFlushHorizontally ? '0' : marginRight;\n    parentStyles.justifyContent = justifyContent;\n    parentStyles.alignItems = shouldBeFlushVertically ? 'flex-start' : this._alignItems;\n  }\n  /**\n   * Cleans up the DOM changes from the position strategy.\n   * @docs-private\n   */\n  dispose() {\n    if (this._isDisposed || !this._overlayRef) {\n      return;\n    }\n    const styles = this._overlayRef.overlayElement.style;\n    const parent = this._overlayRef.hostElement;\n    const parentStyles = parent.style;\n    parent.classList.remove(wrapperClass);\n    parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop = styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';\n    this._overlayRef = null;\n    this._isDisposed = true;\n  }\n}\n\n/** Builder for overlay position strategy. */\nclass OverlayPositionBuilder {\n  constructor(_viewportRuler, _document, _platform, _overlayContainer) {\n    this._viewportRuler = _viewportRuler;\n    this._document = _document;\n    this._platform = _platform;\n    this._overlayContainer = _overlayContainer;\n  }\n  /**\n   * Creates a global position strategy.\n   */\n  global() {\n    return new GlobalPositionStrategy();\n  }\n  /**\n   * Creates a flexible position strategy.\n   * @param origin Origin relative to which to position the overlay.\n   */\n  flexibleConnectedTo(origin) {\n    return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: OverlayPositionBuilder,\n      deps: [{\n        token: i1.ViewportRuler\n      }, {\n        token: DOCUMENT\n      }, {\n        token: i1$1.Platform\n      }, {\n        token: OverlayContainer\n      }],\n      target: i0.ɵɵFactoryTarget.Injectable\n    });\n  }\n  static {\n    this.ɵprov = i0.ɵɵngDeclareInjectable({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: OverlayPositionBuilder,\n      providedIn: 'root'\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: OverlayPositionBuilder,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i1.ViewportRuler\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i1$1.Platform\n  }, {\n    type: OverlayContainer\n  }]\n});\n\n/** Next overlay unique ID. */\nlet nextUniqueId = 0;\n// Note that Overlay is *not* scoped to the app root because of the ComponentFactoryResolver\n// which needs to be different depending on where OverlayModule is imported.\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nclass Overlay {\n  constructor( /** Scrolling strategies that can be used when creating an overlay. */\n  scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location, _outsideClickDispatcher, _animationsModuleType) {\n    this.scrollStrategies = scrollStrategies;\n    this._overlayContainer = _overlayContainer;\n    this._componentFactoryResolver = _componentFactoryResolver;\n    this._positionBuilder = _positionBuilder;\n    this._keyboardDispatcher = _keyboardDispatcher;\n    this._injector = _injector;\n    this._ngZone = _ngZone;\n    this._document = _document;\n    this._directionality = _directionality;\n    this._location = _location;\n    this._outsideClickDispatcher = _outsideClickDispatcher;\n    this._animationsModuleType = _animationsModuleType;\n  }\n  /**\n   * Creates an overlay.\n   * @param config Configuration applied to the overlay.\n   * @returns Reference to the created overlay.\n   */\n  create(config) {\n    const host = this._createHostElement();\n    const pane = this._createPaneElement(host);\n    const portalOutlet = this._createPortalOutlet(pane);\n    const overlayConfig = new OverlayConfig(config);\n    overlayConfig.direction = overlayConfig.direction || this._directionality.value;\n    return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher, this._animationsModuleType === 'NoopAnimations', this._injector.get(EnvironmentInjector));\n  }\n  /**\n   * Gets a position builder that can be used, via fluent API,\n   * to construct and configure a position strategy.\n   * @returns An overlay position builder.\n   */\n  position() {\n    return this._positionBuilder;\n  }\n  /**\n   * Creates the DOM element for an overlay and appends it to the overlay container.\n   * @returns Newly-created pane element\n   */\n  _createPaneElement(host) {\n    const pane = this._document.createElement('div');\n    pane.id = `cdk-overlay-${nextUniqueId++}`;\n    pane.classList.add('cdk-overlay-pane');\n    host.appendChild(pane);\n    return pane;\n  }\n  /**\n   * Creates the host element that wraps around an overlay\n   * and can be used for advanced positioning.\n   * @returns Newly-create host element.\n   */\n  _createHostElement() {\n    const host = this._document.createElement('div');\n    this._overlayContainer.getContainerElement().appendChild(host);\n    return host;\n  }\n  /**\n   * Create a DomPortalOutlet into which the overlay content can be loaded.\n   * @param pane The DOM element to turn into a portal outlet.\n   * @returns A portal outlet for the given DOM element.\n   */\n  _createPortalOutlet(pane) {\n    // We have to resolve the ApplicationRef later in order to allow people\n    // to use overlay-based providers during app initialization.\n    if (!this._appRef) {\n      this._appRef = this._injector.get(ApplicationRef);\n    }\n    return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector, this._document);\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: Overlay,\n      deps: [{\n        token: ScrollStrategyOptions\n      }, {\n        token: OverlayContainer\n      }, {\n        token: i0.ComponentFactoryResolver\n      }, {\n        token: OverlayPositionBuilder\n      }, {\n        token: OverlayKeyboardDispatcher\n      }, {\n        token: i0.Injector\n      }, {\n        token: i0.NgZone\n      }, {\n        token: DOCUMENT\n      }, {\n        token: i5.Directionality\n      }, {\n        token: i6.Location\n      }, {\n        token: OverlayOutsideClickDispatcher\n      }, {\n        token: ANIMATION_MODULE_TYPE,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Injectable\n    });\n  }\n  static {\n    this.ɵprov = i0.ɵɵngDeclareInjectable({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: Overlay,\n      providedIn: 'root'\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: Overlay,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }],\n  ctorParameters: () => [{\n    type: ScrollStrategyOptions\n  }, {\n    type: OverlayContainer\n  }, {\n    type: i0.ComponentFactoryResolver\n  }, {\n    type: OverlayPositionBuilder\n  }, {\n    type: OverlayKeyboardDispatcher\n  }, {\n    type: i0.Injector\n  }, {\n    type: i0.NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i5.Directionality\n  }, {\n    type: i6.Location\n  }, {\n    type: OverlayOutsideClickDispatcher\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [ANIMATION_MODULE_TYPE]\n    }, {\n      type: Optional\n    }]\n  }]\n});\n\n/** Default set of positions for the overlay. Follows the behavior of a dropdown. */\nconst defaultPositionList = [{\n  originX: 'start',\n  originY: 'bottom',\n  overlayX: 'start',\n  overlayY: 'top'\n}, {\n  originX: 'start',\n  originY: 'top',\n  overlayX: 'start',\n  overlayY: 'bottom'\n}, {\n  originX: 'end',\n  originY: 'top',\n  overlayX: 'end',\n  overlayY: 'bottom'\n}, {\n  originX: 'end',\n  originY: 'bottom',\n  overlayX: 'end',\n  overlayY: 'top'\n}];\n/** Injection token that determines the scroll handling while the connected overlay is open. */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy', {\n  providedIn: 'root',\n  factory: () => {\n    const overlay = inject(Overlay);\n    return () => overlay.scrollStrategies.reposition();\n  }\n});\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nclass CdkOverlayOrigin {\n  constructor( /** Reference to the element on which the directive is applied. */\n  elementRef) {\n    this.elementRef = elementRef;\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkOverlayOrigin,\n      deps: [{\n        token: i0.ElementRef\n      }],\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: CdkOverlayOrigin,\n      isStandalone: true,\n      selector: \"[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]\",\n      exportAs: [\"cdkOverlayOrigin\"],\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkOverlayOrigin,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n      exportAs: 'cdkOverlayOrigin',\n      standalone: true\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.ElementRef\n  }]\n});\n/**\n * Directive to facilitate declarative creation of an\n * Overlay using a FlexibleConnectedPositionStrategy.\n */\nclass CdkConnectedOverlay {\n  /** The offset in pixels for the overlay connection point on the x-axis */\n  get offsetX() {\n    return this._offsetX;\n  }\n  set offsetX(offsetX) {\n    this._offsetX = offsetX;\n    if (this._position) {\n      this._updatePositionStrategy(this._position);\n    }\n  }\n  /** The offset in pixels for the overlay connection point on the y-axis */\n  get offsetY() {\n    return this._offsetY;\n  }\n  set offsetY(offsetY) {\n    this._offsetY = offsetY;\n    if (this._position) {\n      this._updatePositionStrategy(this._position);\n    }\n  }\n  /** Whether the overlay should be disposed of when the user goes backwards/forwards in history. */\n  get disposeOnNavigation() {\n    return this._disposeOnNavigation;\n  }\n  set disposeOnNavigation(value) {\n    this._disposeOnNavigation = value;\n  }\n  // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n  constructor(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {\n    this._overlay = _overlay;\n    this._dir = _dir;\n    this._backdropSubscription = Subscription.EMPTY;\n    this._attachSubscription = Subscription.EMPTY;\n    this._detachSubscription = Subscription.EMPTY;\n    this._positionSubscription = Subscription.EMPTY;\n    this._disposeOnNavigation = false;\n    this._ngZone = inject(NgZone);\n    /** Margin between the overlay and the viewport edges. */\n    this.viewportMargin = 0;\n    /** Whether the overlay is open. */\n    this.open = false;\n    /** Whether the overlay can be closed by user interaction. */\n    this.disableClose = false;\n    /** Whether or not the overlay should attach a backdrop. */\n    this.hasBackdrop = false;\n    /** Whether or not the overlay should be locked when scrolling. */\n    this.lockPosition = false;\n    /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n    this.flexibleDimensions = false;\n    /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */\n    this.growAfterOpen = false;\n    /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */\n    this.push = false;\n    /** Event emitted when the backdrop is clicked. */\n    this.backdropClick = new EventEmitter();\n    /** Event emitted when the position has changed. */\n    this.positionChange = new EventEmitter();\n    /** Event emitted when the overlay has been attached. */\n    this.attach = new EventEmitter();\n    /** Event emitted when the overlay has been detached. */\n    this.detach = new EventEmitter();\n    /** Emits when there are keyboard events that are targeted at the overlay. */\n    this.overlayKeydown = new EventEmitter();\n    /** Emits when there are mouse outside click events that are targeted at the overlay. */\n    this.overlayOutsideClick = new EventEmitter();\n    this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n    this._scrollStrategyFactory = scrollStrategyFactory;\n    this.scrollStrategy = this._scrollStrategyFactory();\n  }\n  /** The associated overlay reference. */\n  get overlayRef() {\n    return this._overlayRef;\n  }\n  /** The element's layout direction. */\n  get dir() {\n    return this._dir ? this._dir.value : 'ltr';\n  }\n  ngOnDestroy() {\n    this._attachSubscription.unsubscribe();\n    this._detachSubscription.unsubscribe();\n    this._backdropSubscription.unsubscribe();\n    this._positionSubscription.unsubscribe();\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n    }\n  }\n  ngOnChanges(changes) {\n    if (this._position) {\n      this._updatePositionStrategy(this._position);\n      this._overlayRef.updateSize({\n        width: this.width,\n        minWidth: this.minWidth,\n        height: this.height,\n        minHeight: this.minHeight\n      });\n      if (changes['origin'] && this.open) {\n        this._position.apply();\n      }\n    }\n    if (changes['open']) {\n      this.open ? this._attachOverlay() : this._detachOverlay();\n    }\n  }\n  /** Creates an overlay */\n  _createOverlay() {\n    if (!this.positions || !this.positions.length) {\n      this.positions = defaultPositionList;\n    }\n    const overlayRef = this._overlayRef = this._overlay.create(this._buildConfig());\n    this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());\n    this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());\n    overlayRef.keydownEvents().subscribe(event => {\n      this.overlayKeydown.next(event);\n      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {\n        event.preventDefault();\n        this._detachOverlay();\n      }\n    });\n    this._overlayRef.outsidePointerEvents().subscribe(event => {\n      const origin = this._getOriginElement();\n      const target = _getEventTarget(event);\n      if (!origin || origin !== target && !origin.contains(target)) {\n        this.overlayOutsideClick.next(event);\n      }\n    });\n  }\n  /** Builds the overlay config based on the directive's inputs */\n  _buildConfig() {\n    const positionStrategy = this._position = this.positionStrategy || this._createPositionStrategy();\n    const overlayConfig = new OverlayConfig({\n      direction: this._dir,\n      positionStrategy,\n      scrollStrategy: this.scrollStrategy,\n      hasBackdrop: this.hasBackdrop,\n      disposeOnNavigation: this.disposeOnNavigation\n    });\n    if (this.width || this.width === 0) {\n      overlayConfig.width = this.width;\n    }\n    if (this.height || this.height === 0) {\n      overlayConfig.height = this.height;\n    }\n    if (this.minWidth || this.minWidth === 0) {\n      overlayConfig.minWidth = this.minWidth;\n    }\n    if (this.minHeight || this.minHeight === 0) {\n      overlayConfig.minHeight = this.minHeight;\n    }\n    if (this.backdropClass) {\n      overlayConfig.backdropClass = this.backdropClass;\n    }\n    if (this.panelClass) {\n      overlayConfig.panelClass = this.panelClass;\n    }\n    return overlayConfig;\n  }\n  /** Updates the state of a position strategy, based on the values of the directive inputs. */\n  _updatePositionStrategy(positionStrategy) {\n    const positions = this.positions.map(currentPosition => ({\n      originX: currentPosition.originX,\n      originY: currentPosition.originY,\n      overlayX: currentPosition.overlayX,\n      overlayY: currentPosition.overlayY,\n      offsetX: currentPosition.offsetX || this.offsetX,\n      offsetY: currentPosition.offsetY || this.offsetY,\n      panelClass: currentPosition.panelClass || undefined\n    }));\n    return positionStrategy.setOrigin(this._getOrigin()).withPositions(positions).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector);\n  }\n  /** Returns the position strategy of the overlay to be set on the overlay config */\n  _createPositionStrategy() {\n    const strategy = this._overlay.position().flexibleConnectedTo(this._getOrigin());\n    this._updatePositionStrategy(strategy);\n    return strategy;\n  }\n  _getOrigin() {\n    if (this.origin instanceof CdkOverlayOrigin) {\n      return this.origin.elementRef;\n    } else {\n      return this.origin;\n    }\n  }\n  _getOriginElement() {\n    if (this.origin instanceof CdkOverlayOrigin) {\n      return this.origin.elementRef.nativeElement;\n    }\n    if (this.origin instanceof ElementRef) {\n      return this.origin.nativeElement;\n    }\n    if (typeof Element !== 'undefined' && this.origin instanceof Element) {\n      return this.origin;\n    }\n    return null;\n  }\n  /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */\n  _attachOverlay() {\n    if (!this._overlayRef) {\n      this._createOverlay();\n    } else {\n      // Update the overlay size, in case the directive's inputs have changed\n      this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;\n    }\n    if (!this._overlayRef.hasAttached()) {\n      this._overlayRef.attach(this._templatePortal);\n    }\n    if (this.hasBackdrop) {\n      this._backdropSubscription = this._overlayRef.backdropClick().subscribe(event => {\n        this.backdropClick.emit(event);\n      });\n    } else {\n      this._backdropSubscription.unsubscribe();\n    }\n    this._positionSubscription.unsubscribe();\n    // Only subscribe to `positionChanges` if requested, because putting\n    // together all the information for it can be expensive.\n    if (this.positionChange.observers.length > 0) {\n      this._positionSubscription = this._position.positionChanges.pipe(takeWhile(() => this.positionChange.observers.length > 0)).subscribe(position => {\n        this._ngZone.run(() => this.positionChange.emit(position));\n        if (this.positionChange.observers.length === 0) {\n          this._positionSubscription.unsubscribe();\n        }\n      });\n    }\n  }\n  /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */\n  _detachOverlay() {\n    if (this._overlayRef) {\n      this._overlayRef.detach();\n    }\n    this._backdropSubscription.unsubscribe();\n    this._positionSubscription.unsubscribe();\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: CdkConnectedOverlay,\n      deps: [{\n        token: Overlay\n      }, {\n        token: i0.TemplateRef\n      }, {\n        token: i0.ViewContainerRef\n      }, {\n        token: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY\n      }, {\n        token: i5.Directionality,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"16.1.0\",\n      version: \"18.2.0-next.2\",\n      type: CdkConnectedOverlay,\n      isStandalone: true,\n      selector: \"[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]\",\n      inputs: {\n        origin: [\"cdkConnectedOverlayOrigin\", \"origin\"],\n        positions: [\"cdkConnectedOverlayPositions\", \"positions\"],\n        positionStrategy: [\"cdkConnectedOverlayPositionStrategy\", \"positionStrategy\"],\n        offsetX: [\"cdkConnectedOverlayOffsetX\", \"offsetX\"],\n        offsetY: [\"cdkConnectedOverlayOffsetY\", \"offsetY\"],\n        width: [\"cdkConnectedOverlayWidth\", \"width\"],\n        height: [\"cdkConnectedOverlayHeight\", \"height\"],\n        minWidth: [\"cdkConnectedOverlayMinWidth\", \"minWidth\"],\n        minHeight: [\"cdkConnectedOverlayMinHeight\", \"minHeight\"],\n        backdropClass: [\"cdkConnectedOverlayBackdropClass\", \"backdropClass\"],\n        panelClass: [\"cdkConnectedOverlayPanelClass\", \"panelClass\"],\n        viewportMargin: [\"cdkConnectedOverlayViewportMargin\", \"viewportMargin\"],\n        scrollStrategy: [\"cdkConnectedOverlayScrollStrategy\", \"scrollStrategy\"],\n        open: [\"cdkConnectedOverlayOpen\", \"open\"],\n        disableClose: [\"cdkConnectedOverlayDisableClose\", \"disableClose\"],\n        transformOriginSelector: [\"cdkConnectedOverlayTransformOriginOn\", \"transformOriginSelector\"],\n        hasBackdrop: [\"cdkConnectedOverlayHasBackdrop\", \"hasBackdrop\", booleanAttribute],\n        lockPosition: [\"cdkConnectedOverlayLockPosition\", \"lockPosition\", booleanAttribute],\n        flexibleDimensions: [\"cdkConnectedOverlayFlexibleDimensions\", \"flexibleDimensions\", booleanAttribute],\n        growAfterOpen: [\"cdkConnectedOverlayGrowAfterOpen\", \"growAfterOpen\", booleanAttribute],\n        push: [\"cdkConnectedOverlayPush\", \"push\", booleanAttribute],\n        disposeOnNavigation: [\"cdkConnectedOverlayDisposeOnNavigation\", \"disposeOnNavigation\", booleanAttribute]\n      },\n      outputs: {\n        backdropClick: \"backdropClick\",\n        positionChange: \"positionChange\",\n        attach: \"attach\",\n        detach: \"detach\",\n        overlayKeydown: \"overlayKeydown\",\n        overlayOutsideClick: \"overlayOutsideClick\"\n      },\n      exportAs: [\"cdkConnectedOverlay\"],\n      usesOnChanges: true,\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: CdkConnectedOverlay,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n      exportAs: 'cdkConnectedOverlay',\n      standalone: true\n    }]\n  }],\n  ctorParameters: () => [{\n    type: Overlay\n  }, {\n    type: i0.TemplateRef\n  }, {\n    type: i0.ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY]\n    }]\n  }, {\n    type: i5.Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }],\n  propDecorators: {\n    origin: [{\n      type: Input,\n      args: ['cdkConnectedOverlayOrigin']\n    }],\n    positions: [{\n      type: Input,\n      args: ['cdkConnectedOverlayPositions']\n    }],\n    positionStrategy: [{\n      type: Input,\n      args: ['cdkConnectedOverlayPositionStrategy']\n    }],\n    offsetX: [{\n      type: Input,\n      args: ['cdkConnectedOverlayOffsetX']\n    }],\n    offsetY: [{\n      type: Input,\n      args: ['cdkConnectedOverlayOffsetY']\n    }],\n    width: [{\n      type: Input,\n      args: ['cdkConnectedOverlayWidth']\n    }],\n    height: [{\n      type: Input,\n      args: ['cdkConnectedOverlayHeight']\n    }],\n    minWidth: [{\n      type: Input,\n      args: ['cdkConnectedOverlayMinWidth']\n    }],\n    minHeight: [{\n      type: Input,\n      args: ['cdkConnectedOverlayMinHeight']\n    }],\n    backdropClass: [{\n      type: Input,\n      args: ['cdkConnectedOverlayBackdropClass']\n    }],\n    panelClass: [{\n      type: Input,\n      args: ['cdkConnectedOverlayPanelClass']\n    }],\n    viewportMargin: [{\n      type: Input,\n      args: ['cdkConnectedOverlayViewportMargin']\n    }],\n    scrollStrategy: [{\n      type: Input,\n      args: ['cdkConnectedOverlayScrollStrategy']\n    }],\n    open: [{\n      type: Input,\n      args: ['cdkConnectedOverlayOpen']\n    }],\n    disableClose: [{\n      type: Input,\n      args: ['cdkConnectedOverlayDisableClose']\n    }],\n    transformOriginSelector: [{\n      type: Input,\n      args: ['cdkConnectedOverlayTransformOriginOn']\n    }],\n    hasBackdrop: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayHasBackdrop',\n        transform: booleanAttribute\n      }]\n    }],\n    lockPosition: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayLockPosition',\n        transform: booleanAttribute\n      }]\n    }],\n    flexibleDimensions: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayFlexibleDimensions',\n        transform: booleanAttribute\n      }]\n    }],\n    growAfterOpen: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayGrowAfterOpen',\n        transform: booleanAttribute\n      }]\n    }],\n    push: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayPush',\n        transform: booleanAttribute\n      }]\n    }],\n    disposeOnNavigation: [{\n      type: Input,\n      args: [{\n        alias: 'cdkConnectedOverlayDisposeOnNavigation',\n        transform: booleanAttribute\n      }]\n    }],\n    backdropClick: [{\n      type: Output\n    }],\n    positionChange: [{\n      type: Output\n    }],\n    attach: [{\n      type: Output\n    }],\n    detach: [{\n      type: Output\n    }],\n    overlayKeydown: [{\n      type: Output\n    }],\n    overlayOutsideClick: [{\n      type: Output\n    }]\n  }\n});\n/** @docs-private */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n  return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n  provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY\n};\nclass OverlayModule {\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: OverlayModule,\n      deps: [],\n      target: i0.ɵɵFactoryTarget.NgModule\n    });\n  }\n  static {\n    this.ɵmod = i0.ɵɵngDeclareNgModule({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: OverlayModule,\n      imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],\n      exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule]\n    });\n  }\n  static {\n    this.ɵinj = i0.ɵɵngDeclareInjector({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: OverlayModule,\n      providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER],\n      imports: [BidiModule, PortalModule, ScrollingModule, ScrollingModule]\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: OverlayModule,\n  decorators: [{\n    type: NgModule,\n    args: [{\n      imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],\n      exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],\n      providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER]\n    }]\n  }]\n});\n\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nclass FullscreenOverlayContainer extends OverlayContainer {\n  constructor(_document, platform) {\n    super(_document, platform);\n  }\n  ngOnDestroy() {\n    super.ngOnDestroy();\n    if (this._fullScreenEventName && this._fullScreenListener) {\n      this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);\n    }\n  }\n  _createContainer() {\n    super._createContainer();\n    this._adjustParentForFullscreenChange();\n    this._addFullscreenChangeListener(() => this._adjustParentForFullscreenChange());\n  }\n  _adjustParentForFullscreenChange() {\n    if (!this._containerElement) {\n      return;\n    }\n    const fullscreenElement = this.getFullscreenElement();\n    const parent = fullscreenElement || this._document.body;\n    parent.appendChild(this._containerElement);\n  }\n  _addFullscreenChangeListener(fn) {\n    const eventName = this._getEventName();\n    if (eventName) {\n      if (this._fullScreenListener) {\n        this._document.removeEventListener(eventName, this._fullScreenListener);\n      }\n      this._document.addEventListener(eventName, fn);\n      this._fullScreenListener = fn;\n    }\n  }\n  _getEventName() {\n    if (!this._fullScreenEventName) {\n      const _document = this._document;\n      if (_document.fullscreenEnabled) {\n        this._fullScreenEventName = 'fullscreenchange';\n      } else if (_document.webkitFullscreenEnabled) {\n        this._fullScreenEventName = 'webkitfullscreenchange';\n      } else if (_document.mozFullScreenEnabled) {\n        this._fullScreenEventName = 'mozfullscreenchange';\n      } else if (_document.msFullscreenEnabled) {\n        this._fullScreenEventName = 'MSFullscreenChange';\n      }\n    }\n    return this._fullScreenEventName;\n  }\n  /**\n   * When the page is put into fullscreen mode, a specific element is specified.\n   * Only that element and its children are visible when in fullscreen mode.\n   */\n  getFullscreenElement() {\n    const _document = this._document;\n    return _document.fullscreenElement || _document.webkitFullscreenElement || _document.mozFullScreenElement || _document.msFullscreenElement || null;\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: FullscreenOverlayContainer,\n      deps: [{\n        token: DOCUMENT\n      }, {\n        token: i1$1.Platform\n      }],\n      target: i0.ɵɵFactoryTarget.Injectable\n    });\n  }\n  static {\n    this.ɵprov = i0.ɵɵngDeclareInjectable({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: FullscreenOverlayContainer,\n      providedIn: 'root'\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: FullscreenOverlayContainer,\n  decorators: [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }],\n  ctorParameters: () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: i1$1.Platform\n  }]\n});\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BlockScrollStrategy, CdkConnectedOverlay, CdkOverlayOrigin, CloseScrollStrategy, ConnectedOverlayPositionChange, ConnectionPositionPair, FlexibleConnectedPositionStrategy, FullscreenOverlayContainer, GlobalPositionStrategy, NoopScrollStrategy, Overlay, OverlayConfig, OverlayContainer, OverlayKeyboardDispatcher, OverlayModule, OverlayOutsideClickDispatcher, OverlayPositionBuilder, OverlayRef, RepositionScrollStrategy, STANDARD_DROPDOWN_ADJACENT_POSITIONS, STANDARD_DROPDOWN_BELOW_POSITIONS, ScrollStrategyOptions, ScrollingVisibility, validateHorizontalPosition, validateVerticalPosition };\n","import { takeUntil } from 'rxjs/operators';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, Injector, ElementRef, afterNextRender, Directive, Inject, Optional, Input, ANIMATION_MODULE_TYPE, Component, ViewEncapsulation, ChangeDetectionStrategy, ViewChild, NgModule } from '@angular/core';\nimport { DOCUMENT, NgClass, CommonModule } from '@angular/common';\nimport * as i2 from '@angular/cdk/platform';\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\nimport * as i3 from '@angular/cdk/a11y';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport * as i4 from '@angular/cdk/bidi';\nimport * as i1 from '@angular/cdk/overlay';\nimport { Overlay, OverlayModule } from '@angular/cdk/overlay';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { Subject } from 'rxjs';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport { MatCommonModule } from '@angular/material/core';\n\n/** Time in ms to throttle repositioning after scroll events. */\nconst SCROLL_THROTTLE_MS = 20;\n/**\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\n * @docs-private\n */\nfunction getMatTooltipInvalidPositionError(position) {\n  return Error(`Tooltip position \"${position}\" is invalid.`);\n}\n/** Injection token that determines the scroll handling while a tooltip is visible. */\nconst MAT_TOOLTIP_SCROLL_STRATEGY = new InjectionToken('mat-tooltip-scroll-strategy', {\n  providedIn: 'root',\n  factory: () => {\n    const overlay = inject(Overlay);\n    return () => overlay.scrollStrategies.reposition({\n      scrollThrottle: SCROLL_THROTTLE_MS\n    });\n  }\n});\n/** @docs-private */\nfunction MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay) {\n  return () => overlay.scrollStrategies.reposition({\n    scrollThrottle: SCROLL_THROTTLE_MS\n  });\n}\n/** @docs-private */\nconst MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n  provide: MAT_TOOLTIP_SCROLL_STRATEGY,\n  deps: [Overlay],\n  useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY\n};\n/** @docs-private */\nfunction MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {\n  return {\n    showDelay: 0,\n    hideDelay: 0,\n    touchendHideDelay: 1500\n  };\n}\n/** Injection token to be used to override the default options for `matTooltip`. */\nconst MAT_TOOLTIP_DEFAULT_OPTIONS = new InjectionToken('mat-tooltip-default-options', {\n  providedIn: 'root',\n  factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * CSS class that will be attached to the overlay panel.\n * @deprecated\n * @breaking-change 13.0.0 remove this variable\n */\nconst TOOLTIP_PANEL_CLASS = 'mat-mdc-tooltip-panel';\nconst PANEL_CLASS = 'tooltip-panel';\n/** Options used to bind passive event listeners. */\nconst passiveListenerOptions = normalizePassiveListenerOptions({\n  passive: true\n});\n// These constants were taken from MDC's `numbers` object. We can't import them from MDC,\n// because they have some top-level references to `window` which break during SSR.\nconst MIN_VIEWPORT_TOOLTIP_THRESHOLD = 8;\nconst UNBOUNDED_ANCHOR_GAP = 8;\nconst MIN_HEIGHT = 24;\nconst MAX_WIDTH = 200;\n/**\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\n * hiding of a tooltip provided position (defaults to below the element).\n *\n * https://material.io/design/components/tooltips.html\n */\nclass MatTooltip {\n  /** Allows the user to define the position of the tooltip relative to the parent element */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    if (value !== this._position) {\n      this._position = value;\n      if (this._overlayRef) {\n        this._updatePosition(this._overlayRef);\n        this._tooltipInstance?.show(0);\n        this._overlayRef.updatePosition();\n      }\n    }\n  }\n  /**\n   * Whether tooltip should be relative to the click or touch origin\n   * instead of outside the element bounding box.\n   */\n  get positionAtOrigin() {\n    return this._positionAtOrigin;\n  }\n  set positionAtOrigin(value) {\n    this._positionAtOrigin = coerceBooleanProperty(value);\n    this._detach();\n    this._overlayRef = null;\n  }\n  /** Disables the display of the tooltip. */\n  get disabled() {\n    return this._disabled;\n  }\n  set disabled(value) {\n    this._disabled = coerceBooleanProperty(value);\n    // If tooltip is disabled, hide immediately.\n    if (this._disabled) {\n      this.hide(0);\n    } else {\n      this._setupPointerEnterEventsIfNeeded();\n    }\n  }\n  /** The default delay in ms before showing the tooltip after show is called */\n  get showDelay() {\n    return this._showDelay;\n  }\n  set showDelay(value) {\n    this._showDelay = coerceNumberProperty(value);\n  }\n  /** The default delay in ms before hiding the tooltip after hide is called */\n  get hideDelay() {\n    return this._hideDelay;\n  }\n  set hideDelay(value) {\n    this._hideDelay = coerceNumberProperty(value);\n    if (this._tooltipInstance) {\n      this._tooltipInstance._mouseLeaveHideDelay = this._hideDelay;\n    }\n  }\n  /** The message to be displayed in the tooltip */\n  get message() {\n    return this._message;\n  }\n  set message(value) {\n    this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message, 'tooltip');\n    // If the message is not a string (e.g. number), convert it to a string and trim it.\n    // Must convert with `String(value)`, not `${value}`, otherwise Closure Compiler optimises\n    // away the string-conversion: https://github.com/angular/components/issues/20684\n    this._message = value != null ? String(value).trim() : '';\n    if (!this._message && this._isTooltipVisible()) {\n      this.hide(0);\n    } else {\n      this._setupPointerEnterEventsIfNeeded();\n      this._updateTooltipMessage();\n      this._ngZone.runOutsideAngular(() => {\n        // The `AriaDescriber` has some functionality that avoids adding a description if it's the\n        // same as the `aria-label` of an element, however we can't know whether the tooltip trigger\n        // has a data-bound `aria-label` or when it'll be set for the first time. We can avoid the\n        // issue by deferring the description by a tick so Angular has time to set the `aria-label`.\n        Promise.resolve().then(() => {\n          this._ariaDescriber.describe(this._elementRef.nativeElement, this.message, 'tooltip');\n        });\n      });\n    }\n  }\n  /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */\n  get tooltipClass() {\n    return this._tooltipClass;\n  }\n  set tooltipClass(value) {\n    this._tooltipClass = value;\n    if (this._tooltipInstance) {\n      this._setTooltipClass(this._tooltipClass);\n    }\n  }\n  constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, scrollStrategy, _dir, _defaultOptions, _document) {\n    this._overlay = _overlay;\n    this._elementRef = _elementRef;\n    this._scrollDispatcher = _scrollDispatcher;\n    this._viewContainerRef = _viewContainerRef;\n    this._ngZone = _ngZone;\n    this._platform = _platform;\n    this._ariaDescriber = _ariaDescriber;\n    this._focusMonitor = _focusMonitor;\n    this._dir = _dir;\n    this._defaultOptions = _defaultOptions;\n    this._position = 'below';\n    this._positionAtOrigin = false;\n    this._disabled = false;\n    this._viewInitialized = false;\n    this._pointerExitEventsInitialized = false;\n    this._tooltipComponent = TooltipComponent;\n    this._viewportMargin = 8;\n    this._cssClassPrefix = 'mat-mdc';\n    /**\n     * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive\n     * uses a long press gesture to show and hide, however it can conflict with the native browser\n     * gestures. To work around the conflict, Angular Material disables native gestures on the\n     * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable\n     * elements). The different values for this option configure the touch event handling as follows:\n     * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native\n     *   browser gestures on particular elements. In particular, it allows text selection on inputs\n     *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.\n     * - `on` - Enables touch gestures for all elements and disables native\n     *   browser gestures with no exceptions.\n     * - `off` - Disables touch gestures. Note that this will prevent the tooltip from\n     *   showing on touch devices.\n     */\n    this.touchGestures = 'auto';\n    this._message = '';\n    /** Manually-bound passive event listeners. */\n    this._passiveListeners = [];\n    /** Emits when the component is destroyed. */\n    this._destroyed = new Subject();\n    this._injector = inject(Injector);\n    this._scrollStrategy = scrollStrategy;\n    this._document = _document;\n    if (_defaultOptions) {\n      this._showDelay = _defaultOptions.showDelay;\n      this._hideDelay = _defaultOptions.hideDelay;\n      if (_defaultOptions.position) {\n        this.position = _defaultOptions.position;\n      }\n      if (_defaultOptions.positionAtOrigin) {\n        this.positionAtOrigin = _defaultOptions.positionAtOrigin;\n      }\n      if (_defaultOptions.touchGestures) {\n        this.touchGestures = _defaultOptions.touchGestures;\n      }\n    }\n    _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => {\n      if (this._overlayRef) {\n        this._updatePosition(this._overlayRef);\n      }\n    });\n    this._viewportMargin = MIN_VIEWPORT_TOOLTIP_THRESHOLD;\n  }\n  ngAfterViewInit() {\n    // This needs to happen after view init so the initial values for all inputs have been set.\n    this._viewInitialized = true;\n    this._setupPointerEnterEventsIfNeeded();\n    this._focusMonitor.monitor(this._elementRef).pipe(takeUntil(this._destroyed)).subscribe(origin => {\n      // Note that the focus monitor runs outside the Angular zone.\n      if (!origin) {\n        this._ngZone.run(() => this.hide(0));\n      } else if (origin === 'keyboard') {\n        this._ngZone.run(() => this.show());\n      }\n    });\n  }\n  /**\n   * Dispose the tooltip when destroyed.\n   */\n  ngOnDestroy() {\n    const nativeElement = this._elementRef.nativeElement;\n    clearTimeout(this._touchstartTimeout);\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n      this._tooltipInstance = null;\n    }\n    // Clean up the event listeners set in the constructor\n    this._passiveListeners.forEach(([event, listener]) => {\n      nativeElement.removeEventListener(event, listener, passiveListenerOptions);\n    });\n    this._passiveListeners.length = 0;\n    this._destroyed.next();\n    this._destroyed.complete();\n    this._ariaDescriber.removeDescription(nativeElement, this.message, 'tooltip');\n    this._focusMonitor.stopMonitoring(nativeElement);\n  }\n  /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */\n  show(delay = this.showDelay, origin) {\n    if (this.disabled || !this.message || this._isTooltipVisible()) {\n      this._tooltipInstance?._cancelPendingAnimations();\n      return;\n    }\n    const overlayRef = this._createOverlay(origin);\n    this._detach();\n    this._portal = this._portal || new ComponentPortal(this._tooltipComponent, this._viewContainerRef);\n    const instance = this._tooltipInstance = overlayRef.attach(this._portal).instance;\n    instance._triggerElement = this._elementRef.nativeElement;\n    instance._mouseLeaveHideDelay = this._hideDelay;\n    instance.afterHidden().pipe(takeUntil(this._destroyed)).subscribe(() => this._detach());\n    this._setTooltipClass(this._tooltipClass);\n    this._updateTooltipMessage();\n    instance.show(delay);\n  }\n  /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */\n  hide(delay = this.hideDelay) {\n    const instance = this._tooltipInstance;\n    if (instance) {\n      if (instance.isVisible()) {\n        instance.hide(delay);\n      } else {\n        instance._cancelPendingAnimations();\n        this._detach();\n      }\n    }\n  }\n  /** Shows/hides the tooltip */\n  toggle(origin) {\n    this._isTooltipVisible() ? this.hide() : this.show(undefined, origin);\n  }\n  /** Returns true if the tooltip is currently visible to the user */\n  _isTooltipVisible() {\n    return !!this._tooltipInstance && this._tooltipInstance.isVisible();\n  }\n  /** Create the overlay config and position strategy */\n  _createOverlay(origin) {\n    if (this._overlayRef) {\n      const existingStrategy = this._overlayRef.getConfig().positionStrategy;\n      if ((!this.positionAtOrigin || !origin) && existingStrategy._origin instanceof ElementRef) {\n        return this._overlayRef;\n      }\n      this._detach();\n    }\n    const scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);\n    // Create connected position strategy that listens for scroll events to reposition.\n    const strategy = this._overlay.position().flexibleConnectedTo(this.positionAtOrigin ? origin || this._elementRef : this._elementRef).withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`).withFlexibleDimensions(false).withViewportMargin(this._viewportMargin).withScrollableContainers(scrollableAncestors);\n    strategy.positionChanges.pipe(takeUntil(this._destroyed)).subscribe(change => {\n      this._updateCurrentPositionClass(change.connectionPair);\n      if (this._tooltipInstance) {\n        if (change.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible()) {\n          // After position changes occur and the overlay is clipped by\n          // a parent scrollable then close the tooltip.\n          this._ngZone.run(() => this.hide(0));\n        }\n      }\n    });\n    this._overlayRef = this._overlay.create({\n      direction: this._dir,\n      positionStrategy: strategy,\n      panelClass: `${this._cssClassPrefix}-${PANEL_CLASS}`,\n      scrollStrategy: this._scrollStrategy()\n    });\n    this._updatePosition(this._overlayRef);\n    this._overlayRef.detachments().pipe(takeUntil(this._destroyed)).subscribe(() => this._detach());\n    this._overlayRef.outsidePointerEvents().pipe(takeUntil(this._destroyed)).subscribe(() => this._tooltipInstance?._handleBodyInteraction());\n    this._overlayRef.keydownEvents().pipe(takeUntil(this._destroyed)).subscribe(event => {\n      if (this._isTooltipVisible() && event.keyCode === ESCAPE && !hasModifierKey(event)) {\n        event.preventDefault();\n        event.stopPropagation();\n        this._ngZone.run(() => this.hide(0));\n      }\n    });\n    if (this._defaultOptions?.disableTooltipInteractivity) {\n      this._overlayRef.addPanelClass(`${this._cssClassPrefix}-tooltip-panel-non-interactive`);\n    }\n    return this._overlayRef;\n  }\n  /** Detaches the currently-attached tooltip. */\n  _detach() {\n    if (this._overlayRef && this._overlayRef.hasAttached()) {\n      this._overlayRef.detach();\n    }\n    this._tooltipInstance = null;\n  }\n  /** Updates the position of the current tooltip. */\n  _updatePosition(overlayRef) {\n    const position = overlayRef.getConfig().positionStrategy;\n    const origin = this._getOrigin();\n    const overlay = this._getOverlayPosition();\n    position.withPositions([this._addOffset({\n      ...origin.main,\n      ...overlay.main\n    }), this._addOffset({\n      ...origin.fallback,\n      ...overlay.fallback\n    })]);\n  }\n  /** Adds the configured offset to a position. Used as a hook for child classes. */\n  _addOffset(position) {\n    const offset = UNBOUNDED_ANCHOR_GAP;\n    const isLtr = !this._dir || this._dir.value == 'ltr';\n    if (position.originY === 'top') {\n      position.offsetY = -offset;\n    } else if (position.originY === 'bottom') {\n      position.offsetY = offset;\n    } else if (position.originX === 'start') {\n      position.offsetX = isLtr ? -offset : offset;\n    } else if (position.originX === 'end') {\n      position.offsetX = isLtr ? offset : -offset;\n    }\n    return position;\n  }\n  /**\n   * Returns the origin position and a fallback position based on the user's position preference.\n   * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\n   */\n  _getOrigin() {\n    const isLtr = !this._dir || this._dir.value == 'ltr';\n    const position = this.position;\n    let originPosition;\n    if (position == 'above' || position == 'below') {\n      originPosition = {\n        originX: 'center',\n        originY: position == 'above' ? 'top' : 'bottom'\n      };\n    } else if (position == 'before' || position == 'left' && isLtr || position == 'right' && !isLtr) {\n      originPosition = {\n        originX: 'start',\n        originY: 'center'\n      };\n    } else if (position == 'after' || position == 'right' && isLtr || position == 'left' && !isLtr) {\n      originPosition = {\n        originX: 'end',\n        originY: 'center'\n      };\n    } else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw getMatTooltipInvalidPositionError(position);\n    }\n    const {\n      x,\n      y\n    } = this._invertPosition(originPosition.originX, originPosition.originY);\n    return {\n      main: originPosition,\n      fallback: {\n        originX: x,\n        originY: y\n      }\n    };\n  }\n  /** Returns the overlay position and a fallback position based on the user's preference */\n  _getOverlayPosition() {\n    const isLtr = !this._dir || this._dir.value == 'ltr';\n    const position = this.position;\n    let overlayPosition;\n    if (position == 'above') {\n      overlayPosition = {\n        overlayX: 'center',\n        overlayY: 'bottom'\n      };\n    } else if (position == 'below') {\n      overlayPosition = {\n        overlayX: 'center',\n        overlayY: 'top'\n      };\n    } else if (position == 'before' || position == 'left' && isLtr || position == 'right' && !isLtr) {\n      overlayPosition = {\n        overlayX: 'end',\n        overlayY: 'center'\n      };\n    } else if (position == 'after' || position == 'right' && isLtr || position == 'left' && !isLtr) {\n      overlayPosition = {\n        overlayX: 'start',\n        overlayY: 'center'\n      };\n    } else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      throw getMatTooltipInvalidPositionError(position);\n    }\n    const {\n      x,\n      y\n    } = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY);\n    return {\n      main: overlayPosition,\n      fallback: {\n        overlayX: x,\n        overlayY: y\n      }\n    };\n  }\n  /** Updates the tooltip message and repositions the overlay according to the new message length */\n  _updateTooltipMessage() {\n    // Must wait for the message to be painted to the tooltip so that the overlay can properly\n    // calculate the correct positioning based on the size of the text.\n    if (this._tooltipInstance) {\n      this._tooltipInstance.message = this.message;\n      this._tooltipInstance._markForCheck();\n      afterNextRender(() => {\n        if (this._tooltipInstance) {\n          this._overlayRef.updatePosition();\n        }\n      }, {\n        injector: this._injector\n      });\n    }\n  }\n  /** Updates the tooltip class */\n  _setTooltipClass(tooltipClass) {\n    if (this._tooltipInstance) {\n      this._tooltipInstance.tooltipClass = tooltipClass;\n      this._tooltipInstance._markForCheck();\n    }\n  }\n  /** Inverts an overlay position. */\n  _invertPosition(x, y) {\n    if (this.position === 'above' || this.position === 'below') {\n      if (y === 'top') {\n        y = 'bottom';\n      } else if (y === 'bottom') {\n        y = 'top';\n      }\n    } else {\n      if (x === 'end') {\n        x = 'start';\n      } else if (x === 'start') {\n        x = 'end';\n      }\n    }\n    return {\n      x,\n      y\n    };\n  }\n  /** Updates the class on the overlay panel based on the current position of the tooltip. */\n  _updateCurrentPositionClass(connectionPair) {\n    const {\n      overlayY,\n      originX,\n      originY\n    } = connectionPair;\n    let newPosition;\n    // If the overlay is in the middle along the Y axis,\n    // it means that it's either before or after.\n    if (overlayY === 'center') {\n      // Note that since this information is used for styling, we want to\n      // resolve `start` and `end` to their real values, otherwise consumers\n      // would have to remember to do it themselves on each consumption.\n      if (this._dir && this._dir.value === 'rtl') {\n        newPosition = originX === 'end' ? 'left' : 'right';\n      } else {\n        newPosition = originX === 'start' ? 'left' : 'right';\n      }\n    } else {\n      newPosition = overlayY === 'bottom' && originY === 'top' ? 'above' : 'below';\n    }\n    if (newPosition !== this._currentPosition) {\n      const overlayRef = this._overlayRef;\n      if (overlayRef) {\n        const classPrefix = `${this._cssClassPrefix}-${PANEL_CLASS}-`;\n        overlayRef.removePanelClass(classPrefix + this._currentPosition);\n        overlayRef.addPanelClass(classPrefix + newPosition);\n      }\n      this._currentPosition = newPosition;\n    }\n  }\n  /** Binds the pointer events to the tooltip trigger. */\n  _setupPointerEnterEventsIfNeeded() {\n    // Optimization: Defer hooking up events if there's no message or the tooltip is disabled.\n    if (this._disabled || !this.message || !this._viewInitialized || this._passiveListeners.length) {\n      return;\n    }\n    // The mouse events shouldn't be bound on mobile devices, because they can prevent the\n    // first tap from firing its click event or can cause the tooltip to open for clicks.\n    if (this._platformSupportsMouseEvents()) {\n      this._passiveListeners.push(['mouseenter', event => {\n        this._setupPointerExitEventsIfNeeded();\n        let point = undefined;\n        if (event.x !== undefined && event.y !== undefined) {\n          point = event;\n        }\n        this.show(undefined, point);\n      }]);\n    } else if (this.touchGestures !== 'off') {\n      this._disableNativeGesturesIfNecessary();\n      this._passiveListeners.push(['touchstart', event => {\n        const touch = event.targetTouches?.[0];\n        const origin = touch ? {\n          x: touch.clientX,\n          y: touch.clientY\n        } : undefined;\n        // Note that it's important that we don't `preventDefault` here,\n        // because it can prevent click events from firing on the element.\n        this._setupPointerExitEventsIfNeeded();\n        clearTimeout(this._touchstartTimeout);\n        const DEFAULT_LONGPRESS_DELAY = 500;\n        this._touchstartTimeout = setTimeout(() => this.show(undefined, origin), this._defaultOptions.touchLongPressShowDelay ?? DEFAULT_LONGPRESS_DELAY);\n      }]);\n    }\n    this._addListeners(this._passiveListeners);\n  }\n  _setupPointerExitEventsIfNeeded() {\n    if (this._pointerExitEventsInitialized) {\n      return;\n    }\n    this._pointerExitEventsInitialized = true;\n    const exitListeners = [];\n    if (this._platformSupportsMouseEvents()) {\n      exitListeners.push(['mouseleave', event => {\n        const newTarget = event.relatedTarget;\n        if (!newTarget || !this._overlayRef?.overlayElement.contains(newTarget)) {\n          this.hide();\n        }\n      }], ['wheel', event => this._wheelListener(event)]);\n    } else if (this.touchGestures !== 'off') {\n      this._disableNativeGesturesIfNecessary();\n      const touchendListener = () => {\n        clearTimeout(this._touchstartTimeout);\n        this.hide(this._defaultOptions.touchendHideDelay);\n      };\n      exitListeners.push(['touchend', touchendListener], ['touchcancel', touchendListener]);\n    }\n    this._addListeners(exitListeners);\n    this._passiveListeners.push(...exitListeners);\n  }\n  _addListeners(listeners) {\n    listeners.forEach(([event, listener]) => {\n      this._elementRef.nativeElement.addEventListener(event, listener, passiveListenerOptions);\n    });\n  }\n  _platformSupportsMouseEvents() {\n    return !this._platform.IOS && !this._platform.ANDROID;\n  }\n  /** Listener for the `wheel` event on the element. */\n  _wheelListener(event) {\n    if (this._isTooltipVisible()) {\n      const elementUnderPointer = this._document.elementFromPoint(event.clientX, event.clientY);\n      const element = this._elementRef.nativeElement;\n      // On non-touch devices we depend on the `mouseleave` event to close the tooltip, but it\n      // won't fire if the user scrolls away using the wheel without moving their cursor. We\n      // work around it by finding the element under the user's cursor and closing the tooltip\n      // if it's not the trigger.\n      if (elementUnderPointer !== element && !element.contains(elementUnderPointer)) {\n        this.hide();\n      }\n    }\n  }\n  /** Disables the native browser gestures, based on how the tooltip has been configured. */\n  _disableNativeGesturesIfNecessary() {\n    const gestures = this.touchGestures;\n    if (gestures !== 'off') {\n      const element = this._elementRef.nativeElement;\n      const style = element.style;\n      // If gestures are set to `auto`, we don't disable text selection on inputs and\n      // textareas, because it prevents the user from typing into them on iOS Safari.\n      if (gestures === 'on' || element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA') {\n        style.userSelect = style.msUserSelect = style.webkitUserSelect = style.MozUserSelect = 'none';\n      }\n      // If we have `auto` gestures and the element uses native HTML dragging,\n      // we don't set `-webkit-user-drag` because it prevents the native behavior.\n      if (gestures === 'on' || !element.draggable) {\n        style.webkitUserDrag = 'none';\n      }\n      style.touchAction = 'none';\n      style.webkitTapHighlightColor = 'transparent';\n    }\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: MatTooltip,\n      deps: [{\n        token: i1.Overlay\n      }, {\n        token: i0.ElementRef\n      }, {\n        token: i1.ScrollDispatcher\n      }, {\n        token: i0.ViewContainerRef\n      }, {\n        token: i0.NgZone\n      }, {\n        token: i2.Platform\n      }, {\n        token: i3.AriaDescriber\n      }, {\n        token: i3.FocusMonitor\n      }, {\n        token: MAT_TOOLTIP_SCROLL_STRATEGY\n      }, {\n        token: i4.Directionality\n      }, {\n        token: MAT_TOOLTIP_DEFAULT_OPTIONS,\n        optional: true\n      }, {\n        token: DOCUMENT\n      }],\n      target: i0.ɵɵFactoryTarget.Directive\n    });\n  }\n  static {\n    this.ɵdir = i0.ɵɵngDeclareDirective({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: MatTooltip,\n      isStandalone: true,\n      selector: \"[matTooltip]\",\n      inputs: {\n        position: [\"matTooltipPosition\", \"position\"],\n        positionAtOrigin: [\"matTooltipPositionAtOrigin\", \"positionAtOrigin\"],\n        disabled: [\"matTooltipDisabled\", \"disabled\"],\n        showDelay: [\"matTooltipShowDelay\", \"showDelay\"],\n        hideDelay: [\"matTooltipHideDelay\", \"hideDelay\"],\n        touchGestures: [\"matTooltipTouchGestures\", \"touchGestures\"],\n        message: [\"matTooltip\", \"message\"],\n        tooltipClass: [\"matTooltipClass\", \"tooltipClass\"]\n      },\n      host: {\n        properties: {\n          \"class.mat-mdc-tooltip-disabled\": \"disabled\"\n        },\n        classAttribute: \"mat-mdc-tooltip-trigger\"\n      },\n      exportAs: [\"matTooltip\"],\n      ngImport: i0\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: MatTooltip,\n  decorators: [{\n    type: Directive,\n    args: [{\n      selector: '[matTooltip]',\n      exportAs: 'matTooltip',\n      host: {\n        'class': 'mat-mdc-tooltip-trigger',\n        '[class.mat-mdc-tooltip-disabled]': 'disabled'\n      },\n      standalone: true\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i1.Overlay\n  }, {\n    type: i0.ElementRef\n  }, {\n    type: i1.ScrollDispatcher\n  }, {\n    type: i0.ViewContainerRef\n  }, {\n    type: i0.NgZone\n  }, {\n    type: i2.Platform\n  }, {\n    type: i3.AriaDescriber\n  }, {\n    type: i3.FocusMonitor\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [MAT_TOOLTIP_SCROLL_STRATEGY]\n    }]\n  }, {\n    type: i4.Directionality\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [MAT_TOOLTIP_DEFAULT_OPTIONS]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }],\n  propDecorators: {\n    position: [{\n      type: Input,\n      args: ['matTooltipPosition']\n    }],\n    positionAtOrigin: [{\n      type: Input,\n      args: ['matTooltipPositionAtOrigin']\n    }],\n    disabled: [{\n      type: Input,\n      args: ['matTooltipDisabled']\n    }],\n    showDelay: [{\n      type: Input,\n      args: ['matTooltipShowDelay']\n    }],\n    hideDelay: [{\n      type: Input,\n      args: ['matTooltipHideDelay']\n    }],\n    touchGestures: [{\n      type: Input,\n      args: ['matTooltipTouchGestures']\n    }],\n    message: [{\n      type: Input,\n      args: ['matTooltip']\n    }],\n    tooltipClass: [{\n      type: Input,\n      args: ['matTooltipClass']\n    }]\n  }\n});\n/**\n * Internal component that wraps the tooltip's content.\n * @docs-private\n */\nclass TooltipComponent {\n  constructor(_changeDetectorRef, _elementRef, animationMode) {\n    this._changeDetectorRef = _changeDetectorRef;\n    this._elementRef = _elementRef;\n    /* Whether the tooltip text overflows to multiple lines */\n    this._isMultiline = false;\n    /** Whether interactions on the page should close the tooltip */\n    this._closeOnInteraction = false;\n    /** Whether the tooltip is currently visible. */\n    this._isVisible = false;\n    /** Subject for notifying that the tooltip has been hidden from the view */\n    this._onHide = new Subject();\n    /** Name of the show animation and the class that toggles it. */\n    this._showAnimation = 'mat-mdc-tooltip-show';\n    /** Name of the hide animation and the class that toggles it. */\n    this._hideAnimation = 'mat-mdc-tooltip-hide';\n    this._animationsDisabled = animationMode === 'NoopAnimations';\n  }\n  /**\n   * Shows the tooltip with an animation originating from the provided origin\n   * @param delay Amount of milliseconds to the delay showing the tooltip.\n   */\n  show(delay) {\n    // Cancel the delayed hide if it is scheduled\n    if (this._hideTimeoutId != null) {\n      clearTimeout(this._hideTimeoutId);\n    }\n    this._showTimeoutId = setTimeout(() => {\n      this._toggleVisibility(true);\n      this._showTimeoutId = undefined;\n    }, delay);\n  }\n  /**\n   * Begins the animation to hide the tooltip after the provided delay in ms.\n   * @param delay Amount of milliseconds to delay showing the tooltip.\n   */\n  hide(delay) {\n    // Cancel the delayed show if it is scheduled\n    if (this._showTimeoutId != null) {\n      clearTimeout(this._showTimeoutId);\n    }\n    this._hideTimeoutId = setTimeout(() => {\n      this._toggleVisibility(false);\n      this._hideTimeoutId = undefined;\n    }, delay);\n  }\n  /** Returns an observable that notifies when the tooltip has been hidden from view. */\n  afterHidden() {\n    return this._onHide;\n  }\n  /** Whether the tooltip is being displayed. */\n  isVisible() {\n    return this._isVisible;\n  }\n  ngOnDestroy() {\n    this._cancelPendingAnimations();\n    this._onHide.complete();\n    this._triggerElement = null;\n  }\n  /**\n   * Interactions on the HTML body should close the tooltip immediately as defined in the\n   * material design spec.\n   * https://material.io/design/components/tooltips.html#behavior\n   */\n  _handleBodyInteraction() {\n    if (this._closeOnInteraction) {\n      this.hide(0);\n    }\n  }\n  /**\n   * Marks that the tooltip needs to be checked in the next change detection run.\n   * Mainly used for rendering the initial text before positioning a tooltip, which\n   * can be problematic in components with OnPush change detection.\n   */\n  _markForCheck() {\n    this._changeDetectorRef.markForCheck();\n  }\n  _handleMouseLeave({\n    relatedTarget\n  }) {\n    if (!relatedTarget || !this._triggerElement.contains(relatedTarget)) {\n      if (this.isVisible()) {\n        this.hide(this._mouseLeaveHideDelay);\n      } else {\n        this._finalizeAnimation(false);\n      }\n    }\n  }\n  /**\n   * Callback for when the timeout in this.show() gets completed.\n   * This method is only needed by the mdc-tooltip, and so it is only implemented\n   * in the mdc-tooltip, not here.\n   */\n  _onShow() {\n    this._isMultiline = this._isTooltipMultiline();\n    this._markForCheck();\n  }\n  /** Whether the tooltip text has overflown to the next line */\n  _isTooltipMultiline() {\n    const rect = this._elementRef.nativeElement.getBoundingClientRect();\n    return rect.height > MIN_HEIGHT && rect.width >= MAX_WIDTH;\n  }\n  /** Event listener dispatched when an animation on the tooltip finishes. */\n  _handleAnimationEnd({\n    animationName\n  }) {\n    if (animationName === this._showAnimation || animationName === this._hideAnimation) {\n      this._finalizeAnimation(animationName === this._showAnimation);\n    }\n  }\n  /** Cancels any pending animation sequences. */\n  _cancelPendingAnimations() {\n    if (this._showTimeoutId != null) {\n      clearTimeout(this._showTimeoutId);\n    }\n    if (this._hideTimeoutId != null) {\n      clearTimeout(this._hideTimeoutId);\n    }\n    this._showTimeoutId = this._hideTimeoutId = undefined;\n  }\n  /** Handles the cleanup after an animation has finished. */\n  _finalizeAnimation(toVisible) {\n    if (toVisible) {\n      this._closeOnInteraction = true;\n    } else if (!this.isVisible()) {\n      this._onHide.next();\n    }\n  }\n  /** Toggles the visibility of the tooltip element. */\n  _toggleVisibility(isVisible) {\n    // We set the classes directly here ourselves so that toggling the tooltip state\n    // isn't bound by change detection. This allows us to hide it even if the\n    // view ref has been detached from the CD tree.\n    const tooltip = this._tooltip.nativeElement;\n    const showClass = this._showAnimation;\n    const hideClass = this._hideAnimation;\n    tooltip.classList.remove(isVisible ? hideClass : showClass);\n    tooltip.classList.add(isVisible ? showClass : hideClass);\n    if (this._isVisible !== isVisible) {\n      this._isVisible = isVisible;\n      this._changeDetectorRef.markForCheck();\n    }\n    // It's common for internal apps to disable animations using `* { animation: none !important }`\n    // which can break the opening sequence. Try to detect such cases and work around them.\n    if (isVisible && !this._animationsDisabled && typeof getComputedStyle === 'function') {\n      const styles = getComputedStyle(tooltip);\n      // Use `getPropertyValue` to avoid issues with property renaming.\n      if (styles.getPropertyValue('animation-duration') === '0s' || styles.getPropertyValue('animation-name') === 'none') {\n        this._animationsDisabled = true;\n      }\n    }\n    if (isVisible) {\n      this._onShow();\n    }\n    if (this._animationsDisabled) {\n      tooltip.classList.add('_mat-animation-noopable');\n      this._finalizeAnimation(isVisible);\n    }\n  }\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: TooltipComponent,\n      deps: [{\n        token: i0.ChangeDetectorRef\n      }, {\n        token: i0.ElementRef\n      }, {\n        token: ANIMATION_MODULE_TYPE,\n        optional: true\n      }],\n      target: i0.ɵɵFactoryTarget.Component\n    });\n  }\n  static {\n    this.ɵcmp = i0.ɵɵngDeclareComponent({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      type: TooltipComponent,\n      isStandalone: true,\n      selector: \"mat-tooltip-component\",\n      host: {\n        attributes: {\n          \"aria-hidden\": \"true\"\n        },\n        listeners: {\n          \"mouseleave\": \"_handleMouseLeave($event)\"\n        },\n        properties: {\n          \"style.zoom\": \"isVisible() ? 1 : null\"\n        }\n      },\n      viewQueries: [{\n        propertyName: \"_tooltip\",\n        first: true,\n        predicate: [\"tooltip\"],\n        descendants: true,\n        static: true\n      }],\n      ngImport: i0,\n      template: \"<div\\n  #tooltip\\n  class=\\\"mdc-tooltip mat-mdc-tooltip\\\"\\n  [ngClass]=\\\"tooltipClass\\\"\\n  (animationend)=\\\"_handleAnimationEnd($event)\\\"\\n  [class.mdc-tooltip--multiline]=\\\"_isMultiline\\\">\\n  <div class=\\\"mat-mdc-tooltip-surface mdc-tooltip__surface\\\">{{message}}</div>\\n</div>\\n\",\n      styles: [\".mat-mdc-tooltip{position:relative;transform:scale(0);display:inline-flex}.mat-mdc-tooltip::before{content:\\\"\\\";top:0;right:0;bottom:0;left:0;z-index:-1;position:absolute}.mat-mdc-tooltip-panel-below .mat-mdc-tooltip::before{top:-8px}.mat-mdc-tooltip-panel-above .mat-mdc-tooltip::before{bottom:-8px}.mat-mdc-tooltip-panel-right .mat-mdc-tooltip::before{left:-8px}.mat-mdc-tooltip-panel-left .mat-mdc-tooltip::before{right:-8px}.mat-mdc-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.mat-mdc-tooltip-surface{word-break:normal;overflow-wrap:anywhere;padding:4px 8px;min-width:40px;max-width:200px;min-height:24px;max-height:40vh;box-sizing:border-box;overflow:hidden;text-align:center;will-change:transform,opacity;background-color:var(--mdc-plain-tooltip-container-color);color:var(--mdc-plain-tooltip-supporting-text-color);border-radius:var(--mdc-plain-tooltip-container-shape);font-family:var(--mdc-plain-tooltip-supporting-text-font);font-size:var(--mdc-plain-tooltip-supporting-text-size);font-weight:var(--mdc-plain-tooltip-supporting-text-weight);line-height:var(--mdc-plain-tooltip-supporting-text-line-height);letter-spacing:var(--mdc-plain-tooltip-supporting-text-tracking)}.mat-mdc-tooltip-surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:\\\"\\\";pointer-events:none}.mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:left}[dir=rtl] .mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:right}.mat-mdc-tooltip-panel.mat-mdc-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-mdc-tooltip-show{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes mat-mdc-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}.mat-mdc-tooltip-show{animation:mat-mdc-tooltip-show 150ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-mdc-tooltip-hide{animation:mat-mdc-tooltip-hide 75ms cubic-bezier(0.4, 0, 1, 1) forwards}\"],\n      dependencies: [{\n        kind: \"directive\",\n        type: NgClass,\n        selector: \"[ngClass]\",\n        inputs: [\"class\", \"ngClass\"]\n      }],\n      changeDetection: i0.ChangeDetectionStrategy.OnPush,\n      encapsulation: i0.ViewEncapsulation.None\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: TooltipComponent,\n  decorators: [{\n    type: Component,\n    args: [{\n      selector: 'mat-tooltip-component',\n      encapsulation: ViewEncapsulation.None,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      host: {\n        // Forces the element to have a layout in IE and Edge. This fixes issues where the element\n        // won't be rendered if the animations are disabled or there is no web animations polyfill.\n        '[style.zoom]': 'isVisible() ? 1 : null',\n        '(mouseleave)': '_handleMouseLeave($event)',\n        'aria-hidden': 'true'\n      },\n      standalone: true,\n      imports: [NgClass],\n      template: \"<div\\n  #tooltip\\n  class=\\\"mdc-tooltip mat-mdc-tooltip\\\"\\n  [ngClass]=\\\"tooltipClass\\\"\\n  (animationend)=\\\"_handleAnimationEnd($event)\\\"\\n  [class.mdc-tooltip--multiline]=\\\"_isMultiline\\\">\\n  <div class=\\\"mat-mdc-tooltip-surface mdc-tooltip__surface\\\">{{message}}</div>\\n</div>\\n\",\n      styles: [\".mat-mdc-tooltip{position:relative;transform:scale(0);display:inline-flex}.mat-mdc-tooltip::before{content:\\\"\\\";top:0;right:0;bottom:0;left:0;z-index:-1;position:absolute}.mat-mdc-tooltip-panel-below .mat-mdc-tooltip::before{top:-8px}.mat-mdc-tooltip-panel-above .mat-mdc-tooltip::before{bottom:-8px}.mat-mdc-tooltip-panel-right .mat-mdc-tooltip::before{left:-8px}.mat-mdc-tooltip-panel-left .mat-mdc-tooltip::before{right:-8px}.mat-mdc-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.mat-mdc-tooltip-surface{word-break:normal;overflow-wrap:anywhere;padding:4px 8px;min-width:40px;max-width:200px;min-height:24px;max-height:40vh;box-sizing:border-box;overflow:hidden;text-align:center;will-change:transform,opacity;background-color:var(--mdc-plain-tooltip-container-color);color:var(--mdc-plain-tooltip-supporting-text-color);border-radius:var(--mdc-plain-tooltip-container-shape);font-family:var(--mdc-plain-tooltip-supporting-text-font);font-size:var(--mdc-plain-tooltip-supporting-text-size);font-weight:var(--mdc-plain-tooltip-supporting-text-weight);line-height:var(--mdc-plain-tooltip-supporting-text-line-height);letter-spacing:var(--mdc-plain-tooltip-supporting-text-tracking)}.mat-mdc-tooltip-surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:\\\"\\\";pointer-events:none}.mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:left}[dir=rtl] .mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:right}.mat-mdc-tooltip-panel.mat-mdc-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-mdc-tooltip-show{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes mat-mdc-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}.mat-mdc-tooltip-show{animation:mat-mdc-tooltip-show 150ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-mdc-tooltip-hide{animation:mat-mdc-tooltip-hide 75ms cubic-bezier(0.4, 0, 1, 1) forwards}\"]\n    }]\n  }],\n  ctorParameters: () => [{\n    type: i0.ChangeDetectorRef\n  }, {\n    type: i0.ElementRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [ANIMATION_MODULE_TYPE]\n    }]\n  }],\n  propDecorators: {\n    _tooltip: [{\n      type: ViewChild,\n      args: ['tooltip', {\n        // Use a static query here since we interact directly with\n        // the DOM which can happen before `ngAfterViewInit`.\n        static: true\n      }]\n    }]\n  }\n});\n\n/**\n * Animations used by MatTooltip.\n * @docs-private\n */\nconst matTooltipAnimations = {\n  /** Animation that transitions a tooltip in and out. */\n  tooltipState: trigger('state', [\n  // TODO(crisbeto): these values are based on MDC's CSS.\n  // We should be able to use their styles directly once we land #19432.\n  state('initial, void, hidden', style({\n    opacity: 0,\n    transform: 'scale(0.8)'\n  })), state('visible', style({\n    transform: 'scale(1)'\n  })), transition('* => visible', animate('150ms cubic-bezier(0, 0, 0.2, 1)')), transition('* => hidden', animate('75ms cubic-bezier(0.4, 0, 1, 1)'))])\n};\nclass MatTooltipModule {\n  static {\n    this.ɵfac = i0.ɵɵngDeclareFactory({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: MatTooltipModule,\n      deps: [],\n      target: i0.ɵɵFactoryTarget.NgModule\n    });\n  }\n  static {\n    this.ɵmod = i0.ɵɵngDeclareNgModule({\n      minVersion: \"14.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: MatTooltipModule,\n      imports: [A11yModule, CommonModule, OverlayModule, MatCommonModule, MatTooltip, TooltipComponent],\n      exports: [MatTooltip, TooltipComponent, MatCommonModule, CdkScrollableModule]\n    });\n  }\n  static {\n    this.ɵinj = i0.ɵɵngDeclareInjector({\n      minVersion: \"12.0.0\",\n      version: \"18.2.0-next.2\",\n      ngImport: i0,\n      type: MatTooltipModule,\n      providers: [MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER],\n      imports: [A11yModule, CommonModule, OverlayModule, MatCommonModule, MatCommonModule, CdkScrollableModule]\n    });\n  }\n}\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"18.2.0-next.2\",\n  ngImport: i0,\n  type: MatTooltipModule,\n  decorators: [{\n    type: NgModule,\n    args: [{\n      imports: [A11yModule, CommonModule, OverlayModule, MatCommonModule, MatTooltip, TooltipComponent],\n      exports: [MatTooltip, TooltipComponent, MatCommonModule, CdkScrollableModule],\n      providers: [MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER]\n    }]\n  }]\n});\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_TOOLTIP_DEFAULT_OPTIONS, MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY, MAT_TOOLTIP_SCROLL_STRATEGY, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER, MatTooltip, MatTooltipModule, SCROLL_THROTTLE_MS, TOOLTIP_PANEL_CLASS, TooltipComponent, getMatTooltipInvalidPositionError, matTooltipAnimations };\n"],"mappings":"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","names":["DataSource","isDataSource","value","ConnectableObservable","ArrayDataSource","_data","isObservable","of","_ViewRepeaterOperation","_VIEW_REPEATER_STRATEGY","InjectionToken","_RecycleViewRepeaterStrategy","changes","viewContainerRef","itemContextFactory","itemValueResolver","itemViewChanged","record","adjustedPreviousIndex","currentIndex","view","operation","viewArgsFactory","_ViewRepeaterOperation","value","cachedView","viewArgs","index","detachedView","_UniqueSelectionDispatcher","id","name","listener","registered","ɵɵngDeclareFactory","core_exports","FactoryTarget","ɵɵngDeclareInjectable","UniqueSelectionDispatcher","ɵɵngDeclareClassMetadata","Injectable","VIRTUAL_SCROLL_STRATEGY","InjectionToken","FixedSizeVirtualScrollStrategy","itemSize","minBufferPx","maxBufferPx","Subject","distinctUntilChanged","viewport","index","behavior","renderedRange","newRange","viewportSize","dataLength","scrollOffset","firstVisibleIndex","maxVisibleItems","newVisibleIndex","startBuffer","expandStart","endBuffer","expandEnd","_fixedSizeVirtualScrollStrategyFactory","fixedSizeDir","_CdkFixedSizeVirtualScroll","value","coerceNumberProperty","ɵɵngDeclareFactory","core_exports","FactoryTarget","ɵɵngDeclareDirective","forwardRef","CdkFixedSizeVirtualScroll","ɵɵngDeclareClassMetadata","Directive","Input","DEFAULT_SCROLL_TIME","_ScrollDispatcher","_ngZone","_platform","document","scrollable","scrollableReference","auditTimeInMs","Observable","observer","subscription","auditTime","of","_","container","elementOrElementRef","ancestors","filter","target","scrollingContainers","_subscription","element","coerceElement","scrollableElement","window","fromEvent","NgZone","Platform","DOCUMENT","ɵɵngDeclareInjectable","ScrollDispatcher","Injectable","Optional","Inject","_CdkScrollable","elementRef","scrollDispatcher","ngZone","dir","takeUntil","options","el","isRtl","getRtlScrollAxisType","RtlScrollAxisType","supportsScrollBehavior","from","LEFT","RIGHT","ElementRef","Directionality","CdkScrollable","DEFAULT_RESIZE_TIME","_ViewportRuler","event","output","scrollPosition","width","height","documentElement","documentRect","top","left","throttleTime","ViewportRuler","VIRTUAL_SCROLLABLE","_CdkVirtualScrollable","orientation","viewportEl","CdkVirtualScrollable","rangesEqual","r1","r2","SCROLL_SCHEDULER","animationFrameScheduler","asapScheduler","_CdkVirtualScrollViewport","_changeDetectorRef","_scrollStrategy","viewportRuler","inject","Subscription","Injector","startWith","forOf","data","newLength","size","range","offset","to","isHorizontal","axis","transform","measureScrollOffset","_from","fromRect","scrollerClientRect","contentEl","runAfter","afterNextRender","runAfterChangeDetection","fn","ChangeDetectorRef","ɵɵngDeclareComponent","booleanAttribute","virtualScrollable","ChangeDetectionStrategy","ViewEncapsulation$1","CdkVirtualScrollViewport","Component","Output","ViewChild","getOffset","direction","node","rect","_CdkVirtualForOf","isDataSource","ArrayDataSource","isObservable","item","_viewContainerRef","_template","_differs","_viewRepeater","_viewport","pairwise","switchMap","prev","cur","shareReplay","renderedStartIndex","rangeLen","firstNode","lastNode","i","view","changes","oldDs","newDs","count","record","_adjustedPreviousIndex","currentIndex","context","ViewContainerRef","TemplateRef","IterableDiffers","_VIEW_REPEATER_STRATEGY","_RecycleViewRepeaterStrategy","CdkVirtualForOf","SkipSelf","_CdkVirtualScrollableElement","CdkVirtualScrollableElement","_CdkVirtualScrollableWindow","CdkVirtualScrollableWindow","_CdkScrollableModule","ɵɵngDeclareNgModule","ɵɵngDeclareInjector","CdkScrollableModule","NgModule","_ScrollingModule","BidiModule","ScrollingModule","Portal","host","ComponentPortal","component","viewContainerRef","injector","componentFactoryResolver","projectableNodes","TemplatePortal","templateRef","context","DomPortal","element","ElementRef","BasePortalOutlet","portal","fn","DomPortalOutlet","BasePortalOutlet","outletElement","_componentFactoryResolver","_appRef","_defaultInjector","_document","portal","element","anchorNode","componentFactory","componentRef","Injector","viewContainer","viewRef","rootNode","index","_CdkPortal","TemplatePortal","templateRef","viewContainerRef","ɵɵngDeclareFactory","core_exports","TemplateRef","ViewContainerRef","FactoryTarget","ɵɵngDeclareDirective","CdkPortal","ɵɵngDeclareClassMetadata","Directive","_TemplatePortalDirective","TemplatePortalDirective","_CdkPortalOutlet","BasePortalOutlet","_componentFactoryResolver","_viewContainerRef","_document","EventEmitter","portal","element","anchorNode","componentFactory","ref","viewRef","nativeElement","ComponentFactoryResolver$1","DOCUMENT","CdkPortalOutlet","Inject","Input","Output","_PortalHostDirective","PortalHostDirective","_PortalModule","ɵɵngDeclareNgModule","ɵɵngDeclareInjector","PortalModule","NgModule","scrollBehaviorSupported","supportsScrollBehavior","BlockScrollStrategy","_viewportRuler","document","root","coerceCssPixelValue","html","body","htmlStyle","bodyStyle","previousHtmlScrollBehavior","previousBodyScrollBehavior","viewport","CloseScrollStrategy","_scrollDispatcher","_ngZone","_viewportRuler","_config","overlayRef","stream","filter","scrollable","scrollPosition","NoopScrollStrategy","isElementScrolledOutsideView","element","scrollContainers","containerBounds","outsideAbove","outsideBelow","outsideLeft","outsideRight","isElementClippedByScrolling","scrollContainerRect","clippedAbove","clippedBelow","clippedLeft","clippedRight","RepositionScrollStrategy","throttle","overlayRect","width","height","_ScrollStrategyOptions","document","config","BlockScrollStrategy","ɵɵngDeclareFactory","core_exports","ScrollDispatcher","ViewportRuler","NgZone","DOCUMENT","FactoryTarget","ɵɵngDeclareInjectable","ScrollStrategyOptions","ɵɵngDeclareClassMetadata","Injectable","Inject","OverlayConfig","configKeys","key","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","_BaseOverlayDispatcher","document","overlayRef","index","ɵɵngDeclareFactory","core_exports","DOCUMENT","FactoryTarget","ɵɵngDeclareInjectable","BaseOverlayDispatcher","ɵɵngDeclareClassMetadata","Injectable","Inject","_OverlayKeyboardDispatcher","_ngZone","event","overlays","i","keydownEvents","NgZone","OverlayKeyboardDispatcher","Optional","_OverlayOutsideClickDispatcher","_platform","_getEventTarget","target","origin","containsPierceShadowDom","outsidePointerEvents","body","Platform","OverlayOutsideClickDispatcher","parent","child","supportsShadowRoot","current","_OverlayContainer","containerClass","_isTestEnvironment","oppositePlatformContainers","container","OverlayContainer","OverlayRef","_portalOutlet","_host","_pane","_config","_keyboardDispatcher","_document","_location","_outsideClickDispatcher","_animationsDisabled","_injector","Subject","Subscription","untracked","afterRender","portal","attachResult","afterNextRender","detachmentResult","isAttached","strategy","sizeConfig","__spreadValues","dir","__spreadProps","classes","direction","style","coerceCssPixelValue","enablePointer","showingClass","backdropToDetach","element","cssClasses","isAdd","coerceArray","c","subscription","takeUntil","merge","scrollStrategy","backdrop","boundingBoxClass","cssUnitPattern","FlexibleConnectedPositionStrategy","connectedTo","_viewportRuler","_overlayContainer","originRect","overlayRect","viewportRect","containerRect","flexibleFits","fallback","pos","originPoint","overlayPoint","overlayFit","bestFit","bestScore","fit","score","extendStyles","lastPosition","scrollables","positions","margin","flexibleDimensions","growAfterOpen","canPush","isLocked","offset","selector","x","startX","endX","y","overlayStartX","overlayStartY","point","rawOverlayRect","viewport","position","overlay","getRoundedBoundingClientRect","offsetX","offsetY","leftOverflow","rightOverflow","topOverflow","bottomOverflow","visibleWidth","visibleHeight","visibleArea","availableHeight","availableWidth","minHeight","getPixelValue","minWidth","verticalFit","horizontalFit","start","scrollPosition","overflowRight","overflowBottom","overflowTop","overflowLeft","pushX","pushY","scrollVisibility","compareScrollVisibility","changeEvent","ConnectedOverlayPositionChange","elements","xOrigin","yOrigin","isRtl","height","top","bottom","smallestDistanceToViewportEdge","previousHeight","isBoundedByRightViewportEdge","isBoundedByLeftViewportEdge","width","left","right","previousWidth","boundingBoxRect","styles","maxHeight","maxWidth","hasExactPosition","hasFlexibleDimensions","config","transformString","documentHeight","horizontalStyleProperty","documentWidth","originBounds","overlayBounds","scrollContainerBounds","scrollable","isElementClippedByScrolling","isElementScrolledOutsideView","length","overflows","currentValue","currentOverflow","axis","cssClass","ElementRef","destination","source","key","input","value","units","clientRect","a","b","wrapperClass","GlobalPositionStrategy","overlayRef","config","value","offset","styles","parentStyles","width","height","maxWidth","maxHeight","shouldBeFlushHorizontally","shouldBeFlushVertically","xPosition","xOffset","isRtl","marginLeft","marginRight","justifyContent","parent","_OverlayPositionBuilder","_viewportRuler","_document","_platform","_overlayContainer","origin","FlexibleConnectedPositionStrategy","ɵɵngDeclareFactory","core_exports","ViewportRuler","DOCUMENT","Platform","OverlayContainer","FactoryTarget","ɵɵngDeclareInjectable","OverlayPositionBuilder","ɵɵngDeclareClassMetadata","Injectable","Inject","nextUniqueId","_Overlay","scrollStrategies","_componentFactoryResolver","_positionBuilder","_keyboardDispatcher","_injector","_ngZone","_directionality","_location","_outsideClickDispatcher","_animationsModuleType","host","pane","portalOutlet","overlayConfig","OverlayConfig","OverlayRef","EnvironmentInjector","ApplicationRef","DomPortalOutlet","ScrollStrategyOptions","ComponentFactoryResolver$1","OverlayKeyboardDispatcher","Injector","NgZone","Directionality","Location","OverlayOutsideClickDispatcher","ANIMATION_MODULE_TYPE","Overlay","Optional","defaultPositionList","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY","InjectionToken","overlay","inject","_CdkOverlayOrigin","elementRef","ElementRef","ɵɵngDeclareDirective","CdkOverlayOrigin","Directive","_CdkConnectedOverlay","offsetX","offsetY","_overlay","templateRef","viewContainerRef","scrollStrategyFactory","_dir","Subscription","EventEmitter","TemplatePortal","changes","event","hasModifierKey","target","_getEventTarget","positionStrategy","positions","currentPosition","strategy","takeWhile","position","TemplateRef","ViewContainerRef","booleanAttribute","CdkConnectedOverlay","Input","Output","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","_OverlayModule","ɵɵngDeclareNgModule","BidiModule","PortalModule","ScrollingModule","ɵɵngDeclareInjector","OverlayModule","NgModule","_FullscreenOverlayContainer","platform","fn","eventName","FullscreenOverlayContainer","SCROLL_THROTTLE_MS","MAT_TOOLTIP_SCROLL_STRATEGY","InjectionToken","overlay","inject","Overlay","SCROLL_THROTTLE_MS","MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY","MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER","MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY","MAT_TOOLTIP_DEFAULT_OPTIONS","PANEL_CLASS","passiveListenerOptions","normalizePassiveListenerOptions","MIN_VIEWPORT_TOOLTIP_THRESHOLD","UNBOUNDED_ANCHOR_GAP","MIN_HEIGHT","MAX_WIDTH","_MatTooltip","value","coerceBooleanProperty","coerceNumberProperty","_overlay","_elementRef","_scrollDispatcher","_viewContainerRef","_ngZone","_platform","_ariaDescriber","_focusMonitor","scrollStrategy","_dir","_defaultOptions","_document","TooltipComponent","Subject","inject","Injector","takeUntil","origin","nativeElement","event","listener","delay","overlayRef","ComponentPortal","instance","existingStrategy","ElementRef","scrollableAncestors","strategy","change","hasModifierKey","position","overlay","__spreadValues","offset","isLtr","originPosition","x","y","overlayPosition","afterNextRender","tooltipClass","connectionPair","overlayY","originX","originY","newPosition","classPrefix","point","touch","DEFAULT_LONGPRESS_DELAY","exitListeners","newTarget","touchendListener","listeners","elementUnderPointer","element","gestures","style","ɵɵngDeclareFactory","core_exports","Overlay","ScrollDispatcher","ViewContainerRef","NgZone","Platform","AriaDescriber","FocusMonitor","MAT_TOOLTIP_SCROLL_STRATEGY","Directionality","MAT_TOOLTIP_DEFAULT_OPTIONS","DOCUMENT","FactoryTarget","ɵɵngDeclareDirective","MatTooltip","ɵɵngDeclareClassMetadata","Directive","Inject","Optional","Input","_TooltipComponent","_changeDetectorRef","animationMode","relatedTarget","rect","animationName","toVisible","isVisible","tooltip","showClass","hideClass","styles","ChangeDetectorRef","ANIMATION_MODULE_TYPE","ɵɵngDeclareComponent","NgClass","ChangeDetectionStrategy","ViewEncapsulation$1","Component","ViewChild","matTooltipAnimations","trigger","state","transition","animate","_MatTooltipModule","ɵɵngDeclareNgModule","A11yModule","CommonModule","OverlayModule","MatCommonModule","CdkScrollableModule","ɵɵngDeclareInjector","MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER","MatTooltipModule","NgModule"],"x_google_ignoreList":[0,1,2,3,4]}