(function () {
  "use strict";

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
  function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
  function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  (self["webpackChunkcomplex_portal_view"] = self["webpackChunkcomplex_portal_view"] || []).push([["default-node_modules_angular_material___ivy_ngcc___fesm2015_tooltip_js-src_app_complex_comple-8a6e67"], {
    /***/62604:
    /*!************************************************************************!*\
      !*** ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/collections.js ***!
      \************************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"ArrayDataSource": function ArrayDataSource() {
          return (/* binding */_ArrayDataSource
          );
        },
        /* harmony export */"DataSource": function DataSource() {
          return (/* binding */_DataSource
          );
        },
        /* harmony export */"SelectionModel": function SelectionModel() {
          return (/* binding */_SelectionModel
          );
        },
        /* harmony export */"UniqueSelectionDispatcher": function UniqueSelectionDispatcher() {
          return (/* binding */_UniqueSelectionDispatcher
          );
        },
        /* harmony export */"_DisposeViewRepeaterStrategy": function _DisposeViewRepeaterStrategy() {
          return (/* binding */_DisposeViewRepeaterStrategy2
          );
        },
        /* harmony export */"_RecycleViewRepeaterStrategy": function _RecycleViewRepeaterStrategy() {
          return (/* binding */_RecycleViewRepeaterStrategy2
          );
        },
        /* harmony export */"_VIEW_REPEATER_STRATEGY": function _VIEW_REPEATER_STRATEGY() {
          return (/* binding */_VIEW_REPEATER_STRATEGY2
          );
        },
        /* harmony export */"getMultipleValuesInSingleSelectionError": function getMultipleValuesInSingleSelectionError() {
          return (/* binding */_getMultipleValuesInSingleSelectionError
          );
        },
        /* harmony export */"isDataSource": function isDataSource() {
          return (/* binding */_isDataSource
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! rxjs */64674);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! rxjs */81134);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! rxjs */79441);
      /* harmony import */
      var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @angular/core */2316);

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      var _DataSource = /*#__PURE__*/_createClass(function _DataSource() {
        _classCallCheck(this, _DataSource);
      });
      /** Checks whether an object is a data source. */
      function _isDataSource(value) {
        // Check if the value is a DataSource by observing if it has a connect function. Cannot
        // be checked as an `instanceof DataSource` since people could create their own sources
        // that match the interface, but don't extend DataSource.
        return value && typeof value.connect === 'function';
      }

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** DataSource wrapper for a native array. */
      var _ArrayDataSource = /*#__PURE__*/function (_DataSource2) {
        _inherits(_ArrayDataSource, _DataSource2);
        var _super = _createSuper(_ArrayDataSource);
        function _ArrayDataSource(_data) {
          var _this;
          _classCallCheck(this, _ArrayDataSource);
          _this = _super.call(this);
          _this._data = _data;
          return _this;
        }
        _createClass(_ArrayDataSource, [{
          key: "connect",
          value: function connect() {
            return (0, rxjs__WEBPACK_IMPORTED_MODULE_0__.isObservable)(this._data) ? this._data : (0, rxjs__WEBPACK_IMPORTED_MODULE_1__.of)(this._data);
          }
        }, {
          key: "disconnect",
          value: function disconnect() {}
        }]);
        return _ArrayDataSource;
      }(_DataSource);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * A repeater that destroys views when they are removed from a
       * {@link ViewContainerRef}. When new items are inserted into the container,
       * the repeater will always construct a new embedded view for each item.
       *
       * @template T The type for the embedded view's $implicit property.
       * @template R The type for the item in each IterableDiffer change record.
       * @template C The type for the context passed to each embedded view.
       */
      var _DisposeViewRepeaterStrategy2 = /*#__PURE__*/function () {
        function _DisposeViewRepeaterStrategy2() {
          _classCallCheck(this, _DisposeViewRepeaterStrategy2);
        }
        _createClass(_DisposeViewRepeaterStrategy2, [{
          key: "applyChanges",
          value: function applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
            changes.forEachOperation(function (record, adjustedPreviousIndex, currentIndex) {
              var view;
              var operation;
              if (record.previousIndex == null) {
                var insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);
                view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);
                operation = 1 /* INSERTED */;
              } else if (currentIndex == null) {
                viewContainerRef.remove(adjustedPreviousIndex);
                operation = 3 /* REMOVED */;
              } else {
                view = viewContainerRef.get(adjustedPreviousIndex);
                viewContainerRef.move(view, currentIndex);
                operation = 2 /* MOVED */;
              }

              if (itemViewChanged) {
                itemViewChanged({
                  context: view === null || view === void 0 ? void 0 : view.context,
                  operation: operation,
                  record: record
                });
              }
            });
          }
        }, {
          key: "detach",
          value: function detach() {}
        }]);
        return _DisposeViewRepeaterStrategy2;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * A repeater that caches views when they are removed from a
       * {@link ViewContainerRef}. When new items are inserted into the container,
       * the repeater will reuse one of the cached views instead of creating a new
       * embedded view. Recycling cached views reduces the quantity of expensive DOM
       * inserts.
       *
       * @template T The type for the embedded view's $implicit property.
       * @template R The type for the item in each IterableDiffer change record.
       * @template C The type for the context passed to each embedded view.
       */
      var _RecycleViewRepeaterStrategy2 = /*#__PURE__*/function () {
        function _RecycleViewRepeaterStrategy2() {
          _classCallCheck(this, _RecycleViewRepeaterStrategy2);
          /**
           * The size of the cache used to store unused views.
           * Setting the cache size to `0` will disable caching. Defaults to 20 views.
           */
          this.viewCacheSize = 20;
          /**
           * View cache that stores embedded view instances that have been previously stamped out,
           * but don't are not currently rendered. The view repeater will reuse these views rather than
           * creating brand new ones.
           *
           * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.
           */
          this._viewCache = [];
        }
        /** Apply changes to the DOM. */
        _createClass(_RecycleViewRepeaterStrategy2, [{
          key: "applyChanges",
          value: function applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
            var _this2 = this;
            // Rearrange the views to put them in the right location.
            changes.forEachOperation(function (record, adjustedPreviousIndex, currentIndex) {
              var view;
              var operation;
              if (record.previousIndex == null) {
                // Item added.
                var viewArgsFactory = function viewArgsFactory() {
                  return itemContextFactory(record, adjustedPreviousIndex, currentIndex);
                };
                view = _this2._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
                operation = view ? 1 /* INSERTED */ : 0 /* REPLACED */;
              } else if (currentIndex == null) {
                // Item removed.
                _this2._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
                operation = 3 /* REMOVED */;
              } else {
                // Item moved.
                view = _this2._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
                operation = 2 /* MOVED */;
              }

              if (itemViewChanged) {
                itemViewChanged({
                  context: view === null || view === void 0 ? void 0 : view.context,
                  operation: operation,
                  record: record
                });
              }
            });
          }
        }, {
          key: "detach",
          value: function detach() {
            var _iterator = _createForOfIteratorHelper(this._viewCache),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var view = _step.value;
                view.destroy();
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            this._viewCache = [];
          }
          /**
           * Inserts a view for a new item, either from the cache or by creating a new
           * one. Returns `undefined` if the item was inserted into a cached view.
           */
        }, {
          key: "_insertView",
          value: function _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
            var cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
            if (cachedView) {
              cachedView.context.$implicit = value;
              return undefined;
            }
            var viewArgs = viewArgsFactory();
            return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
          }
          /** Detaches the view at the given index and inserts into the view cache. */
        }, {
          key: "_detachAndCacheView",
          value: function _detachAndCacheView(index, viewContainerRef) {
            var detachedView = viewContainerRef.detach(index);
            this._maybeCacheView(detachedView, viewContainerRef);
          }
          /** Moves view at the previous index to the current index. */
        }, {
          key: "_moveView",
          value: function _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
            var view = viewContainerRef.get(adjustedPreviousIndex);
            viewContainerRef.move(view, currentIndex);
            view.context.$implicit = value;
            return view;
          }
          /**
           * Cache the given detached view. If the cache is full, the view will be
           * destroyed.
           */
        }, {
          key: "_maybeCacheView",
          value: function _maybeCacheView(view, viewContainerRef) {
            if (this._viewCache.length < this.viewCacheSize) {
              this._viewCache.push(view);
            } else {
              var index = viewContainerRef.indexOf(view);
              // The host component could remove views from the container outside of
              // the view repeater. It's unlikely this will occur, but just in case,
              // destroy the view on its own, otherwise destroy it through the
              // container to ensure that all the references are removed.
              if (index === -1) {
                view.destroy();
              } else {
                viewContainerRef.remove(index);
              }
            }
          }
          /** Inserts a recycled view from the cache at the given index. */
        }, {
          key: "_insertViewFromCache",
          value: function _insertViewFromCache(index, viewContainerRef) {
            var cachedView = this._viewCache.pop();
            if (cachedView) {
              viewContainerRef.insert(cachedView, index);
            }
            return cachedView || null;
          }
        }]);
        return _RecycleViewRepeaterStrategy2;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Class to be used to power selecting one or more options from a list.
       */
      var _SelectionModel = /*#__PURE__*/function () {
        function _SelectionModel() {
          var _this3 = this;
          var _multiple = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var initiallySelectedValues = arguments.length > 1 ? arguments[1] : undefined;
          var _emitChanges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          _classCallCheck(this, _SelectionModel);
          this._multiple = _multiple;
          this._emitChanges = _emitChanges;
          /** Currently-selected values. */
          this._selection = new Set();
          /** Keeps track of the deselected options that haven't been emitted by the change event. */
          this._deselectedToEmit = [];
          /** Keeps track of the selected options that haven't been emitted by the change event. */
          this._selectedToEmit = [];
          /** Event emitted when the value has changed. */
          this.changed = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
          if (initiallySelectedValues && initiallySelectedValues.length) {
            if (_multiple) {
              initiallySelectedValues.forEach(function (value) {
                return _this3._markSelected(value);
              });
            } else {
              this._markSelected(initiallySelectedValues[0]);
            }
            // Clear the array in order to avoid firing the change event for preselected values.
            this._selectedToEmit.length = 0;
          }
        }
        /** Selected values. */
        _createClass(_SelectionModel, [{
          key: "selected",
          get: function get() {
            if (!this._selected) {
              this._selected = Array.from(this._selection.values());
            }
            return this._selected;
          }
          /**
           * Selects a value or an array of values.
           */
        }, {
          key: "select",
          value: function select() {
            var _this4 = this;
            for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
              values[_key] = arguments[_key];
            }
            this._verifyValueAssignment(values);
            values.forEach(function (value) {
              return _this4._markSelected(value);
            });
            this._emitChangeEvent();
          }
          /**
           * Deselects a value or an array of values.
           */
        }, {
          key: "deselect",
          value: function deselect() {
            var _this5 = this;
            for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              values[_key2] = arguments[_key2];
            }
            this._verifyValueAssignment(values);
            values.forEach(function (value) {
              return _this5._unmarkSelected(value);
            });
            this._emitChangeEvent();
          }
          /**
           * Toggles a value between selected and deselected.
           */
        }, {
          key: "toggle",
          value: function toggle(value) {
            this.isSelected(value) ? this.deselect(value) : this.select(value);
          }
          /**
           * Clears all of the selected values.
           */
        }, {
          key: "clear",
          value: function clear() {
            this._unmarkAll();
            this._emitChangeEvent();
          }
          /**
           * Determines whether a value is selected.
           */
        }, {
          key: "isSelected",
          value: function isSelected(value) {
            return this._selection.has(value);
          }
          /**
           * Determines whether the model does not have a value.
           */
        }, {
          key: "isEmpty",
          value: function isEmpty() {
            return this._selection.size === 0;
          }
          /**
           * Determines whether the model has a value.
           */
        }, {
          key: "hasValue",
          value: function hasValue() {
            return !this.isEmpty();
          }
          /**
           * Sorts the selected values based on a predicate function.
           */
        }, {
          key: "sort",
          value: function sort(predicate) {
            if (this._multiple && this.selected) {
              this._selected.sort(predicate);
            }
          }
          /**
           * Gets whether multiple values can be selected.
           */
        }, {
          key: "isMultipleSelection",
          value: function isMultipleSelection() {
            return this._multiple;
          }
          /** Emits a change event and clears the records of selected and deselected values. */
        }, {
          key: "_emitChangeEvent",
          value: function _emitChangeEvent() {
            // Clear the selected values so they can be re-cached.
            this._selected = null;
            if (this._selectedToEmit.length || this._deselectedToEmit.length) {
              this.changed.next({
                source: this,
                added: this._selectedToEmit,
                removed: this._deselectedToEmit
              });
              this._deselectedToEmit = [];
              this._selectedToEmit = [];
            }
          }
          /** Selects a value. */
        }, {
          key: "_markSelected",
          value: function _markSelected(value) {
            if (!this.isSelected(value)) {
              if (!this._multiple) {
                this._unmarkAll();
              }
              this._selection.add(value);
              if (this._emitChanges) {
                this._selectedToEmit.push(value);
              }
            }
          }
          /** Deselects a value. */
        }, {
          key: "_unmarkSelected",
          value: function _unmarkSelected(value) {
            if (this.isSelected(value)) {
              this._selection["delete"](value);
              if (this._emitChanges) {
                this._deselectedToEmit.push(value);
              }
            }
          }
          /** Clears out the selected values. */
        }, {
          key: "_unmarkAll",
          value: function _unmarkAll() {
            var _this6 = this;
            if (!this.isEmpty()) {
              this._selection.forEach(function (value) {
                return _this6._unmarkSelected(value);
              });
            }
          }
          /**
           * Verifies the value assignment and throws an error if the specified value array is
           * including multiple values while the selection model is not supporting multiple values.
           */
        }, {
          key: "_verifyValueAssignment",
          value: function _verifyValueAssignment(values) {
            if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw _getMultipleValuesInSingleSelectionError();
            }
          }
        }]);
        return _SelectionModel;
      }();
      /**
       * Returns an error that reports that multiple values are passed into a selection model
       * with a single value.
       * @docs-private
       */
      function _getMultipleValuesInSingleSelectionError() {
        return Error('Cannot pass multiple values into SelectionModel with single-value mode.');
      }

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Class to coordinate unique selection based on name.
       * Intended to be consumed as an Angular service.
       * This service is needed because native radio change events are only fired on the item currently
       * being selected, and we still need to uncheck the previous selection.
       *
       * This service does not *store* any IDs and names because they may change at any time, so it is
       * less error-prone if they are simply passed through when the events occur.
       */
      var _UniqueSelectionDispatcher = /*#__PURE__*/function () {
        function _UniqueSelectionDispatcher() {
          _classCallCheck(this, _UniqueSelectionDispatcher);
          this._listeners = [];
        }
        /**
         * Notify other items that selection for the given name has been set.
         * @param id ID of the item.
         * @param name Name of the item.
         */
        _createClass(_UniqueSelectionDispatcher, [{
          key: "notify",
          value: function notify(id, name) {
            var _iterator2 = _createForOfIteratorHelper(this._listeners),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var listener = _step2.value;
                listener(id, name);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          /**
           * Listen for future changes to item selection.
           * @return Function used to deregister listener
           */
        }, {
          key: "listen",
          value: function listen(listener) {
            var _this7 = this;
            this._listeners.push(listener);
            return function () {
              _this7._listeners = _this7._listeners.filter(function (registered) {
                return listener !== registered;
              });
            };
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this._listeners = [];
          }
        }]);
        return _UniqueSelectionDispatcher;
      }();
      _UniqueSelectionDispatcher.ɵfac = function UniqueSelectionDispatcher_Factory(t) {
        return new (t || _UniqueSelectionDispatcher)();
      };
      _UniqueSelectionDispatcher.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"]({
        factory: function UniqueSelectionDispatcher_Factory() {
          return new _UniqueSelectionDispatcher();
        },
        token: _UniqueSelectionDispatcher,
        providedIn: "root"
      });
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](_UniqueSelectionDispatcher, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.
       * @docs-private
       */
      var _VIEW_REPEATER_STRATEGY2 = new _angular_core__WEBPACK_IMPORTED_MODULE_3__.InjectionToken('_ViewRepeater');

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/
    },

    /***/66883:
    /*!*******************************************************************!*\
      !*** ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/layout.js ***!
      \*******************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"BreakpointObserver": function BreakpointObserver() {
          return (/* binding */_BreakpointObserver
          );
        },
        /* harmony export */"Breakpoints": function Breakpoints() {
          return (/* binding */_Breakpoints
          );
        },
        /* harmony export */"LayoutModule": function LayoutModule() {
          return (/* binding */_LayoutModule
          );
        },
        /* harmony export */"MediaMatcher": function MediaMatcher() {
          return (/* binding */_MediaMatcher
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @angular/core */2316);
      /* harmony import */
      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @angular/cdk/coercion */20657);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! rxjs */79441);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! rxjs */61486);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! rxjs */76461);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__( /*! rxjs */25160);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! rxjs/operators */53466);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! rxjs/operators */84515);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! rxjs/operators */80639);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! rxjs/operators */33927);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__( /*! rxjs/operators */1143);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__( /*! rxjs/operators */22663);
      /* harmony import */
      var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/cdk/platform */36145);

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      var _LayoutModule = /*#__PURE__*/_createClass(function _LayoutModule() {
        _classCallCheck(this, _LayoutModule);
      });
      _LayoutModule.ɵfac = function LayoutModule_Factory(t) {
        return new (t || _LayoutModule)();
      };
      _LayoutModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
        type: _LayoutModule
      });
      _LayoutModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_LayoutModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
          args: [{}]
        }], null, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Global registry for all dynamically-created, injected media queries. */
      var mediaQueriesForWebkitCompatibility = new Set();
      /** Style tag that holds all of the dynamically-created media queries. */
      var mediaQueryStyleNode;
      /** A utility for calling matchMedia queries. */
      var _MediaMatcher = /*#__PURE__*/function () {
        function _MediaMatcher(_platform) {
          _classCallCheck(this, _MediaMatcher);
          this._platform = _platform;
          this._matchMedia = this._platform.isBrowser && window.matchMedia ?
          // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
          // call it from a different scope.
          window.matchMedia.bind(window) : noopMatchMedia;
        }
        /**
         * Evaluates the given media query and returns the native MediaQueryList from which results
         * can be retrieved.
         * Confirms the layout engine will trigger for the selector query provided and returns the
         * MediaQueryList for the query provided.
         */
        _createClass(_MediaMatcher, [{
          key: "matchMedia",
          value: function matchMedia(query) {
            if (this._platform.WEBKIT || this._platform.BLINK) {
              createEmptyStyleRule(query);
            }
            return this._matchMedia(query);
          }
        }]);
        return _MediaMatcher;
      }();
      _MediaMatcher.ɵfac = function MediaMatcher_Factory(t) {
        return new (t || _MediaMatcher)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform));
      };
      _MediaMatcher.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
        factory: function MediaMatcher_Factory() {
          return new _MediaMatcher(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform));
        },
        token: _MediaMatcher,
        providedIn: "root"
      });
      _MediaMatcher.ctorParameters = function () {
        return [{
          type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_MediaMatcher, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
          }];
        }, null);
      })();
      /**
       * Creates an empty stylesheet that is used to work around browser inconsistencies related to
       * `matchMedia`. At the time of writing, it handles the following cases:
       * 1. On WebKit browsers, a media query has to have at least one rule in order for `matchMedia`
       * to fire. We work around it by declaring a dummy stylesheet with a `@media` declaration.
       * 2. In some cases Blink browsers will stop firing the `matchMedia` listener if none of the rules
       * inside the `@media` match existing elements on the page. We work around it by having one rule
       * targeting the `body`. See https://github.com/angular/components/issues/23546.
       */
      function createEmptyStyleRule(query) {
        if (mediaQueriesForWebkitCompatibility.has(query)) {
          return;
        }
        try {
          if (!mediaQueryStyleNode) {
            mediaQueryStyleNode = document.createElement('style');
            mediaQueryStyleNode.setAttribute('type', 'text/css');
            document.head.appendChild(mediaQueryStyleNode);
          }
          if (mediaQueryStyleNode.sheet) {
            mediaQueryStyleNode.sheet.insertRule("@media ".concat(query, " {body{ }}"), 0);
            mediaQueriesForWebkitCompatibility.add(query);
          }
        } catch (e) {
          console.error(e);
        }
      }
      /** No-op matchMedia replacement for non-browser platforms. */
      function noopMatchMedia(query) {
        // Use `as any` here to avoid adding additional necessary properties for
        // the noop matcher.
        return {
          matches: query === 'all' || query === '',
          media: query,
          addListener: function addListener() {},
          removeListener: function removeListener() {}
        };
      }

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Utility for checking the matching state of @media queries. */
      var _BreakpointObserver = /*#__PURE__*/function () {
        function _BreakpointObserver(_mediaMatcher, _zone) {
          _classCallCheck(this, _BreakpointObserver);
          this._mediaMatcher = _mediaMatcher;
          this._zone = _zone;
          /**  A map of all media queries currently being listened for. */
          this._queries = new Map();
          /** A subject for all other observables to takeUntil based on. */
          this._destroySubject = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
        }
        /** Completes the active subject, signalling to all other observables to complete. */
        _createClass(_BreakpointObserver, [{
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this._destroySubject.next();
            this._destroySubject.complete();
          }
          /**
           * Whether one or more media queries match the current viewport size.
           * @param value One or more media queries to check.
           * @returns Whether any of the media queries match.
           */
        }, {
          key: "isMatched",
          value: function isMatched(value) {
            var _this8 = this;
            var queries = splitQueries((0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceArray)(value));
            return queries.some(function (mediaQuery) {
              return _this8._registerQuery(mediaQuery).mql.matches;
            });
          }
          /**
           * Gets an observable of results for the given queries that will emit new results for any changes
           * in matching of the given queries.
           * @param value One or more media queries to check.
           * @returns A stream of matches for the given queries.
           */
        }, {
          key: "observe",
          value: function observe(value) {
            var _this9 = this;
            var queries = splitQueries((0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceArray)(value));
            var observables = queries.map(function (query) {
              return _this9._registerQuery(query).observable;
            });
            var stateObservable = (0, rxjs__WEBPACK_IMPORTED_MODULE_4__.combineLatest)(observables);
            // Emit the first state immediately, and then debounce the subsequent emissions.
            stateObservable = (0, rxjs__WEBPACK_IMPORTED_MODULE_5__.concat)(stateObservable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.take)(1)), stateObservable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.skip)(1), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.debounceTime)(0)));
            return stateObservable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)(function (breakpointStates) {
              var response = {
                matches: false,
                breakpoints: {}
              };
              breakpointStates.forEach(function (_ref) {
                var matches = _ref.matches,
                  query = _ref.query;
                response.matches = response.matches || matches;
                response.breakpoints[query] = matches;
              });
              return response;
            }));
          }
          /** Registers a specific query to be listened for. */
        }, {
          key: "_registerQuery",
          value: function _registerQuery(query) {
            var _this10 = this;
            // Only set up a new MediaQueryList if it is not already being listened for.
            if (this._queries.has(query)) {
              return this._queries.get(query);
            }
            var mql = this._mediaMatcher.matchMedia(query);
            // Create callback for match changes and add it is as a listener.
            var queryObservable = new rxjs__WEBPACK_IMPORTED_MODULE_10__.Observable(function (observer) {
              // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed
              // back into the zone because matchMedia is only included in Zone.js by loading the
              // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not
              // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js
              // patches it.
              var handler = function handler(e) {
                return _this10._zone.run(function () {
                  return observer.next(e);
                });
              };
              mql.addListener(handler);
              return function () {
                mql.removeListener(handler);
              };
            }).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.startWith)(mql), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)(function (_ref2) {
              var matches = _ref2.matches;
              return {
                query: query,
                matches: matches
              };
            }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.takeUntil)(this._destroySubject));
            // Add the MediaQueryList to the set of queries.
            var output = {
              observable: queryObservable,
              mql: mql
            };
            this._queries.set(query, output);
            return output;
          }
        }]);
        return _BreakpointObserver;
      }();
      _BreakpointObserver.ɵfac = function BreakpointObserver_Factory(t) {
        return new (t || _BreakpointObserver)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_MediaMatcher), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
      };
      _BreakpointObserver.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
        factory: function BreakpointObserver_Factory() {
          return new _BreakpointObserver(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_MediaMatcher), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        },
        token: _BreakpointObserver,
        providedIn: "root"
      });
      _BreakpointObserver.ctorParameters = function () {
        return [{
          type: _MediaMatcher
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_BreakpointObserver, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: _MediaMatcher
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
          }];
        }, null);
      })();
      /**
       * Split each query string into separate query strings if two queries are provided as comma
       * separated.
       */
      function splitQueries(queries) {
        return queries.map(function (query) {
          return query.split(',');
        }).reduce(function (a1, a2) {
          return a1.concat(a2);
        }).map(function (query) {
          return query.trim();
        });
      }

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      // PascalCase is being used as Breakpoints is used like an enum.
      // tslint:disable-next-line:variable-name
      var _Breakpoints = {
        XSmall: '(max-width: 599.98px)',
        Small: '(min-width: 600px) and (max-width: 959.98px)',
        Medium: '(min-width: 960px) and (max-width: 1279.98px)',
        Large: '(min-width: 1280px) and (max-width: 1919.98px)',
        XLarge: '(min-width: 1920px)',
        Handset: '(max-width: 599.98px) and (orientation: portrait), ' + '(max-width: 959.98px) and (orientation: landscape)',
        Tablet: '(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait), ' + '(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)',
        Web: '(min-width: 840px) and (orientation: portrait), ' + '(min-width: 1280px) and (orientation: landscape)',
        HandsetPortrait: '(max-width: 599.98px) and (orientation: portrait)',
        TabletPortrait: '(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait)',
        WebPortrait: '(min-width: 840px) and (orientation: portrait)',
        HandsetLandscape: '(max-width: 959.98px) and (orientation: landscape)',
        TabletLandscape: '(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)',
        WebLandscape: '(min-width: 1280px) and (orientation: landscape)'
      };

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/
    },

    /***/45129:
    /*!********************************************************************!*\
      !*** ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/overlay.js ***!
      \********************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"CdkScrollable": function CdkScrollable() {
          return (/* reexport safe */_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.CdkScrollable
          );
        },
        /* harmony export */"ScrollDispatcher": function ScrollDispatcher() {
          return (/* reexport safe */_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ScrollDispatcher
          );
        },
        /* harmony export */"ViewportRuler": function ViewportRuler() {
          return (/* reexport safe */_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ViewportRuler
          );
        },
        /* harmony export */"BlockScrollStrategy": function BlockScrollStrategy() {
          return (/* binding */_BlockScrollStrategy
          );
        },
        /* harmony export */"CdkConnectedOverlay": function CdkConnectedOverlay() {
          return (/* binding */_CdkConnectedOverlay
          );
        },
        /* harmony export */"CdkOverlayOrigin": function CdkOverlayOrigin() {
          return (/* binding */_CdkOverlayOrigin
          );
        },
        /* harmony export */"CloseScrollStrategy": function CloseScrollStrategy() {
          return (/* binding */_CloseScrollStrategy
          );
        },
        /* harmony export */"ConnectedOverlayPositionChange": function ConnectedOverlayPositionChange() {
          return (/* binding */_ConnectedOverlayPositionChange
          );
        },
        /* harmony export */"ConnectedPositionStrategy": function ConnectedPositionStrategy() {
          return (/* binding */_ConnectedPositionStrategy
          );
        },
        /* harmony export */"ConnectionPositionPair": function ConnectionPositionPair() {
          return (/* binding */_ConnectionPositionPair
          );
        },
        /* harmony export */"FlexibleConnectedPositionStrategy": function FlexibleConnectedPositionStrategy() {
          return (/* binding */_FlexibleConnectedPositionStrategy
          );
        },
        /* harmony export */"FullscreenOverlayContainer": function FullscreenOverlayContainer() {
          return (/* binding */_FullscreenOverlayContainer
          );
        },
        /* harmony export */"GlobalPositionStrategy": function GlobalPositionStrategy() {
          return (/* binding */_GlobalPositionStrategy
          );
        },
        /* harmony export */"NoopScrollStrategy": function NoopScrollStrategy() {
          return (/* binding */_NoopScrollStrategy
          );
        },
        /* harmony export */"Overlay": function Overlay() {
          return (/* binding */_Overlay
          );
        },
        /* harmony export */"OverlayConfig": function OverlayConfig() {
          return (/* binding */_OverlayConfig
          );
        },
        /* harmony export */"OverlayContainer": function OverlayContainer() {
          return (/* binding */_OverlayContainer
          );
        },
        /* harmony export */"OverlayKeyboardDispatcher": function OverlayKeyboardDispatcher() {
          return (/* binding */_OverlayKeyboardDispatcher
          );
        },
        /* harmony export */"OverlayModule": function OverlayModule() {
          return (/* binding */_OverlayModule
          );
        },
        /* harmony export */"OverlayOutsideClickDispatcher": function OverlayOutsideClickDispatcher() {
          return (/* binding */_OverlayOutsideClickDispatcher
          );
        },
        /* harmony export */"OverlayPositionBuilder": function OverlayPositionBuilder() {
          return (/* binding */_OverlayPositionBuilder
          );
        },
        /* harmony export */"OverlayRef": function OverlayRef() {
          return (/* binding */_OverlayRef
          );
        },
        /* harmony export */"RepositionScrollStrategy": function RepositionScrollStrategy() {
          return (/* binding */_RepositionScrollStrategy
          );
        },
        /* harmony export */"ScrollStrategyOptions": function ScrollStrategyOptions() {
          return (/* binding */_ScrollStrategyOptions
          );
        },
        /* harmony export */"ScrollingVisibility": function ScrollingVisibility() {
          return (/* binding */_ScrollingVisibility
          );
        },
        /* harmony export */"validateHorizontalPosition": function validateHorizontalPosition() {
          return (/* binding */_validateHorizontalPosition
          );
        },
        /* harmony export */"validateVerticalPosition": function validateVerticalPosition() {
          return (/* binding */_validateVerticalPosition
          );
        },
        /* harmony export */"ɵangular_material_src_cdk_overlay_overlay_a": function ɵangular_material_src_cdk_overlay_overlay_a() {
          return (/* binding */CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY
          );
        },
        /* harmony export */"ɵangular_material_src_cdk_overlay_overlay_b": function ɵangular_material_src_cdk_overlay_overlay_b() {
          return (/* binding */CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY
          );
        },
        /* harmony export */"ɵangular_material_src_cdk_overlay_overlay_c": function ɵangular_material_src_cdk_overlay_overlay_c() {
          return (/* binding */CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER
          );
        },
        /* harmony export */"ɵangular_material_src_cdk_overlay_overlay_d": function ɵangular_material_src_cdk_overlay_overlay_d() {
          return (/* binding */BaseOverlayDispatcher
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @angular/cdk/scrolling */42791);
      /* harmony import */
      var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @angular/core */2316);
      /* harmony import */
      var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/cdk/platform */36145);
      /* harmony import */
      var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__( /*! @angular/cdk/bidi */772);
      /* harmony import */
      var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @angular/common */54364);
      /* harmony import */
      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/cdk/coercion */20657);
      /* harmony import */
      var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__( /*! @angular/cdk/portal */40912);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! rxjs */79441);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! rxjs */94283);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! rxjs */89919);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! rxjs/operators */53466);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! rxjs/operators */22663);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__( /*! rxjs/operators */18511);
      /* harmony import */
      var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__( /*! @angular/cdk/keycodes */90084);

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      var scrollBehaviorSupported = (0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.supportsScrollBehavior)();
      /**
       * Strategy that will prevent the user from scrolling while the overlay is visible.
       */
      var _BlockScrollStrategy = /*#__PURE__*/function () {
        function _BlockScrollStrategy(_viewportRuler, document) {
          _classCallCheck(this, _BlockScrollStrategy);
          this._viewportRuler = _viewportRuler;
          this._previousHTMLStyles = {
            top: '',
            left: ''
          };
          this._isEnabled = false;
          this._document = document;
        }
        /** Attaches this scroll strategy to an overlay. */
        _createClass(_BlockScrollStrategy, [{
          key: "attach",
          value: function attach() {}
          /** Blocks page-level scroll while the attached overlay is open. */
        }, {
          key: "enable",
          value: function enable() {
            if (this._canBeEnabled()) {
              var root = this._document.documentElement;
              this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();
              // Cache the previous inline styles in case the user had set them.
              this._previousHTMLStyles.left = root.style.left || '';
              this._previousHTMLStyles.top = root.style.top || '';
              // Note: we're using the `html` node, instead of the `body`, because the `body` may
              // have the user agent margin, whereas the `html` is guaranteed not to have one.
              root.style.left = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(-this._previousScrollPosition.left);
              root.style.top = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(-this._previousScrollPosition.top);
              root.classList.add('cdk-global-scrollblock');
              this._isEnabled = true;
            }
          }
          /** Unblocks page-level scroll while the attached overlay is open. */
        }, {
          key: "disable",
          value: function disable() {
            if (this._isEnabled) {
              var html = this._document.documentElement;
              var body = this._document.body;
              var htmlStyle = html.style;
              var bodyStyle = body.style;
              var previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';
              var previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';
              this._isEnabled = false;
              htmlStyle.left = this._previousHTMLStyles.left;
              htmlStyle.top = this._previousHTMLStyles.top;
              html.classList.remove('cdk-global-scrollblock');
              // Disable user-defined smooth scrolling temporarily while we restore the scroll position.
              // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior
              // Note that we don't mutate the property if the browser doesn't support `scroll-behavior`,
              // because it can throw off feature detections in `supportsScrollBehavior` which
              // checks for `'scrollBehavior' in documentElement.style`.
              if (scrollBehaviorSupported) {
                htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';
              }
              window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);
              if (scrollBehaviorSupported) {
                htmlStyle.scrollBehavior = previousHtmlScrollBehavior;
                bodyStyle.scrollBehavior = previousBodyScrollBehavior;
              }
            }
          }
        }, {
          key: "_canBeEnabled",
          value: function _canBeEnabled() {
            // Since the scroll strategies can't be singletons, we have to use a global CSS class
            // (`cdk-global-scrollblock`) to make sure that we don't try to disable global
            // scrolling multiple times.
            var html = this._document.documentElement;
            if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {
              return false;
            }
            var body = this._document.body;
            var viewport = this._viewportRuler.getViewportSize();
            return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;
          }
        }]);
        return _BlockScrollStrategy;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.
       */
      function getMatScrollStrategyAlreadyAttachedError() {
        return Error("Scroll strategy has already been attached.");
      }

      /**
       * Strategy that will close the overlay as soon as the user starts scrolling.
       */
      var _CloseScrollStrategy = /*#__PURE__*/function () {
        function _CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {
          var _this11 = this;
          _classCallCheck(this, _CloseScrollStrategy);
          this._scrollDispatcher = _scrollDispatcher;
          this._ngZone = _ngZone;
          this._viewportRuler = _viewportRuler;
          this._config = _config;
          this._scrollSubscription = null;
          /** Detaches the overlay ref and disables the scroll strategy. */
          this._detach = function () {
            _this11.disable();
            if (_this11._overlayRef.hasAttached()) {
              _this11._ngZone.run(function () {
                return _this11._overlayRef.detach();
              });
            }
          };
        }
        /** Attaches this scroll strategy to an overlay. */
        _createClass(_CloseScrollStrategy, [{
          key: "attach",
          value: function attach(overlayRef) {
            if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw getMatScrollStrategyAlreadyAttachedError();
            }
            this._overlayRef = overlayRef;
          }
          /** Enables the closing of the attached overlay on scroll. */
        }, {
          key: "enable",
          value: function enable() {
            var _this12 = this;
            if (this._scrollSubscription) {
              return;
            }
            var stream = this._scrollDispatcher.scrolled(0);
            if (this._config && this._config.threshold && this._config.threshold > 1) {
              this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;
              this._scrollSubscription = stream.subscribe(function () {
                var scrollPosition = _this12._viewportRuler.getViewportScrollPosition().top;
                if (Math.abs(scrollPosition - _this12._initialScrollPosition) > _this12._config.threshold) {
                  _this12._detach();
                } else {
                  _this12._overlayRef.updatePosition();
                }
              });
            } else {
              this._scrollSubscription = stream.subscribe(this._detach);
            }
          }
          /** Disables the closing the attached overlay on scroll. */
        }, {
          key: "disable",
          value: function disable() {
            if (this._scrollSubscription) {
              this._scrollSubscription.unsubscribe();
              this._scrollSubscription = null;
            }
          }
        }, {
          key: "detach",
          value: function detach() {
            this.disable();
            this._overlayRef = null;
          }
        }]);
        return _CloseScrollStrategy;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Scroll strategy that doesn't do anything. */
      var _NoopScrollStrategy = /*#__PURE__*/function () {
        function _NoopScrollStrategy() {
          _classCallCheck(this, _NoopScrollStrategy);
        }
        _createClass(_NoopScrollStrategy, [{
          key: "enable",
          value: /** Does nothing, as this scroll strategy is a no-op. */
          function enable() {}
          /** Does nothing, as this scroll strategy is a no-op. */
        }, {
          key: "disable",
          value: function disable() {}
          /** Does nothing, as this scroll strategy is a no-op. */
        }, {
          key: "attach",
          value: function attach() {}
        }]);
        return _NoopScrollStrategy;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      // TODO(jelbourn): move this to live with the rest of the scrolling code
      // TODO(jelbourn): someday replace this with IntersectionObservers
      /**
       * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.
       * @param element Dimensions of the element (from getBoundingClientRect)
       * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)
       * @returns Whether the element is scrolled out of view
       * @docs-private
       */
      function isElementScrolledOutsideView(element, scrollContainers) {
        return scrollContainers.some(function (containerBounds) {
          var outsideAbove = element.bottom < containerBounds.top;
          var outsideBelow = element.top > containerBounds.bottom;
          var outsideLeft = element.right < containerBounds.left;
          var outsideRight = element.left > containerBounds.right;
          return outsideAbove || outsideBelow || outsideLeft || outsideRight;
        });
      }
      /**
       * Gets whether an element is clipped by any of its scrolling containers.
       * @param element Dimensions of the element (from getBoundingClientRect)
       * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)
       * @returns Whether the element is clipped
       * @docs-private
       */
      function isElementClippedByScrolling(element, scrollContainers) {
        return scrollContainers.some(function (scrollContainerRect) {
          var clippedAbove = element.top < scrollContainerRect.top;
          var clippedBelow = element.bottom > scrollContainerRect.bottom;
          var clippedLeft = element.left < scrollContainerRect.left;
          var clippedRight = element.right > scrollContainerRect.right;
          return clippedAbove || clippedBelow || clippedLeft || clippedRight;
        });
      }

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Strategy that will update the element position as the user is scrolling.
       */
      var _RepositionScrollStrategy = /*#__PURE__*/function () {
        function _RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {
          _classCallCheck(this, _RepositionScrollStrategy);
          this._scrollDispatcher = _scrollDispatcher;
          this._viewportRuler = _viewportRuler;
          this._ngZone = _ngZone;
          this._config = _config;
          this._scrollSubscription = null;
        }
        /** Attaches this scroll strategy to an overlay. */
        _createClass(_RepositionScrollStrategy, [{
          key: "attach",
          value: function attach(overlayRef) {
            if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw getMatScrollStrategyAlreadyAttachedError();
            }
            this._overlayRef = overlayRef;
          }
          /** Enables repositioning of the attached overlay on scroll. */
        }, {
          key: "enable",
          value: function enable() {
            var _this13 = this;
            if (!this._scrollSubscription) {
              var throttle = this._config ? this._config.scrollThrottle : 0;
              this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {
                _this13._overlayRef.updatePosition();
                // TODO(crisbeto): make `close` on by default once all components can handle it.
                if (_this13._config && _this13._config.autoClose) {
                  var overlayRect = _this13._overlayRef.overlayElement.getBoundingClientRect();
                  var _this13$_viewportRule = _this13._viewportRuler.getViewportSize(),
                    width = _this13$_viewportRule.width,
                    height = _this13$_viewportRule.height;
                  // TODO(crisbeto): include all ancestor scroll containers here once
                  // we have a way of exposing the trigger element to the scroll strategy.
                  var parentRects = [{
                    width: width,
                    height: height,
                    bottom: height,
                    right: width,
                    top: 0,
                    left: 0
                  }];
                  if (isElementScrolledOutsideView(overlayRect, parentRects)) {
                    _this13.disable();
                    _this13._ngZone.run(function () {
                      return _this13._overlayRef.detach();
                    });
                  }
                }
              });
            }
          }
          /** Disables repositioning of the attached overlay on scroll. */
        }, {
          key: "disable",
          value: function disable() {
            if (this._scrollSubscription) {
              this._scrollSubscription.unsubscribe();
              this._scrollSubscription = null;
            }
          }
        }, {
          key: "detach",
          value: function detach() {
            this.disable();
            this._overlayRef = null;
          }
        }]);
        return _RepositionScrollStrategy;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Options for how an overlay will handle scrolling.
       *
       * Users can provide a custom value for `ScrollStrategyOptions` to replace the default
       * behaviors. This class primarily acts as a factory for ScrollStrategy instances.
       */
      var _ScrollStrategyOptions = /*#__PURE__*/_createClass(function _ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {
        var _this14 = this;
        _classCallCheck(this, _ScrollStrategyOptions);
        this._scrollDispatcher = _scrollDispatcher;
        this._viewportRuler = _viewportRuler;
        this._ngZone = _ngZone;
        /** Do nothing on scroll. */
        this.noop = function () {
          return new _NoopScrollStrategy();
        };
        /**
         * Close the overlay as soon as the user scrolls.
         * @param config Configuration to be used inside the scroll strategy.
         */
        this.close = function (config) {
          return new _CloseScrollStrategy(_this14._scrollDispatcher, _this14._ngZone, _this14._viewportRuler, config);
        };
        /** Block scrolling. */
        this.block = function () {
          return new _BlockScrollStrategy(_this14._viewportRuler, _this14._document);
        };
        /**
         * Update the overlay's position on scroll.
         * @param config Configuration to be used inside the scroll strategy.
         * Allows debouncing the reposition calls.
         */
        this.reposition = function (config) {
          return new _RepositionScrollStrategy(_this14._scrollDispatcher, _this14._viewportRuler, _this14._ngZone, config);
        };
        this._document = document;
      });
      _ScrollStrategyOptions.ɵfac = function ScrollStrategyOptions_Factory(t) {
        return new (t || _ScrollStrategyOptions)(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ScrollDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ViewportRuler), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_3__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT));
      };
      _ScrollStrategyOptions.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"]({
        factory: function ScrollStrategyOptions_Factory() {
          return new _ScrollStrategyOptions(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ScrollDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ViewportRuler), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_3__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT));
        },
        token: _ScrollStrategyOptions,
        providedIn: "root"
      });
      _ScrollStrategyOptions.ctorParameters = function () {
        return [{
          type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ScrollDispatcher
        }, {
          type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ViewportRuler
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.NgZone
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
          }]
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](_ScrollStrategyOptions, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ScrollDispatcher
          }, {
            type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ViewportRuler
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.NgZone
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
            }]
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Initial configuration used when creating an overlay. */
      var _OverlayConfig = /*#__PURE__*/_createClass(function _OverlayConfig(config) {
        _classCallCheck(this, _OverlayConfig);
        /** Strategy to be used when handling scroll events while the overlay is open. */
        this.scrollStrategy = new _NoopScrollStrategy();
        /** Custom class to add to the overlay pane. */
        this.panelClass = '';
        /** Whether the overlay has a backdrop. */
        this.hasBackdrop = false;
        /** Custom class to add to the backdrop */
        this.backdropClass = 'cdk-overlay-dark-backdrop';
        /**
         * Whether the overlay should be disposed of when the user goes backwards/forwards in history.
         * Note that this usually doesn't include clicking on links (unless the user is using
         * the `HashLocationStrategy`).
         */
        this.disposeOnNavigation = false;
        if (config) {
          // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,
          // loses the array generic type in the `for of`. But we *also* have to use `Array` because
          // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`
          var configKeys = Object.keys(config);
          for (var _i = 0, _configKeys = configKeys; _i < _configKeys.length; _i++) {
            var key = _configKeys[_i];
            if (config[key] !== undefined) {
              // TypeScript, as of version 3.5, sees the left-hand-side of this expression
              // as "I don't know *which* key this is, so the only valid value is the intersection
              // of all the posible values." In this case, that happens to be `undefined`. TypeScript
              // is not smart enough to see that the right-hand-side is actually an access of the same
              // exact type with the same exact key, meaning that the value type must be identical.
              // So we use `any` to work around this.
              this[key] = config[key];
            }
          }
        }
      });
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** The points of the origin element and the overlay element to connect. */
      var _ConnectionPositionPair = /*#__PURE__*/_createClass(function _ConnectionPositionPair(origin, overlay, /** Offset along the X axis. */
      offsetX, /** Offset along the Y axis. */
      offsetY, /** Class(es) to be applied to the panel while this position is active. */
      panelClass) {
        _classCallCheck(this, _ConnectionPositionPair);
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.panelClass = panelClass;
        this.originX = origin.originX;
        this.originY = origin.originY;
        this.overlayX = overlay.overlayX;
        this.overlayY = overlay.overlayY;
      });
      /**
       * Set of properties regarding the position of the origin and overlay relative to the viewport
       * with respect to the containing Scrollable elements.
       *
       * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the
       * bounds of any one of the strategy's Scrollable's bounding client rectangle.
       *
       * The overlay and origin are outside view if there is no overlap between their bounding client
       * rectangle and any one of the strategy's Scrollable's bounding client rectangle.
       *
       *       -----------                    -----------
       *       | outside |                    | clipped |
       *       |  view   |              --------------------------
       *       |         |              |     |         |        |
       *       ----------               |     -----------        |
       *  --------------------------    |                        |
       *  |                        |    |      Scrollable        |
       *  |                        |    |                        |
       *  |                        |     --------------------------
       *  |      Scrollable        |
       *  |                        |
       *  --------------------------
       *
       *  @docs-private
       */
      var _ScrollingVisibility = /*#__PURE__*/_createClass(function _ScrollingVisibility() {
        _classCallCheck(this, _ScrollingVisibility);
      });
      /** The change event emitted by the strategy when a fallback position is used. */
      var _ConnectedOverlayPositionChange = /*#__PURE__*/_createClass(function _ConnectedOverlayPositionChange( /** The position used as a result of this change. */
      connectionPair, /** @docs-private */
      scrollableViewProperties) {
        _classCallCheck(this, _ConnectedOverlayPositionChange);
        this.connectionPair = connectionPair;
        this.scrollableViewProperties = scrollableViewProperties;
      });
      _ConnectedOverlayPositionChange.ctorParameters = function () {
        return [{
          type: _ConnectionPositionPair
        }, {
          type: _ScrollingVisibility,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Optional
          }]
        }];
      };
      /**
       * Validates whether a vertical position property matches the expected values.
       * @param property Name of the property being validated.
       * @param value Value of the property being validated.
       * @docs-private
       */
      function _validateVerticalPosition(property, value) {
        if (value !== 'top' && value !== 'bottom' && value !== 'center') {
          throw Error("ConnectedPosition: Invalid ".concat(property, " \"").concat(value, "\". ") + "Expected \"top\", \"bottom\" or \"center\".");
        }
      }
      /**
       * Validates whether a horizontal position property matches the expected values.
       * @param property Name of the property being validated.
       * @param value Value of the property being validated.
       * @docs-private
       */
      function _validateHorizontalPosition(property, value) {
        if (value !== 'start' && value !== 'end' && value !== 'center') {
          throw Error("ConnectedPosition: Invalid ".concat(property, " \"").concat(value, "\". ") + "Expected \"start\", \"end\" or \"center\".");
        }
      }

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Service for dispatching events that land on the body to appropriate overlay ref,
       * if any. It maintains a list of attached overlays to determine best suited overlay based
       * on event target and order of overlay opens.
       */
      var BaseOverlayDispatcher = /*#__PURE__*/function () {
        function BaseOverlayDispatcher(document) {
          _classCallCheck(this, BaseOverlayDispatcher);
          /** Currently attached overlays in the order they were attached. */
          this._attachedOverlays = [];
          this._document = document;
        }
        _createClass(BaseOverlayDispatcher, [{
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this.detach();
          }
          /** Add a new overlay to the list of attached overlay refs. */
        }, {
          key: "add",
          value: function add(overlayRef) {
            // Ensure that we don't get the same overlay multiple times.
            this.remove(overlayRef);
            this._attachedOverlays.push(overlayRef);
          }
          /** Remove an overlay from the list of attached overlay refs. */
        }, {
          key: "remove",
          value: function remove(overlayRef) {
            var index = this._attachedOverlays.indexOf(overlayRef);
            if (index > -1) {
              this._attachedOverlays.splice(index, 1);
            }
            // Remove the global listener once there are no more overlays.
            if (this._attachedOverlays.length === 0) {
              this.detach();
            }
          }
        }]);
        return BaseOverlayDispatcher;
      }();
      BaseOverlayDispatcher.ɵfac = function BaseOverlayDispatcher_Factory(t) {
        return new (t || BaseOverlayDispatcher)(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT));
      };
      BaseOverlayDispatcher.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"]({
        factory: function BaseOverlayDispatcher_Factory() {
          return new BaseOverlayDispatcher(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT));
        },
        token: BaseOverlayDispatcher,
        providedIn: "root"
      });
      BaseOverlayDispatcher.ctorParameters = function () {
        return [{
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
          }]
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](BaseOverlayDispatcher, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
            }]
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Service for dispatching keyboard events that land on the body to appropriate overlay ref,
       * if any. It maintains a list of attached overlays to determine best suited overlay based
       * on event target and order of overlay opens.
       */
      var _OverlayKeyboardDispatcher = /*#__PURE__*/function (_BaseOverlayDispatche) {
        _inherits(_OverlayKeyboardDispatcher, _BaseOverlayDispatche);
        var _super2 = _createSuper(_OverlayKeyboardDispatcher);
        function _OverlayKeyboardDispatcher(document) {
          var _this15;
          _classCallCheck(this, _OverlayKeyboardDispatcher);
          _this15 = _super2.call(this, document);
          /** Keyboard event listener that will be attached to the body. */
          _this15._keydownListener = function (event) {
            var overlays = _this15._attachedOverlays;
            for (var i = overlays.length - 1; i > -1; i--) {
              // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.
              // We want to target the most recent overlay, rather than trying to match where the event came
              // from, because some components might open an overlay, but keep focus on a trigger element
              // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,
              // because we don't want overlays that don't handle keyboard events to block the ones below
              // them that do.
              if (overlays[i]._keydownEvents.observers.length > 0) {
                overlays[i]._keydownEvents.next(event);
                break;
              }
            }
          };
          return _this15;
        }
        /** Add a new overlay to the list of attached overlay refs. */
        _createClass(_OverlayKeyboardDispatcher, [{
          key: "add",
          value: function add(overlayRef) {
            _get(_getPrototypeOf(_OverlayKeyboardDispatcher.prototype), "add", this).call(this, overlayRef);
            // Lazily start dispatcher once first overlay is added
            if (!this._isAttached) {
              this._document.body.addEventListener('keydown', this._keydownListener);
              this._isAttached = true;
            }
          }
          /** Detaches the global keyboard event listener. */
        }, {
          key: "detach",
          value: function detach() {
            if (this._isAttached) {
              this._document.body.removeEventListener('keydown', this._keydownListener);
              this._isAttached = false;
            }
          }
        }]);
        return _OverlayKeyboardDispatcher;
      }(BaseOverlayDispatcher);
      _OverlayKeyboardDispatcher.ɵfac = function OverlayKeyboardDispatcher_Factory(t) {
        return new (t || _OverlayKeyboardDispatcher)(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT));
      };
      _OverlayKeyboardDispatcher.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"]({
        factory: function OverlayKeyboardDispatcher_Factory() {
          return new _OverlayKeyboardDispatcher(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT));
        },
        token: _OverlayKeyboardDispatcher,
        providedIn: "root"
      });
      _OverlayKeyboardDispatcher.ctorParameters = function () {
        return [{
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
          }]
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](_OverlayKeyboardDispatcher, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
            }]
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Service for dispatching mouse click events that land on the body to appropriate overlay ref,
       * if any. It maintains a list of attached overlays to determine best suited overlay based
       * on event target and order of overlay opens.
       */
      var _OverlayOutsideClickDispatcher = /*#__PURE__*/function (_BaseOverlayDispatche2) {
        _inherits(_OverlayOutsideClickDispatcher, _BaseOverlayDispatche2);
        var _super3 = _createSuper(_OverlayOutsideClickDispatcher);
        function _OverlayOutsideClickDispatcher(document, _platform) {
          var _this16;
          _classCallCheck(this, _OverlayOutsideClickDispatcher);
          _this16 = _super3.call(this, document);
          _this16._platform = _platform;
          _this16._cursorStyleIsSet = false;
          /** Store pointerdown event target to track origin of click. */
          _this16._pointerDownListener = function (event) {
            _this16._pointerDownEventTarget = (0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__._getEventTarget)(event);
          };
          /** Click event listener that will be attached to the body propagate phase. */
          _this16._clickListener = function (event) {
            var target = (0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__._getEventTarget)(event);
            // In case of a click event, we want to check the origin of the click
            // (e.g. in case where a user starts a click inside the overlay and
            // releases the click outside of it).
            // This is done by using the event target of the preceding pointerdown event.
            // Every click event caused by a pointer device has a preceding pointerdown
            // event, unless the click was programmatically triggered (e.g. in a unit test).
            var origin = event.type === 'click' && _this16._pointerDownEventTarget ? _this16._pointerDownEventTarget : target;
            // Reset the stored pointerdown event target, to avoid having it interfere
            // in subsequent events.
            _this16._pointerDownEventTarget = null;
            // We copy the array because the original may be modified asynchronously if the
            // outsidePointerEvents listener decides to detach overlays resulting in index errors inside
            // the for loop.
            var overlays = _this16._attachedOverlays.slice();
            // Dispatch the mouse event to the top overlay which has subscribers to its mouse events.
            // We want to target all overlays for which the click could be considered as outside click.
            // As soon as we reach an overlay for which the click is not outside click we break off
            // the loop.
            for (var i = overlays.length - 1; i > -1; i--) {
              var overlayRef = overlays[i];
              if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {
                continue;
              }
              // If it's a click inside the overlay, just break - we should do nothing
              // If it's an outside click (both origin and target of the click) dispatch the mouse event,
              // and proceed with the next overlay
              if (overlayRef.overlayElement.contains(target) || overlayRef.overlayElement.contains(origin)) {
                break;
              }
              overlayRef._outsidePointerEvents.next(event);
            }
          };
          return _this16;
        }
        /** Add a new overlay to the list of attached overlay refs. */
        _createClass(_OverlayOutsideClickDispatcher, [{
          key: "add",
          value: function add(overlayRef) {
            _get(_getPrototypeOf(_OverlayOutsideClickDispatcher.prototype), "add", this).call(this, overlayRef);
            // Safari on iOS does not generate click events for non-interactive
            // elements. However, we want to receive a click for any element outside
            // the overlay. We can force a "clickable" state by setting
            // `cursor: pointer` on the document body. See:
            // https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event#Safari_Mobile
            // https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html
            if (!this._isAttached) {
              var body = this._document.body;
              body.addEventListener('pointerdown', this._pointerDownListener, true);
              body.addEventListener('click', this._clickListener, true);
              body.addEventListener('auxclick', this._clickListener, true);
              body.addEventListener('contextmenu', this._clickListener, true);
              // click event is not fired on iOS. To make element "clickable" we are
              // setting the cursor to pointer
              if (this._platform.IOS && !this._cursorStyleIsSet) {
                this._cursorOriginalValue = body.style.cursor;
                body.style.cursor = 'pointer';
                this._cursorStyleIsSet = true;
              }
              this._isAttached = true;
            }
          }
          /** Detaches the global keyboard event listener. */
        }, {
          key: "detach",
          value: function detach() {
            if (this._isAttached) {
              var body = this._document.body;
              body.removeEventListener('pointerdown', this._pointerDownListener, true);
              body.removeEventListener('click', this._clickListener, true);
              body.removeEventListener('auxclick', this._clickListener, true);
              body.removeEventListener('contextmenu', this._clickListener, true);
              if (this._platform.IOS && this._cursorStyleIsSet) {
                body.style.cursor = this._cursorOriginalValue;
                this._cursorStyleIsSet = false;
              }
              this._isAttached = false;
            }
          }
        }]);
        return _OverlayOutsideClickDispatcher;
      }(BaseOverlayDispatcher);
      _OverlayOutsideClickDispatcher.ɵfac = function OverlayOutsideClickDispatcher_Factory(t) {
        return new (t || _OverlayOutsideClickDispatcher)(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform));
      };
      _OverlayOutsideClickDispatcher.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"]({
        factory: function OverlayOutsideClickDispatcher_Factory() {
          return new _OverlayOutsideClickDispatcher(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform));
        },
        token: _OverlayOutsideClickDispatcher,
        providedIn: "root"
      });
      _OverlayOutsideClickDispatcher.ctorParameters = function () {
        return [{
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
          }]
        }, {
          type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](_OverlayOutsideClickDispatcher, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
            }]
          }, {
            type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Container inside which all overlays will render. */
      var _OverlayContainer = /*#__PURE__*/function () {
        function _OverlayContainer(document, _platform) {
          _classCallCheck(this, _OverlayContainer);
          this._platform = _platform;
          this._document = document;
        }
        _createClass(_OverlayContainer, [{
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            var container = this._containerElement;
            if (container && container.parentNode) {
              container.parentNode.removeChild(container);
            }
          }
          /**
           * This method returns the overlay container element. It will lazily
           * create the element the first time it is called to facilitate using
           * the container in non-browser environments.
           * @returns the container element
           */
        }, {
          key: "getContainerElement",
          value: function getContainerElement() {
            if (!this._containerElement) {
              this._createContainer();
            }
            return this._containerElement;
          }
          /**
           * Create the overlay container element, which is simply a div
           * with the 'cdk-overlay-container' class on the document body.
           */
        }, {
          key: "_createContainer",
          value: function _createContainer() {
            var containerClass = 'cdk-overlay-container';
            // TODO(crisbeto): remove the testing check once we have an overlay testing
            // module or Angular starts tearing down the testing `NgModule`. See:
            // https://github.com/angular/angular/issues/18831
            if (this._platform.isBrowser || (0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__._isTestEnvironment)()) {
              var oppositePlatformContainers = this._document.querySelectorAll(".".concat(containerClass, "[platform=\"server\"], ") + ".".concat(containerClass, "[platform=\"test\"]"));
              // Remove any old containers from the opposite platform.
              // This can happen when transitioning from the server to the client.
              for (var i = 0; i < oppositePlatformContainers.length; i++) {
                oppositePlatformContainers[i].parentNode.removeChild(oppositePlatformContainers[i]);
              }
            }
            var container = this._document.createElement('div');
            container.classList.add(containerClass);
            // A long time ago we kept adding new overlay containers whenever a new app was instantiated,
            // but at some point we added logic which clears the duplicate ones in order to avoid leaks.
            // The new logic was a little too aggressive since it was breaking some legitimate use cases.
            // To mitigate the problem we made it so that only containers from a different platform are
            // cleared, but the side-effect was that people started depending on the overly-aggressive
            // logic to clean up their tests for them. Until we can introduce an overlay-specific testing
            // module which does the cleanup, we try to detect that we're in a test environment and we
            // always clear the container. See #17006.
            // TODO(crisbeto): remove the test environment check once we have an overlay testing module.
            if ((0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__._isTestEnvironment)()) {
              container.setAttribute('platform', 'test');
            } else if (!this._platform.isBrowser) {
              container.setAttribute('platform', 'server');
            }
            this._document.body.appendChild(container);
            this._containerElement = container;
          }
        }]);
        return _OverlayContainer;
      }();
      _OverlayContainer.ɵfac = function OverlayContainer_Factory(t) {
        return new (t || _OverlayContainer)(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform));
      };
      _OverlayContainer.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"]({
        factory: function OverlayContainer_Factory() {
          return new _OverlayContainer(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform));
        },
        token: _OverlayContainer,
        providedIn: "root"
      });
      _OverlayContainer.ctorParameters = function () {
        return [{
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
          }]
        }, {
          type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](_OverlayContainer, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
            }]
          }, {
            type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Reference to an overlay that has been created with the Overlay service.
       * Used to manipulate or dispose of said overlay.
       */
      var _OverlayRef = /*#__PURE__*/function () {
        function _OverlayRef(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location, _outsideClickDispatcher) {
          var _this17 = this;
          _classCallCheck(this, _OverlayRef);
          this._portalOutlet = _portalOutlet;
          this._host = _host;
          this._pane = _pane;
          this._config = _config;
          this._ngZone = _ngZone;
          this._keyboardDispatcher = _keyboardDispatcher;
          this._document = _document;
          this._location = _location;
          this._outsideClickDispatcher = _outsideClickDispatcher;
          this._backdropElement = null;
          this._backdropClick = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject();
          this._attachments = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject();
          this._detachments = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject();
          this._locationChanges = rxjs__WEBPACK_IMPORTED_MODULE_6__.Subscription.EMPTY;
          this._backdropClickHandler = function (event) {
            return _this17._backdropClick.next(event);
          };
          /** Stream of keydown events dispatched to this overlay. */
          this._keydownEvents = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject();
          /** Stream of mouse outside events dispatched to this overlay. */
          this._outsidePointerEvents = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject();
          if (_config.scrollStrategy) {
            this._scrollStrategy = _config.scrollStrategy;
            this._scrollStrategy.attach(this);
          }
          this._positionStrategy = _config.positionStrategy;
        }
        /** The overlay's HTML element */
        _createClass(_OverlayRef, [{
          key: "overlayElement",
          get: function get() {
            return this._pane;
          }
          /** The overlay's backdrop HTML element. */
        }, {
          key: "backdropElement",
          get: function get() {
            return this._backdropElement;
          }
          /**
           * Wrapper around the panel element. Can be used for advanced
           * positioning where a wrapper with specific styling is
           * required around the overlay pane.
           */
        }, {
          key: "hostElement",
          get: function get() {
            return this._host;
          }
          /**
           * Attaches content, given via a Portal, to the overlay.
           * If the overlay is configured to have a backdrop, it will be created.
           *
           * @param portal Portal instance to which to attach the overlay.
           * @returns The portal attachment result.
           */
        }, {
          key: "attach",
          value: function attach(portal) {
            var _this18 = this;
            var attachResult = this._portalOutlet.attach(portal);
            // Update the pane element with the given configuration.
            if (!this._host.parentElement && this._previousHostParent) {
              this._previousHostParent.appendChild(this._host);
            }
            if (this._positionStrategy) {
              this._positionStrategy.attach(this);
            }
            this._updateStackingOrder();
            this._updateElementSize();
            this._updateElementDirection();
            if (this._scrollStrategy) {
              this._scrollStrategy.enable();
            }
            // Update the position once the zone is stable so that the overlay will be fully rendered
            // before attempting to position it, as the position may depend on the size of the rendered
            // content.
            this._ngZone.onStable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.take)(1)).subscribe(function () {
              // The overlay could've been detached before the zone has stabilized.
              if (_this18.hasAttached()) {
                _this18.updatePosition();
              }
            });
            // Enable pointer events for the overlay pane element.
            this._togglePointerEvents(true);
            if (this._config.hasBackdrop) {
              this._attachBackdrop();
            }
            if (this._config.panelClass) {
              this._toggleClasses(this._pane, this._config.panelClass, true);
            }
            // Only emit the `attachments` event once all other setup is done.
            this._attachments.next();
            // Track this overlay by the keyboard dispatcher
            this._keyboardDispatcher.add(this);
            if (this._config.disposeOnNavigation) {
              this._locationChanges = this._location.subscribe(function () {
                return _this18.dispose();
              });
            }
            this._outsideClickDispatcher.add(this);
            return attachResult;
          }
          /**
           * Detaches an overlay from a portal.
           * @returns The portal detachment result.
           */
        }, {
          key: "detach",
          value: function detach() {
            if (!this.hasAttached()) {
              return;
            }
            this.detachBackdrop();
            // When the overlay is detached, the pane element should disable pointer events.
            // This is necessary because otherwise the pane element will cover the page and disable
            // pointer events therefore. Depends on the position strategy and the applied pane boundaries.
            this._togglePointerEvents(false);
            if (this._positionStrategy && this._positionStrategy.detach) {
              this._positionStrategy.detach();
            }
            if (this._scrollStrategy) {
              this._scrollStrategy.disable();
            }
            var detachmentResult = this._portalOutlet.detach();
            // Only emit after everything is detached.
            this._detachments.next();
            // Remove this overlay from keyboard dispatcher tracking.
            this._keyboardDispatcher.remove(this);
            // Keeping the host element in the DOM can cause scroll jank, because it still gets
            // rendered, even though it's transparent and unclickable which is why we remove it.
            this._detachContentWhenStable();
            this._locationChanges.unsubscribe();
            this._outsideClickDispatcher.remove(this);
            return detachmentResult;
          }
          /** Cleans up the overlay from the DOM. */
        }, {
          key: "dispose",
          value: function dispose() {
            var isAttached = this.hasAttached();
            if (this._positionStrategy) {
              this._positionStrategy.dispose();
            }
            this._disposeScrollStrategy();
            this._disposeBackdrop(this._backdropElement);
            this._locationChanges.unsubscribe();
            this._keyboardDispatcher.remove(this);
            this._portalOutlet.dispose();
            this._attachments.complete();
            this._backdropClick.complete();
            this._keydownEvents.complete();
            this._outsidePointerEvents.complete();
            this._outsideClickDispatcher.remove(this);
            if (this._host && this._host.parentNode) {
              this._host.parentNode.removeChild(this._host);
              this._host = null;
            }
            this._previousHostParent = this._pane = null;
            if (isAttached) {
              this._detachments.next();
            }
            this._detachments.complete();
          }
          /** Whether the overlay has attached content. */
        }, {
          key: "hasAttached",
          value: function hasAttached() {
            return this._portalOutlet.hasAttached();
          }
          /** Gets an observable that emits when the backdrop has been clicked. */
        }, {
          key: "backdropClick",
          value: function backdropClick() {
            return this._backdropClick;
          }
          /** Gets an observable that emits when the overlay has been attached. */
        }, {
          key: "attachments",
          value: function attachments() {
            return this._attachments;
          }
          /** Gets an observable that emits when the overlay has been detached. */
        }, {
          key: "detachments",
          value: function detachments() {
            return this._detachments;
          }
          /** Gets an observable of keydown events targeted to this overlay. */
        }, {
          key: "keydownEvents",
          value: function keydownEvents() {
            return this._keydownEvents;
          }
          /** Gets an observable of pointer events targeted outside this overlay. */
        }, {
          key: "outsidePointerEvents",
          value: function outsidePointerEvents() {
            return this._outsidePointerEvents;
          }
          /** Gets the current overlay configuration, which is immutable. */
        }, {
          key: "getConfig",
          value: function getConfig() {
            return this._config;
          }
          /** Updates the position of the overlay based on the position strategy. */
        }, {
          key: "updatePosition",
          value: function updatePosition() {
            if (this._positionStrategy) {
              this._positionStrategy.apply();
            }
          }
          /** Switches to a new position strategy and updates the overlay position. */
        }, {
          key: "updatePositionStrategy",
          value: function updatePositionStrategy(strategy) {
            if (strategy === this._positionStrategy) {
              return;
            }
            if (this._positionStrategy) {
              this._positionStrategy.dispose();
            }
            this._positionStrategy = strategy;
            if (this.hasAttached()) {
              strategy.attach(this);
              this.updatePosition();
            }
          }
          /** Update the size properties of the overlay. */
        }, {
          key: "updateSize",
          value: function updateSize(sizeConfig) {
            this._config = Object.assign(Object.assign({}, this._config), sizeConfig);
            this._updateElementSize();
          }
          /** Sets the LTR/RTL direction for the overlay. */
        }, {
          key: "setDirection",
          value: function setDirection(dir) {
            this._config = Object.assign(Object.assign({}, this._config), {
              direction: dir
            });
            this._updateElementDirection();
          }
          /** Add a CSS class or an array of classes to the overlay pane. */
        }, {
          key: "addPanelClass",
          value: function addPanelClass(classes) {
            if (this._pane) {
              this._toggleClasses(this._pane, classes, true);
            }
          }
          /** Remove a CSS class or an array of classes from the overlay pane. */
        }, {
          key: "removePanelClass",
          value: function removePanelClass(classes) {
            if (this._pane) {
              this._toggleClasses(this._pane, classes, false);
            }
          }
          /**
           * Returns the layout direction of the overlay panel.
           */
        }, {
          key: "getDirection",
          value: function getDirection() {
            var direction = this._config.direction;
            if (!direction) {
              return 'ltr';
            }
            return typeof direction === 'string' ? direction : direction.value;
          }
          /** Switches to a new scroll strategy. */
        }, {
          key: "updateScrollStrategy",
          value: function updateScrollStrategy(strategy) {
            if (strategy === this._scrollStrategy) {
              return;
            }
            this._disposeScrollStrategy();
            this._scrollStrategy = strategy;
            if (this.hasAttached()) {
              strategy.attach(this);
              strategy.enable();
            }
          }
          /** Updates the text direction of the overlay panel. */
        }, {
          key: "_updateElementDirection",
          value: function _updateElementDirection() {
            this._host.setAttribute('dir', this.getDirection());
          }
          /** Updates the size of the overlay element based on the overlay config. */
        }, {
          key: "_updateElementSize",
          value: function _updateElementSize() {
            if (!this._pane) {
              return;
            }
            var style = this._pane.style;
            style.width = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(this._config.width);
            style.height = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(this._config.height);
            style.minWidth = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(this._config.minWidth);
            style.minHeight = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(this._config.minHeight);
            style.maxWidth = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(this._config.maxWidth);
            style.maxHeight = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(this._config.maxHeight);
          }
          /** Toggles the pointer events for the overlay pane element. */
        }, {
          key: "_togglePointerEvents",
          value: function _togglePointerEvents(enablePointer) {
            this._pane.style.pointerEvents = enablePointer ? '' : 'none';
          }
          /** Attaches a backdrop for this overlay. */
        }, {
          key: "_attachBackdrop",
          value: function _attachBackdrop() {
            var _this19 = this;
            var showingClass = 'cdk-overlay-backdrop-showing';
            this._backdropElement = this._document.createElement('div');
            this._backdropElement.classList.add('cdk-overlay-backdrop');
            if (this._config.backdropClass) {
              this._toggleClasses(this._backdropElement, this._config.backdropClass, true);
            }
            // Insert the backdrop before the pane in the DOM order,
            // in order to handle stacked overlays properly.
            this._host.parentElement.insertBefore(this._backdropElement, this._host);
            // Forward backdrop clicks such that the consumer of the overlay can perform whatever
            // action desired when such a click occurs (usually closing the overlay).
            this._backdropElement.addEventListener('click', this._backdropClickHandler);
            // Add class to fade-in the backdrop after one frame.
            if (typeof requestAnimationFrame !== 'undefined') {
              this._ngZone.runOutsideAngular(function () {
                requestAnimationFrame(function () {
                  if (_this19._backdropElement) {
                    _this19._backdropElement.classList.add(showingClass);
                  }
                });
              });
            } else {
              this._backdropElement.classList.add(showingClass);
            }
          }
          /**
           * Updates the stacking order of the element, moving it to the top if necessary.
           * This is required in cases where one overlay was detached, while another one,
           * that should be behind it, was destroyed. The next time both of them are opened,
           * the stacking will be wrong, because the detached element's pane will still be
           * in its original DOM position.
           */
        }, {
          key: "_updateStackingOrder",
          value: function _updateStackingOrder() {
            if (this._host.nextSibling) {
              this._host.parentNode.appendChild(this._host);
            }
          }
          /** Detaches the backdrop (if any) associated with the overlay. */
        }, {
          key: "detachBackdrop",
          value: function detachBackdrop() {
            var _this20 = this;
            var backdropToDetach = this._backdropElement;
            if (!backdropToDetach) {
              return;
            }
            var timeoutId;
            var finishDetach = function finishDetach() {
              // It may not be attached to anything in certain cases (e.g. unit tests).
              if (backdropToDetach) {
                backdropToDetach.removeEventListener('click', _this20._backdropClickHandler);
                backdropToDetach.removeEventListener('transitionend', finishDetach);
                _this20._disposeBackdrop(backdropToDetach);
              }
              if (_this20._config.backdropClass) {
                _this20._toggleClasses(backdropToDetach, _this20._config.backdropClass, false);
              }
              clearTimeout(timeoutId);
            };
            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');
            this._ngZone.runOutsideAngular(function () {
              backdropToDetach.addEventListener('transitionend', finishDetach);
            });
            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.
            // In this case we make it unclickable and we try to remove it after a delay.
            backdropToDetach.style.pointerEvents = 'none';
            // Run this outside the Angular zone because there's nothing that Angular cares about.
            // If it were to run inside the Angular zone, every test that used Overlay would have to be
            // either async or fakeAsync.
            timeoutId = this._ngZone.runOutsideAngular(function () {
              return setTimeout(finishDetach, 500);
            });
          }
          /** Toggles a single CSS class or an array of classes on an element. */
        }, {
          key: "_toggleClasses",
          value: function _toggleClasses(element, cssClasses, isAdd) {
            var classList = element.classList;
            (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceArray)(cssClasses).forEach(function (cssClass) {
              // We can't do a spread here, because IE doesn't support setting multiple classes.
              // Also trying to add an empty string to a DOMTokenList will throw.
              if (cssClass) {
                isAdd ? classList.add(cssClass) : classList.remove(cssClass);
              }
            });
          }
          /** Detaches the overlay content next time the zone stabilizes. */
        }, {
          key: "_detachContentWhenStable",
          value: function _detachContentWhenStable() {
            var _this21 = this;
            // Normally we wouldn't have to explicitly run this outside the `NgZone`, however
            // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will
            // be patched to run inside the zone, which will throw us into an infinite loop.
            this._ngZone.runOutsideAngular(function () {
              // We can't remove the host here immediately, because the overlay pane's content
              // might still be animating. This stream helps us avoid interrupting the animation
              // by waiting for the pane to become empty.
              var subscription = _this21._ngZone.onStable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.takeUntil)((0, rxjs__WEBPACK_IMPORTED_MODULE_9__.merge)(_this21._attachments, _this21._detachments))).subscribe(function () {
                // Needs a couple of checks for the pane and host, because
                // they may have been removed by the time the zone stabilizes.
                if (!_this21._pane || !_this21._host || _this21._pane.children.length === 0) {
                  if (_this21._pane && _this21._config.panelClass) {
                    _this21._toggleClasses(_this21._pane, _this21._config.panelClass, false);
                  }
                  if (_this21._host && _this21._host.parentElement) {
                    _this21._previousHostParent = _this21._host.parentElement;
                    _this21._previousHostParent.removeChild(_this21._host);
                  }
                  subscription.unsubscribe();
                }
              });
            });
          }
          /** Disposes of a scroll strategy. */
        }, {
          key: "_disposeScrollStrategy",
          value: function _disposeScrollStrategy() {
            var scrollStrategy = this._scrollStrategy;
            if (scrollStrategy) {
              scrollStrategy.disable();
              if (scrollStrategy.detach) {
                scrollStrategy.detach();
              }
            }
          }
          /** Removes a backdrop element from the DOM. */
        }, {
          key: "_disposeBackdrop",
          value: function _disposeBackdrop(backdrop) {
            if (backdrop) {
              if (backdrop.parentNode) {
                backdrop.parentNode.removeChild(backdrop);
              }
              // It is possible that a new portal has been attached to this overlay since we started
              // removing the backdrop. If that is the case, only clear the backdrop reference if it
              // is still the same instance that we started to remove.
              if (this._backdropElement === backdrop) {
                this._backdropElement = null;
              }
            }
          }
        }]);
        return _OverlayRef;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      // TODO: refactor clipping detection into a separate thing (part of scrolling module)
      // TODO: doesn't handle both flexible width and height when it has to scroll along both axis.
      /** Class to be added to the overlay bounding box. */
      var boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';
      /** Regex used to split a string on its CSS units. */
      var cssUnitPattern = /([A-Za-z%]+)$/;
      /**
       * A strategy for positioning overlays. Using this strategy, an overlay is given an
       * implicit position relative some origin element. The relative position is defined in terms of
       * a point on the origin element that is connected to a point on the overlay element. For example,
       * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
       * of the overlay.
       */
      var _FlexibleConnectedPositionStrategy = /*#__PURE__*/function () {
        function _FlexibleConnectedPositionStrategy(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {
          _classCallCheck(this, _FlexibleConnectedPositionStrategy);
          this._viewportRuler = _viewportRuler;
          this._document = _document;
          this._platform = _platform;
          this._overlayContainer = _overlayContainer;
          /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */
          this._lastBoundingBoxSize = {
            width: 0,
            height: 0
          };
          /** Whether the overlay was pushed in a previous positioning. */
          this._isPushed = false;
          /** Whether the overlay can be pushed on-screen on the initial open. */
          this._canPush = true;
          /** Whether the overlay can grow via flexible width/height after the initial open. */
          this._growAfterOpen = false;
          /** Whether the overlay's width and height can be constrained to fit within the viewport. */
          this._hasFlexibleDimensions = true;
          /** Whether the overlay position is locked. */
          this._positionLocked = false;
          /** Amount of space that must be maintained between the overlay and the edge of the viewport. */
          this._viewportMargin = 0;
          /** The Scrollable containers used to check scrollable view properties on position change. */
          this._scrollables = [];
          /** Ordered list of preferred positions, from most to least desirable. */
          this._preferredPositions = [];
          /** Subject that emits whenever the position changes. */
          this._positionChanges = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject();
          /** Subscription to viewport size changes. */
          this._resizeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_6__.Subscription.EMPTY;
          /** Default offset for the overlay along the x axis. */
          this._offsetX = 0;
          /** Default offset for the overlay along the y axis. */
          this._offsetY = 0;
          /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */
          this._appliedPanelClasses = [];
          /** Observable sequence of position changes. */
          this.positionChanges = this._positionChanges;
          this.setOrigin(connectedTo);
        }
        /** Ordered list of preferred positions, from most to least desirable. */
        _createClass(_FlexibleConnectedPositionStrategy, [{
          key: "positions",
          get: function get() {
            return this._preferredPositions;
          }
          /** Attaches this position strategy to an overlay. */
        }, {
          key: "attach",
          value: function attach(overlayRef) {
            var _this22 = this;
            if (this._overlayRef && overlayRef !== this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw Error('This position strategy is already attached to an overlay');
            }
            this._validatePositions();
            overlayRef.hostElement.classList.add(boundingBoxClass);
            this._overlayRef = overlayRef;
            this._boundingBox = overlayRef.hostElement;
            this._pane = overlayRef.overlayElement;
            this._isDisposed = false;
            this._isInitialRender = true;
            this._lastPosition = null;
            this._resizeSubscription.unsubscribe();
            this._resizeSubscription = this._viewportRuler.change().subscribe(function () {
              // When the window is resized, we want to trigger the next reposition as if it
              // was an initial render, in order for the strategy to pick a new optimal position,
              // otherwise position locking will cause it to stay at the old one.
              _this22._isInitialRender = true;
              _this22.apply();
            });
          }
          /**
           * Updates the position of the overlay element, using whichever preferred position relative
           * to the origin best fits on-screen.
           *
           * The selection of a position goes as follows:
           *  - If any positions fit completely within the viewport as-is,
           *      choose the first position that does so.
           *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,
           *      choose the position with the greatest available size modified by the positions' weight.
           *  - If pushing is enabled, take the position that went off-screen the least and push it
           *      on-screen.
           *  - If none of the previous criteria were met, use the position that goes off-screen the least.
           * @docs-private
           */
        }, {
          key: "apply",
          value: function apply() {
            // We shouldn't do anything if the strategy was disposed or we're on the server.
            if (this._isDisposed || !this._platform.isBrowser) {
              return;
            }
            // If the position has been applied already (e.g. when the overlay was opened) and the
            // consumer opted into locking in the position, re-use the old position, in order to
            // prevent the overlay from jumping around.
            if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
              this.reapplyLastPosition();
              return;
            }
            this._clearPanelClasses();
            this._resetOverlayElementStyles();
            this._resetBoundingBoxStyles();
            // We need the bounding rects for the origin and the overlay to determine how to position
            // the overlay relative to the origin.
            // We use the viewport rect to determine whether a position would go off-screen.
            this._viewportRect = this._getNarrowedViewportRect();
            this._originRect = this._getOriginRect();
            this._overlayRect = this._pane.getBoundingClientRect();
            var originRect = this._originRect;
            var overlayRect = this._overlayRect;
            var viewportRect = this._viewportRect;
            // Positions where the overlay will fit with flexible dimensions.
            var flexibleFits = [];
            // Fallback if none of the preferred positions fit within the viewport.
            var fallback;
            // Go through each of the preferred positions looking for a good fit.
            // If a good fit is found, it will be applied immediately.
            var _iterator3 = _createForOfIteratorHelper(this._preferredPositions),
              _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var pos = _step3.value;
                // Get the exact (x, y) coordinate for the point-of-origin on the origin element.
                var originPoint = this._getOriginPoint(originRect, pos);
                // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the
                // overlay in this position. We use the top-left corner for calculations and later translate
                // this into an appropriate (top, left, bottom, right) style.
                var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);
                // Calculate how well the overlay would fit into the viewport with this point.
                var overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);
                // If the overlay, without any further work, fits into the viewport, use this position.
                if (overlayFit.isCompletelyWithinViewport) {
                  this._isPushed = false;
                  this._applyPosition(pos, originPoint);
                  return;
                }
                // If the overlay has flexible dimensions, we can use this position
                // so long as there's enough space for the minimum dimensions.
                if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {
                  // Save positions where the overlay will fit with flexible dimensions. We will use these
                  // if none of the positions fit *without* flexible dimensions.
                  flexibleFits.push({
                    position: pos,
                    origin: originPoint,
                    overlayRect: overlayRect,
                    boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)
                  });
                  continue;
                }
                // If the current preferred position does not fit on the screen, remember the position
                // if it has more visible area on-screen than we've seen and move onto the next preferred
                // position.
                if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {
                  fallback = {
                    overlayFit: overlayFit,
                    overlayPoint: overlayPoint,
                    originPoint: originPoint,
                    position: pos,
                    overlayRect: overlayRect
                  };
                }
              }
              // If there are any positions where the overlay would fit with flexible dimensions, choose the
              // one that has the greatest area available modified by the position's weight
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            if (flexibleFits.length) {
              var bestFit = null;
              var bestScore = -1;
              var _iterator4 = _createForOfIteratorHelper(flexibleFits),
                _step4;
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  var fit = _step4.value;
                  var score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);
                  if (score > bestScore) {
                    bestScore = score;
                    bestFit = fit;
                  }
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
              this._isPushed = false;
              this._applyPosition(bestFit.position, bestFit.origin);
              return;
            }
            // When none of the preferred positions fit within the viewport, take the position
            // that went off-screen the least and attempt to push it on-screen.
            if (this._canPush) {
              // TODO(jelbourn): after pushing, the opening "direction" of the overlay might not make sense.
              this._isPushed = true;
              this._applyPosition(fallback.position, fallback.originPoint);
              return;
            }
            // All options for getting the overlay within the viewport have been exhausted, so go with the
            // position that went off-screen the least.
            this._applyPosition(fallback.position, fallback.originPoint);
          }
        }, {
          key: "detach",
          value: function detach() {
            this._clearPanelClasses();
            this._lastPosition = null;
            this._previousPushAmount = null;
            this._resizeSubscription.unsubscribe();
          }
          /** Cleanup after the element gets destroyed. */
        }, {
          key: "dispose",
          value: function dispose() {
            if (this._isDisposed) {
              return;
            }
            // We can't use `_resetBoundingBoxStyles` here, because it resets
            // some properties to zero, rather than removing them.
            if (this._boundingBox) {
              extendStyles(this._boundingBox.style, {
                top: '',
                left: '',
                right: '',
                bottom: '',
                height: '',
                width: '',
                alignItems: '',
                justifyContent: ''
              });
            }
            if (this._pane) {
              this._resetOverlayElementStyles();
            }
            if (this._overlayRef) {
              this._overlayRef.hostElement.classList.remove(boundingBoxClass);
            }
            this.detach();
            this._positionChanges.complete();
            this._overlayRef = this._boundingBox = null;
            this._isDisposed = true;
          }
          /**
           * This re-aligns the overlay element with the trigger in its last calculated position,
           * even if a position higher in the "preferred positions" list would now fit. This
           * allows one to re-align the panel without changing the orientation of the panel.
           */
        }, {
          key: "reapplyLastPosition",
          value: function reapplyLastPosition() {
            if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {
              this._originRect = this._getOriginRect();
              this._overlayRect = this._pane.getBoundingClientRect();
              this._viewportRect = this._getNarrowedViewportRect();
              var lastPosition = this._lastPosition || this._preferredPositions[0];
              var originPoint = this._getOriginPoint(this._originRect, lastPosition);
              this._applyPosition(lastPosition, originPoint);
            }
          }
          /**
           * Sets the list of Scrollable containers that host the origin element so that
           * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
           * Scrollable must be an ancestor element of the strategy's origin element.
           */
        }, {
          key: "withScrollableContainers",
          value: function withScrollableContainers(scrollables) {
            this._scrollables = scrollables;
            return this;
          }
          /**
           * Adds new preferred positions.
           * @param positions List of positions options for this overlay.
           */
        }, {
          key: "withPositions",
          value: function withPositions(positions) {
            this._preferredPositions = positions;
            // If the last calculated position object isn't part of the positions anymore, clear
            // it in order to avoid it being picked up if the consumer tries to re-apply.
            if (positions.indexOf(this._lastPosition) === -1) {
              this._lastPosition = null;
            }
            this._validatePositions();
            return this;
          }
          /**
           * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
           * @param margin Required margin between the overlay and the viewport edge in pixels.
           */
        }, {
          key: "withViewportMargin",
          value: function withViewportMargin(margin) {
            this._viewportMargin = margin;
            return this;
          }
          /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */
        }, {
          key: "withFlexibleDimensions",
          value: function withFlexibleDimensions() {
            var flexibleDimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            this._hasFlexibleDimensions = flexibleDimensions;
            return this;
          }
          /** Sets whether the overlay can grow after the initial open via flexible width/height. */
        }, {
          key: "withGrowAfterOpen",
          value: function withGrowAfterOpen() {
            var growAfterOpen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            this._growAfterOpen = growAfterOpen;
            return this;
          }
          /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */
        }, {
          key: "withPush",
          value: function withPush() {
            var canPush = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            this._canPush = canPush;
            return this;
          }
          /**
           * Sets whether the overlay's position should be locked in after it is positioned
           * initially. When an overlay is locked in, it won't attempt to reposition itself
           * when the position is re-applied (e.g. when the user scrolls away).
           * @param isLocked Whether the overlay should locked in.
           */
        }, {
          key: "withLockedPosition",
          value: function withLockedPosition() {
            var isLocked = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            this._positionLocked = isLocked;
            return this;
          }
          /**
           * Sets the origin, relative to which to position the overlay.
           * Using an element origin is useful for building components that need to be positioned
           * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be
           * used for cases like contextual menus which open relative to the user's pointer.
           * @param origin Reference to the new origin.
           */
        }, {
          key: "setOrigin",
          value: function setOrigin(origin) {
            this._origin = origin;
            return this;
          }
          /**
           * Sets the default offset for the overlay's connection point on the x-axis.
           * @param offset New offset in the X axis.
           */
        }, {
          key: "withDefaultOffsetX",
          value: function withDefaultOffsetX(offset) {
            this._offsetX = offset;
            return this;
          }
          /**
           * Sets the default offset for the overlay's connection point on the y-axis.
           * @param offset New offset in the Y axis.
           */
        }, {
          key: "withDefaultOffsetY",
          value: function withDefaultOffsetY(offset) {
            this._offsetY = offset;
            return this;
          }
          /**
           * Configures that the position strategy should set a `transform-origin` on some elements
           * inside the overlay, depending on the current position that is being applied. This is
           * useful for the cases where the origin of an animation can change depending on the
           * alignment of the overlay.
           * @param selector CSS selector that will be used to find the target
           *    elements onto which to set the transform origin.
           */
        }, {
          key: "withTransformOriginOn",
          value: function withTransformOriginOn(selector) {
            this._transformOriginSelector = selector;
            return this;
          }
          /**
           * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
           */
        }, {
          key: "_getOriginPoint",
          value: function _getOriginPoint(originRect, pos) {
            var x;
            if (pos.originX == 'center') {
              // Note: when centering we should always use the `left`
              // offset, otherwise the position will be wrong in RTL.
              x = originRect.left + originRect.width / 2;
            } else {
              var startX = this._isRtl() ? originRect.right : originRect.left;
              var endX = this._isRtl() ? originRect.left : originRect.right;
              x = pos.originX == 'start' ? startX : endX;
            }
            var y;
            if (pos.originY == 'center') {
              y = originRect.top + originRect.height / 2;
            } else {
              y = pos.originY == 'top' ? originRect.top : originRect.bottom;
            }
            return {
              x: x,
              y: y
            };
          }
          /**
           * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
           * origin point to which the overlay should be connected.
           */
        }, {
          key: "_getOverlayPoint",
          value: function _getOverlayPoint(originPoint, overlayRect, pos) {
            // Calculate the (overlayStartX, overlayStartY), the start of the
            // potential overlay position relative to the origin point.
            var overlayStartX;
            if (pos.overlayX == 'center') {
              overlayStartX = -overlayRect.width / 2;
            } else if (pos.overlayX === 'start') {
              overlayStartX = this._isRtl() ? -overlayRect.width : 0;
            } else {
              overlayStartX = this._isRtl() ? 0 : -overlayRect.width;
            }
            var overlayStartY;
            if (pos.overlayY == 'center') {
              overlayStartY = -overlayRect.height / 2;
            } else {
              overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;
            }
            // The (x, y) coordinates of the overlay.
            return {
              x: originPoint.x + overlayStartX,
              y: originPoint.y + overlayStartY
            };
          }
          /** Gets how well an overlay at the given point will fit within the viewport. */
        }, {
          key: "_getOverlayFit",
          value: function _getOverlayFit(point, rawOverlayRect, viewport, position) {
            // Round the overlay rect when comparing against the
            // viewport, because the viewport is always rounded.
            var overlay = getRoundedBoundingClientRect(rawOverlayRect);
            var x = point.x,
              y = point.y;
            var offsetX = this._getOffset(position, 'x');
            var offsetY = this._getOffset(position, 'y');
            // Account for the offsets since they could push the overlay out of the viewport.
            if (offsetX) {
              x += offsetX;
            }
            if (offsetY) {
              y += offsetY;
            }
            // How much the overlay would overflow at this position, on each side.
            var leftOverflow = 0 - x;
            var rightOverflow = x + overlay.width - viewport.width;
            var topOverflow = 0 - y;
            var bottomOverflow = y + overlay.height - viewport.height;
            // Visible parts of the element on each axis.
            var visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);
            var visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);
            var visibleArea = visibleWidth * visibleHeight;
            return {
              visibleArea: visibleArea,
              isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,
              fitsInViewportVertically: visibleHeight === overlay.height,
              fitsInViewportHorizontally: visibleWidth == overlay.width
            };
          }
          /**
           * Whether the overlay can fit within the viewport when it may resize either its width or height.
           * @param fit How well the overlay fits in the viewport at some position.
           * @param point The (x, y) coordinates of the overlat at some position.
           * @param viewport The geometry of the viewport.
           */
        }, {
          key: "_canFitWithFlexibleDimensions",
          value: function _canFitWithFlexibleDimensions(fit, point, viewport) {
            if (this._hasFlexibleDimensions) {
              var availableHeight = viewport.bottom - point.y;
              var availableWidth = viewport.right - point.x;
              var minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);
              var minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);
              var verticalFit = fit.fitsInViewportVertically || minHeight != null && minHeight <= availableHeight;
              var horizontalFit = fit.fitsInViewportHorizontally || minWidth != null && minWidth <= availableWidth;
              return verticalFit && horizontalFit;
            }
            return false;
          }
          /**
           * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
           * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the
           * right and bottom).
           *
           * @param start Starting point from which the overlay is pushed.
           * @param overlay Dimensions of the overlay.
           * @param scrollPosition Current viewport scroll position.
           * @returns The point at which to position the overlay after pushing. This is effectively a new
           *     originPoint.
           */
        }, {
          key: "_pushOverlayOnScreen",
          value: function _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {
            // If the position is locked and we've pushed the overlay already, reuse the previous push
            // amount, rather than pushing it again. If we were to continue pushing, the element would
            // remain in the viewport, which goes against the expectations when position locking is enabled.
            if (this._previousPushAmount && this._positionLocked) {
              return {
                x: start.x + this._previousPushAmount.x,
                y: start.y + this._previousPushAmount.y
              };
            }
            // Round the overlay rect when comparing against the
            // viewport, because the viewport is always rounded.
            var overlay = getRoundedBoundingClientRect(rawOverlayRect);
            var viewport = this._viewportRect;
            // Determine how much the overlay goes outside the viewport on each
            // side, which we'll use to decide which direction to push it.
            var overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);
            var overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);
            var overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);
            var overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);
            // Amount by which to push the overlay in each axis such that it remains on-screen.
            var pushX = 0;
            var pushY = 0;
            // If the overlay fits completely within the bounds of the viewport, push it from whichever
            // direction is goes off-screen. Otherwise, push the top-left corner such that its in the
            // viewport and allow for the trailing end of the overlay to go out of bounds.
            if (overlay.width <= viewport.width) {
              pushX = overflowLeft || -overflowRight;
            } else {
              pushX = start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0;
            }
            if (overlay.height <= viewport.height) {
              pushY = overflowTop || -overflowBottom;
            } else {
              pushY = start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0;
            }
            this._previousPushAmount = {
              x: pushX,
              y: pushY
            };
            return {
              x: start.x + pushX,
              y: start.y + pushY
            };
          }
          /**
           * Applies a computed position to the overlay and emits a position change.
           * @param position The position preference
           * @param originPoint The point on the origin element where the overlay is connected.
           */
        }, {
          key: "_applyPosition",
          value: function _applyPosition(position, originPoint) {
            this._setTransformOrigin(position);
            this._setOverlayElementStyles(originPoint, position);
            this._setBoundingBoxStyles(originPoint, position);
            if (position.panelClass) {
              this._addPanelClasses(position.panelClass);
            }
            // Save the last connected position in case the position needs to be re-calculated.
            this._lastPosition = position;
            // Notify that the position has been changed along with its change properties.
            // We only emit if we've got any subscriptions, because the scroll visibility
            // calculcations can be somewhat expensive.
            if (this._positionChanges.observers.length) {
              var scrollableViewProperties = this._getScrollVisibility();
              var changeEvent = new _ConnectedOverlayPositionChange(position, scrollableViewProperties);
              this._positionChanges.next(changeEvent);
            }
            this._isInitialRender = false;
          }
          /** Sets the transform origin based on the configured selector and the passed-in position.  */
        }, {
          key: "_setTransformOrigin",
          value: function _setTransformOrigin(position) {
            if (!this._transformOriginSelector) {
              return;
            }
            var elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);
            var xOrigin;
            var yOrigin = position.overlayY;
            if (position.overlayX === 'center') {
              xOrigin = 'center';
            } else if (this._isRtl()) {
              xOrigin = position.overlayX === 'start' ? 'right' : 'left';
            } else {
              xOrigin = position.overlayX === 'start' ? 'left' : 'right';
            }
            for (var i = 0; i < elements.length; i++) {
              elements[i].style.transformOrigin = "".concat(xOrigin, " ").concat(yOrigin);
            }
          }
          /**
           * Gets the position and size of the overlay's sizing container.
           *
           * This method does no measuring and applies no styles so that we can cheaply compute the
           * bounds for all positions and choose the best fit based on these results.
           */
        }, {
          key: "_calculateBoundingBoxRect",
          value: function _calculateBoundingBoxRect(origin, position) {
            var viewport = this._viewportRect;
            var isRtl = this._isRtl();
            var height, top, bottom;
            if (position.overlayY === 'top') {
              // Overlay is opening "downward" and thus is bound by the bottom viewport edge.
              top = origin.y;
              height = viewport.height - top + this._viewportMargin;
            } else if (position.overlayY === 'bottom') {
              // Overlay is opening "upward" and thus is bound by the top viewport edge. We need to add
              // the viewport margin back in, because the viewport rect is narrowed down to remove the
              // margin, whereas the `origin` position is calculated based on its `ClientRect`.
              bottom = viewport.height - origin.y + this._viewportMargin * 2;
              height = viewport.height - bottom + this._viewportMargin;
            } else {
              // If neither top nor bottom, it means that the overlay is vertically centered on the
              // origin point. Note that we want the position relative to the viewport, rather than
              // the page, which is why we don't use something like `viewport.bottom - origin.y` and
              // `origin.y - viewport.top`.
              var smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);
              var previousHeight = this._lastBoundingBoxSize.height;
              height = smallestDistanceToViewportEdge * 2;
              top = origin.y - smallestDistanceToViewportEdge;
              if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {
                top = origin.y - previousHeight / 2;
              }
            }
            // The overlay is opening 'right-ward' (the content flows to the right).
            var isBoundedByRightViewportEdge = position.overlayX === 'start' && !isRtl || position.overlayX === 'end' && isRtl;
            // The overlay is opening 'left-ward' (the content flows to the left).
            var isBoundedByLeftViewportEdge = position.overlayX === 'end' && !isRtl || position.overlayX === 'start' && isRtl;
            var width, left, right;
            if (isBoundedByLeftViewportEdge) {
              right = viewport.width - origin.x + this._viewportMargin;
              width = origin.x - this._viewportMargin;
            } else if (isBoundedByRightViewportEdge) {
              left = origin.x;
              width = viewport.right - origin.x;
            } else {
              // If neither start nor end, it means that the overlay is horizontally centered on the
              // origin point. Note that we want the position relative to the viewport, rather than
              // the page, which is why we don't use something like `viewport.right - origin.x` and
              // `origin.x - viewport.left`.
              var _smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);
              var previousWidth = this._lastBoundingBoxSize.width;
              width = _smallestDistanceToViewportEdge * 2;
              left = origin.x - _smallestDistanceToViewportEdge;
              if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {
                left = origin.x - previousWidth / 2;
              }
            }
            return {
              top: top,
              left: left,
              bottom: bottom,
              right: right,
              width: width,
              height: height
            };
          }
          /**
           * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
           * origin's connection point and stetches to the bounds of the viewport.
           *
           * @param origin The point on the origin element where the overlay is connected.
           * @param position The position preference
           */
        }, {
          key: "_setBoundingBoxStyles",
          value: function _setBoundingBoxStyles(origin, position) {
            var boundingBoxRect = this._calculateBoundingBoxRect(origin, position);
            // It's weird if the overlay *grows* while scrolling, so we take the last size into account
            // when applying a new size.
            if (!this._isInitialRender && !this._growAfterOpen) {
              boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);
              boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);
            }
            var styles = {};
            if (this._hasExactPosition()) {
              styles.top = styles.left = '0';
              styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = '';
              styles.width = styles.height = '100%';
            } else {
              var maxHeight = this._overlayRef.getConfig().maxHeight;
              var maxWidth = this._overlayRef.getConfig().maxWidth;
              styles.height = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(boundingBoxRect.height);
              styles.top = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(boundingBoxRect.top);
              styles.bottom = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(boundingBoxRect.bottom);
              styles.width = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(boundingBoxRect.width);
              styles.left = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(boundingBoxRect.left);
              styles.right = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(boundingBoxRect.right);
              // Push the pane content towards the proper direction.
              if (position.overlayX === 'center') {
                styles.alignItems = 'center';
              } else {
                styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';
              }
              if (position.overlayY === 'center') {
                styles.justifyContent = 'center';
              } else {
                styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';
              }
              if (maxHeight) {
                styles.maxHeight = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(maxHeight);
              }
              if (maxWidth) {
                styles.maxWidth = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(maxWidth);
              }
            }
            this._lastBoundingBoxSize = boundingBoxRect;
            extendStyles(this._boundingBox.style, styles);
          }
          /** Resets the styles for the bounding box so that a new positioning can be computed. */
        }, {
          key: "_resetBoundingBoxStyles",
          value: function _resetBoundingBoxStyles() {
            extendStyles(this._boundingBox.style, {
              top: '0',
              left: '0',
              right: '0',
              bottom: '0',
              height: '',
              width: '',
              alignItems: '',
              justifyContent: ''
            });
          }
          /** Resets the styles for the overlay pane so that a new positioning can be computed. */
        }, {
          key: "_resetOverlayElementStyles",
          value: function _resetOverlayElementStyles() {
            extendStyles(this._pane.style, {
              top: '',
              left: '',
              bottom: '',
              right: '',
              position: '',
              transform: ''
            });
          }
          /** Sets positioning styles to the overlay element. */
        }, {
          key: "_setOverlayElementStyles",
          value: function _setOverlayElementStyles(originPoint, position) {
            var styles = {};
            var hasExactPosition = this._hasExactPosition();
            var hasFlexibleDimensions = this._hasFlexibleDimensions;
            var config = this._overlayRef.getConfig();
            if (hasExactPosition) {
              var scrollPosition = this._viewportRuler.getViewportScrollPosition();
              extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));
              extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));
            } else {
              styles.position = 'static';
            }
            // Use a transform to apply the offsets. We do this because the `center` positions rely on
            // being in the normal flex flow and setting a `top` / `left` at all will completely throw
            // off the position. We also can't use margins, because they won't have an effect in some
            // cases where the element doesn't have anything to "push off of". Finally, this works
            // better both with flexible and non-flexible positioning.
            var transformString = '';
            var offsetX = this._getOffset(position, 'x');
            var offsetY = this._getOffset(position, 'y');
            if (offsetX) {
              transformString += "translateX(".concat(offsetX, "px) ");
            }
            if (offsetY) {
              transformString += "translateY(".concat(offsetY, "px)");
            }
            styles.transform = transformString.trim();
            // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because
            // we need these values to both be set to "100%" for the automatic flexible sizing to work.
            // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.
            // Note that this doesn't apply when we have an exact position, in which case we do want to
            // apply them because they'll be cleared from the bounding box.
            if (config.maxHeight) {
              if (hasExactPosition) {
                styles.maxHeight = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(config.maxHeight);
              } else if (hasFlexibleDimensions) {
                styles.maxHeight = '';
              }
            }
            if (config.maxWidth) {
              if (hasExactPosition) {
                styles.maxWidth = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(config.maxWidth);
              } else if (hasFlexibleDimensions) {
                styles.maxWidth = '';
              }
            }
            extendStyles(this._pane.style, styles);
          }
          /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */
        }, {
          key: "_getExactOverlayY",
          value: function _getExactOverlayY(position, originPoint, scrollPosition) {
            // Reset any existing styles. This is necessary in case the
            // preferred position has changed since the last `apply`.
            var styles = {
              top: '',
              bottom: ''
            };
            var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
            if (this._isPushed) {
              overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
            }
            var virtualKeyboardOffset = this._overlayContainer.getContainerElement().getBoundingClientRect().top;
            // Normally this would be zero, however when the overlay is attached to an input (e.g. in an
            // autocomplete), mobile browsers will shift everything in order to put the input in the middle
            // of the screen and to make space for the virtual keyboard. We need to account for this offset,
            // otherwise our positioning will be thrown off.
            overlayPoint.y -= virtualKeyboardOffset;
            // We want to set either `top` or `bottom` based on whether the overlay wants to appear
            // above or below the origin and the direction in which the element will expand.
            if (position.overlayY === 'bottom') {
              // When using `bottom`, we adjust the y position such that it is the distance
              // from the bottom of the viewport rather than the top.
              var documentHeight = this._document.documentElement.clientHeight;
              styles.bottom = "".concat(documentHeight - (overlayPoint.y + this._overlayRect.height), "px");
            } else {
              styles.top = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(overlayPoint.y);
            }
            return styles;
          }
          /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */
        }, {
          key: "_getExactOverlayX",
          value: function _getExactOverlayX(position, originPoint, scrollPosition) {
            // Reset any existing styles. This is necessary in case the preferred position has
            // changed since the last `apply`.
            var styles = {
              left: '',
              right: ''
            };
            var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
            if (this._isPushed) {
              overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
            }
            // We want to set either `left` or `right` based on whether the overlay wants to appear "before"
            // or "after" the origin, which determines the direction in which the element will expand.
            // For the horizontal axis, the meaning of "before" and "after" change based on whether the
            // page is in RTL or LTR.
            var horizontalStyleProperty;
            if (this._isRtl()) {
              horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';
            } else {
              horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';
            }
            // When we're setting `right`, we adjust the x position such that it is the distance
            // from the right edge of the viewport rather than the left edge.
            if (horizontalStyleProperty === 'right') {
              var documentWidth = this._document.documentElement.clientWidth;
              styles.right = "".concat(documentWidth - (overlayPoint.x + this._overlayRect.width), "px");
            } else {
              styles.left = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceCssPixelValue)(overlayPoint.x);
            }
            return styles;
          }
          /**
           * Gets the view properties of the trigger and overlay, including whether they are clipped
           * or completely outside the view of any of the strategy's scrollables.
           */
        }, {
          key: "_getScrollVisibility",
          value: function _getScrollVisibility() {
            // Note: needs fresh rects since the position could've changed.
            var originBounds = this._getOriginRect();
            var overlayBounds = this._pane.getBoundingClientRect();
            // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers
            // every time, we should be able to use the scrollTop of the containers if the size of those
            // containers hasn't changed.
            var scrollContainerBounds = this._scrollables.map(function (scrollable) {
              return scrollable.getElementRef().nativeElement.getBoundingClientRect();
            });
            return {
              isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),
              isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),
              isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),
              isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds)
            };
          }
          /** Subtracts the amount that an element is overflowing on an axis from its length. */
        }, {
          key: "_subtractOverflows",
          value: function _subtractOverflows(length) {
            for (var _len3 = arguments.length, overflows = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
              overflows[_key3 - 1] = arguments[_key3];
            }
            return overflows.reduce(function (currentValue, currentOverflow) {
              return currentValue - Math.max(currentOverflow, 0);
            }, length);
          }
          /** Narrows the given viewport rect by the current _viewportMargin. */
        }, {
          key: "_getNarrowedViewportRect",
          value: function _getNarrowedViewportRect() {
            // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,
            // because we want to use the `clientWidth` and `clientHeight` as the base. The difference
            // being that the client properties don't include the scrollbar, as opposed to `innerWidth`
            // and `innerHeight` that do. This is necessary, because the overlay container uses
            // 100% `width` and `height` which don't include the scrollbar either.
            var width = this._document.documentElement.clientWidth;
            var height = this._document.documentElement.clientHeight;
            var scrollPosition = this._viewportRuler.getViewportScrollPosition();
            return {
              top: scrollPosition.top + this._viewportMargin,
              left: scrollPosition.left + this._viewportMargin,
              right: scrollPosition.left + width - this._viewportMargin,
              bottom: scrollPosition.top + height - this._viewportMargin,
              width: width - 2 * this._viewportMargin,
              height: height - 2 * this._viewportMargin
            };
          }
          /** Whether the we're dealing with an RTL context */
        }, {
          key: "_isRtl",
          value: function _isRtl() {
            return this._overlayRef.getDirection() === 'rtl';
          }
          /** Determines whether the overlay uses exact or flexible positioning. */
        }, {
          key: "_hasExactPosition",
          value: function _hasExactPosition() {
            return !this._hasFlexibleDimensions || this._isPushed;
          }
          /** Retrieves the offset of a position along the x or y axis. */
        }, {
          key: "_getOffset",
          value: function _getOffset(position, axis) {
            if (axis === 'x') {
              // We don't do something like `position['offset' + axis]` in
              // order to avoid breking minifiers that rename properties.
              return position.offsetX == null ? this._offsetX : position.offsetX;
            }
            return position.offsetY == null ? this._offsetY : position.offsetY;
          }
          /** Validates that the current position match the expected values. */
        }, {
          key: "_validatePositions",
          value: function _validatePositions() {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
              if (!this._preferredPositions.length) {
                throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');
              }
              // TODO(crisbeto): remove these once Angular's template type
              // checking is advanced enough to catch these cases.
              this._preferredPositions.forEach(function (pair) {
                _validateHorizontalPosition('originX', pair.originX);
                _validateVerticalPosition('originY', pair.originY);
                _validateHorizontalPosition('overlayX', pair.overlayX);
                _validateVerticalPosition('overlayY', pair.overlayY);
              });
            }
          }
          /** Adds a single CSS class or an array of classes on the overlay panel. */
        }, {
          key: "_addPanelClasses",
          value: function _addPanelClasses(cssClasses) {
            var _this23 = this;
            if (this._pane) {
              (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceArray)(cssClasses).forEach(function (cssClass) {
                if (cssClass !== '' && _this23._appliedPanelClasses.indexOf(cssClass) === -1) {
                  _this23._appliedPanelClasses.push(cssClass);
                  _this23._pane.classList.add(cssClass);
                }
              });
            }
          }
          /** Clears the classes that the position strategy has applied from the overlay panel. */
        }, {
          key: "_clearPanelClasses",
          value: function _clearPanelClasses() {
            var _this24 = this;
            if (this._pane) {
              this._appliedPanelClasses.forEach(function (cssClass) {
                _this24._pane.classList.remove(cssClass);
              });
              this._appliedPanelClasses = [];
            }
          }
          /** Returns the ClientRect of the current origin. */
        }, {
          key: "_getOriginRect",
          value: function _getOriginRect() {
            var origin = this._origin;
            if (origin instanceof _angular_core__WEBPACK_IMPORTED_MODULE_3__.ElementRef) {
              return origin.nativeElement.getBoundingClientRect();
            }
            // Check for Element so SVG elements are also supported.
            if (origin instanceof Element) {
              return origin.getBoundingClientRect();
            }
            var width = origin.width || 0;
            var height = origin.height || 0;
            // If the origin is a point, return a client rect as if it was a 0x0 element at the point.
            return {
              top: origin.y,
              bottom: origin.y + height,
              left: origin.x,
              right: origin.x + width,
              height: height,
              width: width
            };
          }
        }]);
        return _FlexibleConnectedPositionStrategy;
      }();
      /** Shallow-extends a stylesheet object with another stylesheet object. */
      function extendStyles(destination, source) {
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            destination[key] = source[key];
          }
        }
        return destination;
      }
      /**
       * Extracts the pixel value as a number from a value, if it's a number
       * or a CSS pixel string (e.g. `1337px`). Otherwise returns null.
       */
      function getPixelValue(input) {
        if (typeof input !== 'number' && input != null) {
          var _input$split = input.split(cssUnitPattern),
            _input$split2 = _slicedToArray(_input$split, 2),
            value = _input$split2[0],
            units = _input$split2[1];
          return !units || units === 'px' ? parseFloat(value) : null;
        }
        return input || null;
      }
      /**
       * Gets a version of an element's bounding `ClientRect` where all the values are rounded down to
       * the nearest pixel. This allows us to account for the cases where there may be sub-pixel
       * deviations in the `ClientRect` returned by the browser (e.g. when zoomed in with a percentage
       * size, see #21350).
       */
      function getRoundedBoundingClientRect(clientRect) {
        return {
          top: Math.floor(clientRect.top),
          right: Math.floor(clientRect.right),
          bottom: Math.floor(clientRect.bottom),
          left: Math.floor(clientRect.left),
          width: Math.floor(clientRect.width),
          height: Math.floor(clientRect.height)
        };
      }

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * A strategy for positioning overlays. Using this strategy, an overlay is given an
       * implicit position relative to some origin element. The relative position is defined in terms of
       * a point on the origin element that is connected to a point on the overlay element. For example,
       * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
       * of the overlay.
       * @deprecated Use `FlexibleConnectedPositionStrategy` instead.
       * @breaking-change 8.0.0
       */
      var _ConnectedPositionStrategy = /*#__PURE__*/function () {
        function _ConnectedPositionStrategy(originPos, overlayPos, connectedTo, viewportRuler, document, platform, overlayContainer) {
          _classCallCheck(this, _ConnectedPositionStrategy);
          /** Ordered list of preferred positions, from most to least desirable. */
          this._preferredPositions = [];
          // Since the `ConnectedPositionStrategy` is deprecated and we don't want to maintain
          // the extra logic, we create an instance of the positioning strategy that has some
          // defaults that make it behave as the old position strategy and to which we'll
          // proxy all of the API calls.
          this._positionStrategy = new _FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform, overlayContainer).withFlexibleDimensions(false).withPush(false).withViewportMargin(0);
          this.withFallbackPosition(originPos, overlayPos);
          this.onPositionChange = this._positionStrategy.positionChanges;
        }
        /** Ordered list of preferred positions, from most to least desirable. */
        _createClass(_ConnectedPositionStrategy, [{
          key: "positions",
          get: function get() {
            return this._preferredPositions;
          }
          /** Attach this position strategy to an overlay. */
        }, {
          key: "attach",
          value: function attach(overlayRef) {
            this._overlayRef = overlayRef;
            this._positionStrategy.attach(overlayRef);
            if (this._direction) {
              overlayRef.setDirection(this._direction);
              this._direction = null;
            }
          }
          /** Disposes all resources used by the position strategy. */
        }, {
          key: "dispose",
          value: function dispose() {
            this._positionStrategy.dispose();
          }
          /** @docs-private */
        }, {
          key: "detach",
          value: function detach() {
            this._positionStrategy.detach();
          }
          /**
           * Updates the position of the overlay element, using whichever preferred position relative
           * to the origin fits on-screen.
           * @docs-private
           */
        }, {
          key: "apply",
          value: function apply() {
            this._positionStrategy.apply();
          }
          /**
           * Re-positions the overlay element with the trigger in its last calculated position,
           * even if a position higher in the "preferred positions" list would now fit. This
           * allows one to re-align the panel without changing the orientation of the panel.
           */
        }, {
          key: "recalculateLastPosition",
          value: function recalculateLastPosition() {
            this._positionStrategy.reapplyLastPosition();
          }
          /**
           * Sets the list of Scrollable containers that host the origin element so that
           * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
           * Scrollable must be an ancestor element of the strategy's origin element.
           */
        }, {
          key: "withScrollableContainers",
          value: function withScrollableContainers(scrollables) {
            this._positionStrategy.withScrollableContainers(scrollables);
          }
          /**
           * Adds a new preferred fallback position.
           * @param originPos
           * @param overlayPos
           */
        }, {
          key: "withFallbackPosition",
          value: function withFallbackPosition(originPos, overlayPos, offsetX, offsetY) {
            var position = new _ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);
            this._preferredPositions.push(position);
            this._positionStrategy.withPositions(this._preferredPositions);
            return this;
          }
          /**
           * Sets the layout direction so the overlay's position can be adjusted to match.
           * @param dir New layout direction.
           */
        }, {
          key: "withDirection",
          value: function withDirection(dir) {
            // Since the direction might be declared before the strategy is attached,
            // we save the value in a temporary property and we'll transfer it to the
            // overlay ref on attachment.
            if (this._overlayRef) {
              this._overlayRef.setDirection(dir);
            } else {
              this._direction = dir;
            }
            return this;
          }
          /**
           * Sets an offset for the overlay's connection point on the x-axis
           * @param offset New offset in the X axis.
           */
        }, {
          key: "withOffsetX",
          value: function withOffsetX(offset) {
            this._positionStrategy.withDefaultOffsetX(offset);
            return this;
          }
          /**
           * Sets an offset for the overlay's connection point on the y-axis
           * @param  offset New offset in the Y axis.
           */
        }, {
          key: "withOffsetY",
          value: function withOffsetY(offset) {
            this._positionStrategy.withDefaultOffsetY(offset);
            return this;
          }
          /**
           * Sets whether the overlay's position should be locked in after it is positioned
           * initially. When an overlay is locked in, it won't attempt to reposition itself
           * when the position is re-applied (e.g. when the user scrolls away).
           * @param isLocked Whether the overlay should locked in.
           */
        }, {
          key: "withLockedPosition",
          value: function withLockedPosition(isLocked) {
            this._positionStrategy.withLockedPosition(isLocked);
            return this;
          }
          /**
           * Overwrites the current set of positions with an array of new ones.
           * @param positions Position pairs to be set on the strategy.
           */
        }, {
          key: "withPositions",
          value: function withPositions(positions) {
            this._preferredPositions = positions.slice();
            this._positionStrategy.withPositions(this._preferredPositions);
            return this;
          }
          /**
           * Sets the origin element, relative to which to position the overlay.
           * @param origin Reference to the new origin element.
           */
        }, {
          key: "setOrigin",
          value: function setOrigin(origin) {
            this._positionStrategy.setOrigin(origin);
            return this;
          }
        }]);
        return _ConnectedPositionStrategy;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Class to be added to the overlay pane wrapper. */
      var wrapperClass = 'cdk-global-overlay-wrapper';
      /**
       * A strategy for positioning overlays. Using this strategy, an overlay is given an
       * explicit position relative to the browser's viewport. We use flexbox, instead of
       * transforms, in order to avoid issues with subpixel rendering which can cause the
       * element to become blurry.
       */
      var _GlobalPositionStrategy = /*#__PURE__*/function () {
        function _GlobalPositionStrategy() {
          _classCallCheck(this, _GlobalPositionStrategy);
          this._cssPosition = 'static';
          this._topOffset = '';
          this._bottomOffset = '';
          this._leftOffset = '';
          this._rightOffset = '';
          this._alignItems = '';
          this._justifyContent = '';
          this._width = '';
          this._height = '';
        }
        _createClass(_GlobalPositionStrategy, [{
          key: "attach",
          value: function attach(overlayRef) {
            var config = overlayRef.getConfig();
            this._overlayRef = overlayRef;
            if (this._width && !config.width) {
              overlayRef.updateSize({
                width: this._width
              });
            }
            if (this._height && !config.height) {
              overlayRef.updateSize({
                height: this._height
              });
            }
            overlayRef.hostElement.classList.add(wrapperClass);
            this._isDisposed = false;
          }
          /**
           * Sets the top position of the overlay. Clears any previously set vertical position.
           * @param value New top offset.
           */
        }, {
          key: "top",
          value: function top() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            this._bottomOffset = '';
            this._topOffset = value;
            this._alignItems = 'flex-start';
            return this;
          }
          /**
           * Sets the left position of the overlay. Clears any previously set horizontal position.
           * @param value New left offset.
           */
        }, {
          key: "left",
          value: function left() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            this._rightOffset = '';
            this._leftOffset = value;
            this._justifyContent = 'flex-start';
            return this;
          }
          /**
           * Sets the bottom position of the overlay. Clears any previously set vertical position.
           * @param value New bottom offset.
           */
        }, {
          key: "bottom",
          value: function bottom() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            this._topOffset = '';
            this._bottomOffset = value;
            this._alignItems = 'flex-end';
            return this;
          }
          /**
           * Sets the right position of the overlay. Clears any previously set horizontal position.
           * @param value New right offset.
           */
        }, {
          key: "right",
          value: function right() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            this._leftOffset = '';
            this._rightOffset = value;
            this._justifyContent = 'flex-end';
            return this;
          }
          /**
           * Sets the overlay width and clears any previously set width.
           * @param value New width for the overlay
           * @deprecated Pass the `width` through the `OverlayConfig`.
           * @breaking-change 8.0.0
           */
        }, {
          key: "width",
          value: function width() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            if (this._overlayRef) {
              this._overlayRef.updateSize({
                width: value
              });
            } else {
              this._width = value;
            }
            return this;
          }
          /**
           * Sets the overlay height and clears any previously set height.
           * @param value New height for the overlay
           * @deprecated Pass the `height` through the `OverlayConfig`.
           * @breaking-change 8.0.0
           */
        }, {
          key: "height",
          value: function height() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            if (this._overlayRef) {
              this._overlayRef.updateSize({
                height: value
              });
            } else {
              this._height = value;
            }
            return this;
          }
          /**
           * Centers the overlay horizontally with an optional offset.
           * Clears any previously set horizontal position.
           *
           * @param offset Overlay offset from the horizontal center.
           */
        }, {
          key: "centerHorizontally",
          value: function centerHorizontally() {
            var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            this.left(offset);
            this._justifyContent = 'center';
            return this;
          }
          /**
           * Centers the overlay vertically with an optional offset.
           * Clears any previously set vertical position.
           *
           * @param offset Overlay offset from the vertical center.
           */
        }, {
          key: "centerVertically",
          value: function centerVertically() {
            var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            this.top(offset);
            this._alignItems = 'center';
            return this;
          }
          /**
           * Apply the position to the element.
           * @docs-private
           */
        }, {
          key: "apply",
          value: function apply() {
            // Since the overlay ref applies the strategy asynchronously, it could
            // have been disposed before it ends up being applied. If that is the
            // case, we shouldn't do anything.
            if (!this._overlayRef || !this._overlayRef.hasAttached()) {
              return;
            }
            var styles = this._overlayRef.overlayElement.style;
            var parentStyles = this._overlayRef.hostElement.style;
            var config = this._overlayRef.getConfig();
            var width = config.width,
              height = config.height,
              maxWidth = config.maxWidth,
              maxHeight = config.maxHeight;
            var shouldBeFlushHorizontally = (width === '100%' || width === '100vw') && (!maxWidth || maxWidth === '100%' || maxWidth === '100vw');
            var shouldBeFlushVertically = (height === '100%' || height === '100vh') && (!maxHeight || maxHeight === '100%' || maxHeight === '100vh');
            styles.position = this._cssPosition;
            styles.marginLeft = shouldBeFlushHorizontally ? '0' : this._leftOffset;
            styles.marginTop = shouldBeFlushVertically ? '0' : this._topOffset;
            styles.marginBottom = this._bottomOffset;
            styles.marginRight = this._rightOffset;
            if (shouldBeFlushHorizontally) {
              parentStyles.justifyContent = 'flex-start';
            } else if (this._justifyContent === 'center') {
              parentStyles.justifyContent = 'center';
            } else if (this._overlayRef.getConfig().direction === 'rtl') {
              // In RTL the browser will invert `flex-start` and `flex-end` automatically, but we
              // don't want that because our positioning is explicitly `left` and `right`, hence
              // why we do another inversion to ensure that the overlay stays in the same position.
              // TODO: reconsider this if we add `start` and `end` methods.
              if (this._justifyContent === 'flex-start') {
                parentStyles.justifyContent = 'flex-end';
              } else if (this._justifyContent === 'flex-end') {
                parentStyles.justifyContent = 'flex-start';
              }
            } else {
              parentStyles.justifyContent = this._justifyContent;
            }
            parentStyles.alignItems = shouldBeFlushVertically ? 'flex-start' : this._alignItems;
          }
          /**
           * Cleans up the DOM changes from the position strategy.
           * @docs-private
           */
        }, {
          key: "dispose",
          value: function dispose() {
            if (this._isDisposed || !this._overlayRef) {
              return;
            }
            var styles = this._overlayRef.overlayElement.style;
            var parent = this._overlayRef.hostElement;
            var parentStyles = parent.style;
            parent.classList.remove(wrapperClass);
            parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop = styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';
            this._overlayRef = null;
            this._isDisposed = true;
          }
        }]);
        return _GlobalPositionStrategy;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Builder for overlay position strategy. */
      var _OverlayPositionBuilder = /*#__PURE__*/function () {
        function _OverlayPositionBuilder(_viewportRuler, _document, _platform, _overlayContainer) {
          _classCallCheck(this, _OverlayPositionBuilder);
          this._viewportRuler = _viewportRuler;
          this._document = _document;
          this._platform = _platform;
          this._overlayContainer = _overlayContainer;
        }
        /**
         * Creates a global position strategy.
         */
        _createClass(_OverlayPositionBuilder, [{
          key: "global",
          value: function global() {
            return new _GlobalPositionStrategy();
          }
          /**
           * Creates a relative position strategy.
           * @param elementRef
           * @param originPos
           * @param overlayPos
           * @deprecated Use `flexibleConnectedTo` instead.
           * @breaking-change 8.0.0
           */
        }, {
          key: "connectedTo",
          value: function connectedTo(elementRef, originPos, overlayPos) {
            return new _ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document, this._platform, this._overlayContainer);
          }
          /**
           * Creates a flexible position strategy.
           * @param origin Origin relative to which to position the overlay.
           */
        }, {
          key: "flexibleConnectedTo",
          value: function flexibleConnectedTo(origin) {
            return new _FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
          }
        }]);
        return _OverlayPositionBuilder;
      }();
      _OverlayPositionBuilder.ɵfac = function OverlayPositionBuilder_Factory(t) {
        return new (t || _OverlayPositionBuilder)(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ViewportRuler), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_OverlayContainer));
      };
      _OverlayPositionBuilder.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"]({
        factory: function OverlayPositionBuilder_Factory() {
          return new _OverlayPositionBuilder(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ViewportRuler), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_OverlayContainer));
        },
        token: _OverlayPositionBuilder,
        providedIn: "root"
      });
      _OverlayPositionBuilder.ctorParameters = function () {
        return [{
          type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ViewportRuler
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
          }]
        }, {
          type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
        }, {
          type: _OverlayContainer
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](_OverlayPositionBuilder, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ViewportRuler
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
            }]
          }, {
            type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
          }, {
            type: _OverlayContainer
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Next overlay unique ID. */
      var nextUniqueId = 0;
      // Note that Overlay is *not* scoped to the app root because of the ComponentFactoryResolver
      // which needs to be different depending on where OverlayModule is imported.
      /**
       * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be
       * used as a low-level building block for other components. Dialogs, tooltips, menus,
       * selects, etc. can all be built using overlays. The service should primarily be used by authors
       * of re-usable components rather than developers building end-user applications.
       *
       * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.
       */
      var _Overlay = /*#__PURE__*/function () {
        function _Overlay( /** Scrolling strategies that can be used when creating an overlay. */
        scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location, _outsideClickDispatcher) {
          _classCallCheck(this, _Overlay);
          this.scrollStrategies = scrollStrategies;
          this._overlayContainer = _overlayContainer;
          this._componentFactoryResolver = _componentFactoryResolver;
          this._positionBuilder = _positionBuilder;
          this._keyboardDispatcher = _keyboardDispatcher;
          this._injector = _injector;
          this._ngZone = _ngZone;
          this._document = _document;
          this._directionality = _directionality;
          this._location = _location;
          this._outsideClickDispatcher = _outsideClickDispatcher;
        }
        /**
         * Creates an overlay.
         * @param config Configuration applied to the overlay.
         * @returns Reference to the created overlay.
         */
        _createClass(_Overlay, [{
          key: "create",
          value: function create(config) {
            var host = this._createHostElement();
            var pane = this._createPaneElement(host);
            var portalOutlet = this._createPortalOutlet(pane);
            var overlayConfig = new _OverlayConfig(config);
            overlayConfig.direction = overlayConfig.direction || this._directionality.value;
            return new _OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher);
          }
          /**
           * Gets a position builder that can be used, via fluent API,
           * to construct and configure a position strategy.
           * @returns An overlay position builder.
           */
        }, {
          key: "position",
          value: function position() {
            return this._positionBuilder;
          }
          /**
           * Creates the DOM element for an overlay and appends it to the overlay container.
           * @returns Newly-created pane element
           */
        }, {
          key: "_createPaneElement",
          value: function _createPaneElement(host) {
            var pane = this._document.createElement('div');
            pane.id = "cdk-overlay-".concat(nextUniqueId++);
            pane.classList.add('cdk-overlay-pane');
            host.appendChild(pane);
            return pane;
          }
          /**
           * Creates the host element that wraps around an overlay
           * and can be used for advanced positioning.
           * @returns Newly-create host element.
           */
        }, {
          key: "_createHostElement",
          value: function _createHostElement() {
            var host = this._document.createElement('div');
            this._overlayContainer.getContainerElement().appendChild(host);
            return host;
          }
          /**
           * Create a DomPortalOutlet into which the overlay content can be loaded.
           * @param pane The DOM element to turn into a portal outlet.
           * @returns A portal outlet for the given DOM element.
           */
        }, {
          key: "_createPortalOutlet",
          value: function _createPortalOutlet(pane) {
            // We have to resolve the ApplicationRef later in order to allow people
            // to use overlay-based providers during app initialization.
            if (!this._appRef) {
              this._appRef = this._injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_3__.ApplicationRef);
            }
            return new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__.DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector, this._document);
          }
        }]);
        return _Overlay;
      }();
      _Overlay.ɵfac = function Overlay_Factory(t) {
        return new (t || _Overlay)(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_ScrollStrategyOptions), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_OverlayContainer), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_3__.ComponentFactoryResolver), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_OverlayPositionBuilder), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_OverlayKeyboardDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_3__.Injector), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_3__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__.Directionality), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.Location), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_OverlayOutsideClickDispatcher));
      };
      _Overlay.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"]({
        token: _Overlay,
        factory: _Overlay.ɵfac
      });
      _Overlay.ctorParameters = function () {
        return [{
          type: _ScrollStrategyOptions
        }, {
          type: _OverlayContainer
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.ComponentFactoryResolver
        }, {
          type: _OverlayPositionBuilder
        }, {
          type: _OverlayKeyboardDispatcher
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injector
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.NgZone
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
          }]
        }, {
          type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__.Directionality
        }, {
          type: _angular_common__WEBPACK_IMPORTED_MODULE_4__.Location
        }, {
          type: _OverlayOutsideClickDispatcher
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](_Overlay, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable
        }], function () {
          return [{
            type: _ScrollStrategyOptions
          }, {
            type: _OverlayContainer
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.ComponentFactoryResolver
          }, {
            type: _OverlayPositionBuilder
          }, {
            type: _OverlayKeyboardDispatcher
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injector
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.NgZone
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
            }]
          }, {
            type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__.Directionality
          }, {
            type: _angular_common__WEBPACK_IMPORTED_MODULE_4__.Location
          }, {
            type: _OverlayOutsideClickDispatcher
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Default set of positions for the overlay. Follows the behavior of a dropdown. */
      var defaultPositionList = [{
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top'
      }, {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom'
      }, {
        originX: 'end',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'bottom'
      }, {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'top'
      }];
      /** Injection token that determines the scroll handling while the connected overlay is open. */
      var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_3__.InjectionToken('cdk-connected-overlay-scroll-strategy');
      /**
       * Directive applied to an element to make it usable as an origin for an Overlay using a
       * ConnectedPositionStrategy.
       */
      var _CdkOverlayOrigin = /*#__PURE__*/_createClass(function _CdkOverlayOrigin( /** Reference to the element on which the directive is applied. */
      elementRef) {
        _classCallCheck(this, _CdkOverlayOrigin);
        this.elementRef = elementRef;
      });
      _CdkOverlayOrigin.ɵfac = function CdkOverlayOrigin_Factory(t) {
        return new (t || _CdkOverlayOrigin)(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_3__.ElementRef));
      };
      _CdkOverlayOrigin.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineDirective"]({
        type: _CdkOverlayOrigin,
        selectors: [["", "cdk-overlay-origin", ""], ["", "overlay-origin", ""], ["", "cdkOverlayOrigin", ""]],
        exportAs: ["cdkOverlayOrigin"]
      });
      _CdkOverlayOrigin.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.ElementRef
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](_CdkOverlayOrigin, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Directive,
          args: [{
            selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',
            exportAs: 'cdkOverlayOrigin'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.ElementRef
          }];
        }, null);
      })();
      /**
       * Directive to facilitate declarative creation of an
       * Overlay using a FlexibleConnectedPositionStrategy.
       */
      var _CdkConnectedOverlay = /*#__PURE__*/function () {
        // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.
        function _CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {
          _classCallCheck(this, _CdkConnectedOverlay);
          this._overlay = _overlay;
          this._dir = _dir;
          this._hasBackdrop = false;
          this._lockPosition = false;
          this._growAfterOpen = false;
          this._flexibleDimensions = false;
          this._push = false;
          this._backdropSubscription = rxjs__WEBPACK_IMPORTED_MODULE_6__.Subscription.EMPTY;
          this._attachSubscription = rxjs__WEBPACK_IMPORTED_MODULE_6__.Subscription.EMPTY;
          this._detachSubscription = rxjs__WEBPACK_IMPORTED_MODULE_6__.Subscription.EMPTY;
          this._positionSubscription = rxjs__WEBPACK_IMPORTED_MODULE_6__.Subscription.EMPTY;
          /** Margin between the overlay and the viewport edges. */
          this.viewportMargin = 0;
          /** Whether the overlay is open. */
          this.open = false;
          /** Whether the overlay can be closed by user interaction. */
          this.disableClose = false;
          /** Event emitted when the backdrop is clicked. */
          this.backdropClick = new _angular_core__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
          /** Event emitted when the position has changed. */
          this.positionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
          /** Event emitted when the overlay has been attached. */
          this.attach = new _angular_core__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
          /** Event emitted when the overlay has been detached. */
          this.detach = new _angular_core__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
          /** Emits when there are keyboard events that are targeted at the overlay. */
          this.overlayKeydown = new _angular_core__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
          /** Emits when there are mouse outside click events that are targeted at the overlay. */
          this.overlayOutsideClick = new _angular_core__WEBPACK_IMPORTED_MODULE_3__.EventEmitter();
          this._templatePortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__.TemplatePortal(templateRef, viewContainerRef);
          this._scrollStrategyFactory = scrollStrategyFactory;
          this.scrollStrategy = this._scrollStrategyFactory();
        }
        /** The offset in pixels for the overlay connection point on the x-axis */
        _createClass(_CdkConnectedOverlay, [{
          key: "offsetX",
          get: function get() {
            return this._offsetX;
          },
          set: function set(offsetX) {
            this._offsetX = offsetX;
            if (this._position) {
              this._updatePositionStrategy(this._position);
            }
          }
          /** The offset in pixels for the overlay connection point on the y-axis */
        }, {
          key: "offsetY",
          get: function get() {
            return this._offsetY;
          },
          set: function set(offsetY) {
            this._offsetY = offsetY;
            if (this._position) {
              this._updatePositionStrategy(this._position);
            }
          }
          /** Whether or not the overlay should attach a backdrop. */
        }, {
          key: "hasBackdrop",
          get: function get() {
            return this._hasBackdrop;
          },
          set: function set(value) {
            this._hasBackdrop = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceBooleanProperty)(value);
          }
          /** Whether or not the overlay should be locked when scrolling. */
        }, {
          key: "lockPosition",
          get: function get() {
            return this._lockPosition;
          },
          set: function set(value) {
            this._lockPosition = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceBooleanProperty)(value);
          }
          /** Whether the overlay's width and height can be constrained to fit within the viewport. */
        }, {
          key: "flexibleDimensions",
          get: function get() {
            return this._flexibleDimensions;
          },
          set: function set(value) {
            this._flexibleDimensions = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceBooleanProperty)(value);
          }
          /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */
        }, {
          key: "growAfterOpen",
          get: function get() {
            return this._growAfterOpen;
          },
          set: function set(value) {
            this._growAfterOpen = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceBooleanProperty)(value);
          }
          /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */
        }, {
          key: "push",
          get: function get() {
            return this._push;
          },
          set: function set(value) {
            this._push = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__.coerceBooleanProperty)(value);
          }
          /** The associated overlay reference. */
        }, {
          key: "overlayRef",
          get: function get() {
            return this._overlayRef;
          }
          /** The element's layout direction. */
        }, {
          key: "dir",
          get: function get() {
            return this._dir ? this._dir.value : 'ltr';
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this._attachSubscription.unsubscribe();
            this._detachSubscription.unsubscribe();
            this._backdropSubscription.unsubscribe();
            this._positionSubscription.unsubscribe();
            if (this._overlayRef) {
              this._overlayRef.dispose();
            }
          }
        }, {
          key: "ngOnChanges",
          value: function ngOnChanges(changes) {
            if (this._position) {
              this._updatePositionStrategy(this._position);
              this._overlayRef.updateSize({
                width: this.width,
                minWidth: this.minWidth,
                height: this.height,
                minHeight: this.minHeight
              });
              if (changes['origin'] && this.open) {
                this._position.apply();
              }
            }
            if (changes['open']) {
              this.open ? this._attachOverlay() : this._detachOverlay();
            }
          }
          /** Creates an overlay */
        }, {
          key: "_createOverlay",
          value: function _createOverlay() {
            var _this25 = this;
            if (!this.positions || !this.positions.length) {
              this.positions = defaultPositionList;
            }
            var overlayRef = this._overlayRef = this._overlay.create(this._buildConfig());
            this._attachSubscription = overlayRef.attachments().subscribe(function () {
              return _this25.attach.emit();
            });
            this._detachSubscription = overlayRef.detachments().subscribe(function () {
              return _this25.detach.emit();
            });
            overlayRef.keydownEvents().subscribe(function (event) {
              _this25.overlayKeydown.next(event);
              if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_12__.ESCAPE && !_this25.disableClose && !(0, _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_12__.hasModifierKey)(event)) {
                event.preventDefault();
                _this25._detachOverlay();
              }
            });
            this._overlayRef.outsidePointerEvents().subscribe(function (event) {
              _this25.overlayOutsideClick.next(event);
            });
          }
          /** Builds the overlay config based on the directive's inputs */
        }, {
          key: "_buildConfig",
          value: function _buildConfig() {
            var positionStrategy = this._position = this.positionStrategy || this._createPositionStrategy();
            var overlayConfig = new _OverlayConfig({
              direction: this._dir,
              positionStrategy: positionStrategy,
              scrollStrategy: this.scrollStrategy,
              hasBackdrop: this.hasBackdrop
            });
            if (this.width || this.width === 0) {
              overlayConfig.width = this.width;
            }
            if (this.height || this.height === 0) {
              overlayConfig.height = this.height;
            }
            if (this.minWidth || this.minWidth === 0) {
              overlayConfig.minWidth = this.minWidth;
            }
            if (this.minHeight || this.minHeight === 0) {
              overlayConfig.minHeight = this.minHeight;
            }
            if (this.backdropClass) {
              overlayConfig.backdropClass = this.backdropClass;
            }
            if (this.panelClass) {
              overlayConfig.panelClass = this.panelClass;
            }
            return overlayConfig;
          }
          /** Updates the state of a position strategy, based on the values of the directive inputs. */
        }, {
          key: "_updatePositionStrategy",
          value: function _updatePositionStrategy(positionStrategy) {
            var _this26 = this;
            var positions = this.positions.map(function (currentPosition) {
              return {
                originX: currentPosition.originX,
                originY: currentPosition.originY,
                overlayX: currentPosition.overlayX,
                overlayY: currentPosition.overlayY,
                offsetX: currentPosition.offsetX || _this26.offsetX,
                offsetY: currentPosition.offsetY || _this26.offsetY,
                panelClass: currentPosition.panelClass || undefined
              };
            });
            return positionStrategy.setOrigin(this.origin.elementRef).withPositions(positions).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector);
          }
          /** Returns the position strategy of the overlay to be set on the overlay config */
        }, {
          key: "_createPositionStrategy",
          value: function _createPositionStrategy() {
            var strategy = this._overlay.position().flexibleConnectedTo(this.origin.elementRef);
            this._updatePositionStrategy(strategy);
            return strategy;
          }
          /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */
        }, {
          key: "_attachOverlay",
          value: function _attachOverlay() {
            var _this27 = this;
            if (!this._overlayRef) {
              this._createOverlay();
            } else {
              // Update the overlay size, in case the directive's inputs have changed
              this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;
            }
            if (!this._overlayRef.hasAttached()) {
              this._overlayRef.attach(this._templatePortal);
            }
            if (this.hasBackdrop) {
              this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function (event) {
                _this27.backdropClick.emit(event);
              });
            } else {
              this._backdropSubscription.unsubscribe();
            }
            this._positionSubscription.unsubscribe();
            // Only subscribe to `positionChanges` if requested, because putting
            // together all the information for it can be expensive.
            if (this.positionChange.observers.length > 0) {
              this._positionSubscription = this._position.positionChanges.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.takeWhile)(function () {
                return _this27.positionChange.observers.length > 0;
              })).subscribe(function (position) {
                _this27.positionChange.emit(position);
                if (_this27.positionChange.observers.length === 0) {
                  _this27._positionSubscription.unsubscribe();
                }
              });
            }
          }
          /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */
        }, {
          key: "_detachOverlay",
          value: function _detachOverlay() {
            if (this._overlayRef) {
              this._overlayRef.detach();
            }
            this._backdropSubscription.unsubscribe();
            this._positionSubscription.unsubscribe();
          }
        }]);
        return _CdkConnectedOverlay;
      }();
      _CdkConnectedOverlay.ɵfac = function CdkConnectedOverlay_Factory(t) {
        return new (t || _CdkConnectedOverlay)(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdirectiveInject"](_Overlay), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_3__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_3__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdirectiveInject"](CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdirectiveInject"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__.Directionality, 8));
      };
      _CdkConnectedOverlay.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineDirective"]({
        type: _CdkConnectedOverlay,
        selectors: [["", "cdk-connected-overlay", ""], ["", "connected-overlay", ""], ["", "cdkConnectedOverlay", ""]],
        inputs: {
          viewportMargin: ["cdkConnectedOverlayViewportMargin", "viewportMargin"],
          open: ["cdkConnectedOverlayOpen", "open"],
          disableClose: ["cdkConnectedOverlayDisableClose", "disableClose"],
          scrollStrategy: ["cdkConnectedOverlayScrollStrategy", "scrollStrategy"],
          offsetX: ["cdkConnectedOverlayOffsetX", "offsetX"],
          offsetY: ["cdkConnectedOverlayOffsetY", "offsetY"],
          hasBackdrop: ["cdkConnectedOverlayHasBackdrop", "hasBackdrop"],
          lockPosition: ["cdkConnectedOverlayLockPosition", "lockPosition"],
          flexibleDimensions: ["cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions"],
          growAfterOpen: ["cdkConnectedOverlayGrowAfterOpen", "growAfterOpen"],
          push: ["cdkConnectedOverlayPush", "push"],
          positions: ["cdkConnectedOverlayPositions", "positions"],
          origin: ["cdkConnectedOverlayOrigin", "origin"],
          positionStrategy: ["cdkConnectedOverlayPositionStrategy", "positionStrategy"],
          width: ["cdkConnectedOverlayWidth", "width"],
          height: ["cdkConnectedOverlayHeight", "height"],
          minWidth: ["cdkConnectedOverlayMinWidth", "minWidth"],
          minHeight: ["cdkConnectedOverlayMinHeight", "minHeight"],
          backdropClass: ["cdkConnectedOverlayBackdropClass", "backdropClass"],
          panelClass: ["cdkConnectedOverlayPanelClass", "panelClass"],
          transformOriginSelector: ["cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"]
        },
        outputs: {
          backdropClick: "backdropClick",
          positionChange: "positionChange",
          attach: "attach",
          detach: "detach",
          overlayKeydown: "overlayKeydown",
          overlayOutsideClick: "overlayOutsideClick"
        },
        exportAs: ["cdkConnectedOverlay"],
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵNgOnChangesFeature"]]
      });
      _CdkConnectedOverlay.ctorParameters = function () {
        return [{
          type: _Overlay
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.TemplateRef
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.ViewContainerRef
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
            args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY]
          }]
        }, {
          type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__.Directionality,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Optional
          }]
        }];
      };
      _CdkConnectedOverlay.propDecorators = {
        origin: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayOrigin']
        }],
        positions: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayPositions']
        }],
        positionStrategy: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayPositionStrategy']
        }],
        offsetX: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayOffsetX']
        }],
        offsetY: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayOffsetY']
        }],
        width: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayWidth']
        }],
        height: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayHeight']
        }],
        minWidth: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayMinWidth']
        }],
        minHeight: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayMinHeight']
        }],
        backdropClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayBackdropClass']
        }],
        panelClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayPanelClass']
        }],
        viewportMargin: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayViewportMargin']
        }],
        scrollStrategy: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayScrollStrategy']
        }],
        open: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayOpen']
        }],
        disableClose: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayDisableClose']
        }],
        transformOriginSelector: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayTransformOriginOn']
        }],
        hasBackdrop: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayHasBackdrop']
        }],
        lockPosition: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayLockPosition']
        }],
        flexibleDimensions: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayFlexibleDimensions']
        }],
        growAfterOpen: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayGrowAfterOpen']
        }],
        push: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
          args: ['cdkConnectedOverlayPush']
        }],
        backdropClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
        }],
        positionChange: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
        }],
        attach: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
        }],
        detach: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
        }],
        overlayKeydown: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
        }],
        overlayOutsideClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
        }]
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](_CdkConnectedOverlay, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Directive,
          args: [{
            selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',
            exportAs: 'cdkConnectedOverlay'
          }]
        }], function () {
          return [{
            type: _Overlay
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.TemplateRef
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.ViewContainerRef
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
              args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY]
            }]
          }, {
            type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__.Directionality,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Optional
            }]
          }];
        }, {
          viewportMargin: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayViewportMargin']
          }],
          open: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayOpen']
          }],
          disableClose: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayDisableClose']
          }],
          backdropClick: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
          }],
          positionChange: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
          }],
          attach: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
          }],
          detach: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
          }],
          overlayKeydown: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
          }],
          overlayOutsideClick: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Output
          }],
          scrollStrategy: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayScrollStrategy']
          }],
          offsetX: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayOffsetX']
          }],
          offsetY: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayOffsetY']
          }],
          hasBackdrop: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayHasBackdrop']
          }],
          lockPosition: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayLockPosition']
          }],
          flexibleDimensions: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayFlexibleDimensions']
          }],
          growAfterOpen: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayGrowAfterOpen']
          }],
          push: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayPush']
          }],
          positions: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayPositions']
          }],
          origin: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayOrigin']
          }],
          positionStrategy: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayPositionStrategy']
          }],
          width: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayWidth']
          }],
          height: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayHeight']
          }],
          minWidth: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayMinWidth']
          }],
          minHeight: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayMinHeight']
          }],
          backdropClass: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayBackdropClass']
          }],
          panelClass: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayPanelClass']
          }],
          transformOriginSelector: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Input,
            args: ['cdkConnectedOverlayTransformOriginOn']
          }]
        });
      })();
      /** @docs-private */
      function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
        return function () {
          return overlay.scrollStrategies.reposition();
        };
      }
      /** @docs-private */
      var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
        provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,
        deps: [_Overlay],
        useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY
      };

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      var _OverlayModule = /*#__PURE__*/_createClass(function _OverlayModule() {
        _classCallCheck(this, _OverlayModule);
      });
      _OverlayModule.ɵfac = function OverlayModule_Factory(t) {
        return new (t || _OverlayModule)();
      };
      _OverlayModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineNgModule"]({
        type: _OverlayModule
      });
      _OverlayModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjector"]({
        providers: [_Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER],
        imports: [[_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__.BidiModule, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__.PortalModule, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ScrollingModule], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ScrollingModule]
      });
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](_OverlayModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.NgModule,
          args: [{
            imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__.BidiModule, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__.PortalModule, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ScrollingModule],
            exports: [_CdkConnectedOverlay, _CdkOverlayOrigin, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ScrollingModule],
            declarations: [_CdkConnectedOverlay, _CdkOverlayOrigin],
            providers: [_Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER]
          }]
        }], null, null);
      })();
      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵsetNgModuleScope"](_OverlayModule, {
          declarations: function declarations() {
            return [_CdkConnectedOverlay, _CdkOverlayOrigin];
          },
          imports: function imports() {
            return [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__.BidiModule, _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__.PortalModule, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ScrollingModule];
          },
          exports: function exports() {
            return [_CdkConnectedOverlay, _CdkOverlayOrigin, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_0__.ScrollingModule];
          }
        });
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Alternative to OverlayContainer that supports correct displaying of overlay elements in
       * Fullscreen mode
       * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen
       *
       * Should be provided in the root component.
       */
      var _FullscreenOverlayContainer = /*#__PURE__*/function (_OverlayContainer2) {
        _inherits(_FullscreenOverlayContainer, _OverlayContainer2);
        var _super4 = _createSuper(_FullscreenOverlayContainer);
        function _FullscreenOverlayContainer(_document, platform) {
          _classCallCheck(this, _FullscreenOverlayContainer);
          return _super4.call(this, _document, platform);
        }
        _createClass(_FullscreenOverlayContainer, [{
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            _get(_getPrototypeOf(_FullscreenOverlayContainer.prototype), "ngOnDestroy", this).call(this);
            if (this._fullScreenEventName && this._fullScreenListener) {
              this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);
            }
          }
        }, {
          key: "_createContainer",
          value: function _createContainer() {
            var _this28 = this;
            _get(_getPrototypeOf(_FullscreenOverlayContainer.prototype), "_createContainer", this).call(this);
            this._adjustParentForFullscreenChange();
            this._addFullscreenChangeListener(function () {
              return _this28._adjustParentForFullscreenChange();
            });
          }
        }, {
          key: "_adjustParentForFullscreenChange",
          value: function _adjustParentForFullscreenChange() {
            if (!this._containerElement) {
              return;
            }
            var fullscreenElement = this.getFullscreenElement();
            var parent = fullscreenElement || this._document.body;
            parent.appendChild(this._containerElement);
          }
        }, {
          key: "_addFullscreenChangeListener",
          value: function _addFullscreenChangeListener(fn) {
            var eventName = this._getEventName();
            if (eventName) {
              if (this._fullScreenListener) {
                this._document.removeEventListener(eventName, this._fullScreenListener);
              }
              this._document.addEventListener(eventName, fn);
              this._fullScreenListener = fn;
            }
          }
        }, {
          key: "_getEventName",
          value: function _getEventName() {
            if (!this._fullScreenEventName) {
              var _document = this._document;
              if (_document.fullscreenEnabled) {
                this._fullScreenEventName = 'fullscreenchange';
              } else if (_document.webkitFullscreenEnabled) {
                this._fullScreenEventName = 'webkitfullscreenchange';
              } else if (_document.mozFullScreenEnabled) {
                this._fullScreenEventName = 'mozfullscreenchange';
              } else if (_document.msFullscreenEnabled) {
                this._fullScreenEventName = 'MSFullscreenChange';
              }
            }
            return this._fullScreenEventName;
          }
          /**
           * When the page is put into fullscreen mode, a specific element is specified.
           * Only that element and its children are visible when in fullscreen mode.
           */
        }, {
          key: "getFullscreenElement",
          value: function getFullscreenElement() {
            var _document = this._document;
            return _document.fullscreenElement || _document.webkitFullscreenElement || _document.mozFullScreenElement || _document.msFullscreenElement || null;
          }
        }]);
        return _FullscreenOverlayContainer;
      }(_OverlayContainer);
      _FullscreenOverlayContainer.ɵfac = function FullscreenOverlayContainer_Factory(t) {
        return new (t || _FullscreenOverlayContainer)(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform));
      };
      _FullscreenOverlayContainer.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵdefineInjectable"]({
        factory: function FullscreenOverlayContainer_Factory() {
          return new _FullscreenOverlayContainer(_angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform));
        },
        token: _FullscreenOverlayContainer,
        providedIn: "root"
      });
      _FullscreenOverlayContainer.ctorParameters = function () {
        return [{
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
          }]
        }, {
          type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__["ɵsetClassMetadata"](_FullscreenOverlayContainer, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_3__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]
            }]
          }, {
            type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/
    },

    /***/40912:
    /*!*******************************************************************!*\
      !*** ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/portal.js ***!
      \*******************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"BasePortalHost": function BasePortalHost() {
          return (/* binding */_BasePortalHost
          );
        },
        /* harmony export */"BasePortalOutlet": function BasePortalOutlet() {
          return (/* binding */_BasePortalOutlet
          );
        },
        /* harmony export */"CdkPortal": function CdkPortal() {
          return (/* binding */_CdkPortal
          );
        },
        /* harmony export */"CdkPortalOutlet": function CdkPortalOutlet() {
          return (/* binding */_CdkPortalOutlet
          );
        },
        /* harmony export */"ComponentPortal": function ComponentPortal() {
          return (/* binding */_ComponentPortal
          );
        },
        /* harmony export */"DomPortal": function DomPortal() {
          return (/* binding */_DomPortal
          );
        },
        /* harmony export */"DomPortalHost": function DomPortalHost() {
          return (/* binding */_DomPortalHost
          );
        },
        /* harmony export */"DomPortalOutlet": function DomPortalOutlet() {
          return (/* binding */_DomPortalOutlet
          );
        },
        /* harmony export */"Portal": function Portal() {
          return (/* binding */_Portal
          );
        },
        /* harmony export */"PortalHostDirective": function PortalHostDirective() {
          return (/* binding */_PortalHostDirective
          );
        },
        /* harmony export */"PortalInjector": function PortalInjector() {
          return (/* binding */_PortalInjector
          );
        },
        /* harmony export */"PortalModule": function PortalModule() {
          return (/* binding */_PortalModule
          );
        },
        /* harmony export */"TemplatePortal": function TemplatePortal() {
          return (/* binding */_TemplatePortal
          );
        },
        /* harmony export */"TemplatePortalDirective": function TemplatePortalDirective() {
          return (/* binding */_TemplatePortalDirective
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @angular/core */2316);
      /* harmony import */
      var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/common */54364);

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Throws an exception when attempting to attach a null portal to a host.
       * @docs-private
       */

      function throwNullPortalError() {
        throw Error('Must provide a portal to attach');
      }
      /**
       * Throws an exception when attempting to attach a portal to a host that is already attached.
       * @docs-private
       */
      function throwPortalAlreadyAttachedError() {
        throw Error('Host already has a portal attached');
      }
      /**
       * Throws an exception when attempting to attach a portal to an already-disposed host.
       * @docs-private
       */
      function throwPortalOutletAlreadyDisposedError() {
        throw Error('This PortalOutlet has already been disposed');
      }
      /**
       * Throws an exception when attempting to attach an unknown portal type.
       * @docs-private
       */
      function throwUnknownPortalTypeError() {
        throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' + 'a ComponentPortal or a TemplatePortal.');
      }
      /**
       * Throws an exception when attempting to attach a portal to a null host.
       * @docs-private
       */
      function throwNullPortalOutletError() {
        throw Error('Attempting to attach a portal to a null PortalOutlet');
      }
      /**
       * Throws an exception when attempting to detach a portal that is not attached.
       * @docs-private
       */
      function throwNoPortalAttachedError() {
        throw Error('Attempting to detach a portal that is not attached to a host');
      }

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * A `Portal` is something that you want to render somewhere else.
       * It can be attach to / detached from a `PortalOutlet`.
       */
      var _Portal = /*#__PURE__*/function () {
        function _Portal() {
          _classCallCheck(this, _Portal);
        }
        _createClass(_Portal, [{
          key: "attach",
          value: /** Attach this portal to a host. */
          function attach(host) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
              if (host == null) {
                throwNullPortalOutletError();
              }
              if (host.hasAttached()) {
                throwPortalAlreadyAttachedError();
              }
            }
            this._attachedHost = host;
            return host.attach(this);
          }
          /** Detach this portal from its host */
        }, {
          key: "detach",
          value: function detach() {
            var host = this._attachedHost;
            if (host != null) {
              this._attachedHost = null;
              host.detach();
            } else if (typeof ngDevMode === 'undefined' || ngDevMode) {
              throwNoPortalAttachedError();
            }
          }
          /** Whether this portal is attached to a host. */
        }, {
          key: "isAttached",
          get: function get() {
            return this._attachedHost != null;
          }
          /**
           * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
           * the PortalOutlet when it is performing an `attach()` or `detach()`.
           */
        }, {
          key: "setAttachedHost",
          value: function setAttachedHost(host) {
            this._attachedHost = host;
          }
        }]);
        return _Portal;
      }();
      /**
       * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
       */
      var _ComponentPortal = /*#__PURE__*/function (_Portal2) {
        _inherits(_ComponentPortal, _Portal2);
        var _super5 = _createSuper(_ComponentPortal);
        function _ComponentPortal(component, viewContainerRef, injector, componentFactoryResolver) {
          var _this29;
          _classCallCheck(this, _ComponentPortal);
          _this29 = _super5.call(this);
          _this29.component = component;
          _this29.viewContainerRef = viewContainerRef;
          _this29.injector = injector;
          _this29.componentFactoryResolver = componentFactoryResolver;
          return _this29;
        }
        return _createClass(_ComponentPortal);
      }(_Portal);
      /**
       * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
       */
      var _TemplatePortal = /*#__PURE__*/function (_Portal3) {
        _inherits(_TemplatePortal, _Portal3);
        var _super6 = _createSuper(_TemplatePortal);
        function _TemplatePortal(template, viewContainerRef, context) {
          var _this30;
          _classCallCheck(this, _TemplatePortal);
          _this30 = _super6.call(this);
          _this30.templateRef = template;
          _this30.viewContainerRef = viewContainerRef;
          _this30.context = context;
          return _this30;
        }
        _createClass(_TemplatePortal, [{
          key: "origin",
          get: function get() {
            return this.templateRef.elementRef;
          }
          /**
           * Attach the portal to the provided `PortalOutlet`.
           * When a context is provided it will override the `context` property of the `TemplatePortal`
           * instance.
           */
        }, {
          key: "attach",
          value: function attach(host) {
            var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;
            this.context = context;
            return _get(_getPrototypeOf(_TemplatePortal.prototype), "attach", this).call(this, host);
          }
        }, {
          key: "detach",
          value: function detach() {
            this.context = undefined;
            return _get(_getPrototypeOf(_TemplatePortal.prototype), "detach", this).call(this);
          }
        }]);
        return _TemplatePortal;
      }(_Portal);
      /**
       * A `DomPortal` is a portal whose DOM element will be taken from its current position
       * in the DOM and moved into a portal outlet, when it is attached. On detach, the content
       * will be restored to its original position.
       */
      var _DomPortal = /*#__PURE__*/function (_Portal4) {
        _inherits(_DomPortal, _Portal4);
        var _super7 = _createSuper(_DomPortal);
        function _DomPortal(element) {
          var _this31;
          _classCallCheck(this, _DomPortal);
          _this31 = _super7.call(this);
          _this31.element = element instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef ? element.nativeElement : element;
          return _this31;
        }
        return _createClass(_DomPortal);
      }(_Portal);
      /**
       * Partial implementation of PortalOutlet that handles attaching
       * ComponentPortal and TemplatePortal.
       */
      var _BasePortalOutlet = /*#__PURE__*/function () {
        function _BasePortalOutlet() {
          _classCallCheck(this, _BasePortalOutlet);
          /** Whether this host has already been permanently disposed. */
          this._isDisposed = false;
          // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.
          this.attachDomPortal = null;
        }
        /** Whether this host has an attached portal. */
        _createClass(_BasePortalOutlet, [{
          key: "hasAttached",
          value: function hasAttached() {
            return !!this._attachedPortal;
          }
          /** Attaches a portal. */
        }, {
          key: "attach",
          value: function attach(portal) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
              if (!portal) {
                throwNullPortalError();
              }
              if (this.hasAttached()) {
                throwPortalAlreadyAttachedError();
              }
              if (this._isDisposed) {
                throwPortalOutletAlreadyDisposedError();
              }
            }
            if (portal instanceof _ComponentPortal) {
              this._attachedPortal = portal;
              return this.attachComponentPortal(portal);
            } else if (portal instanceof _TemplatePortal) {
              this._attachedPortal = portal;
              return this.attachTemplatePortal(portal);
              // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.
            } else if (this.attachDomPortal && portal instanceof _DomPortal) {
              this._attachedPortal = portal;
              return this.attachDomPortal(portal);
            }
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
              throwUnknownPortalTypeError();
            }
          }
          /** Detaches a previously attached portal. */
        }, {
          key: "detach",
          value: function detach() {
            if (this._attachedPortal) {
              this._attachedPortal.setAttachedHost(null);
              this._attachedPortal = null;
            }
            this._invokeDisposeFn();
          }
          /** Permanently dispose of this portal host. */
        }, {
          key: "dispose",
          value: function dispose() {
            if (this.hasAttached()) {
              this.detach();
            }
            this._invokeDisposeFn();
            this._isDisposed = true;
          }
          /** @docs-private */
        }, {
          key: "setDisposeFn",
          value: function setDisposeFn(fn) {
            this._disposeFn = fn;
          }
        }, {
          key: "_invokeDisposeFn",
          value: function _invokeDisposeFn() {
            if (this._disposeFn) {
              this._disposeFn();
              this._disposeFn = null;
            }
          }
        }]);
        return _BasePortalOutlet;
      }();
      /**
       * @deprecated Use `BasePortalOutlet` instead.
       * @breaking-change 9.0.0
       */
      var _BasePortalHost = /*#__PURE__*/function (_BasePortalOutlet2) {
        _inherits(_BasePortalHost, _BasePortalOutlet2);
        var _super8 = _createSuper(_BasePortalHost);
        function _BasePortalHost() {
          _classCallCheck(this, _BasePortalHost);
          return _super8.apply(this, arguments);
        }
        return _createClass(_BasePortalHost);
      }(_BasePortalOutlet);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
       * application context.
       */
      var _DomPortalOutlet = /*#__PURE__*/function (_BasePortalOutlet3) {
        _inherits(_DomPortalOutlet, _BasePortalOutlet3);
        var _super9 = _createSuper(_DomPortalOutlet);
        function _DomPortalOutlet( /** Element into which the content is projected. */
        outletElement, _componentFactoryResolver, _appRef, _defaultInjector,
        /**
         * @deprecated `_document` Parameter to be made required.
         * @breaking-change 10.0.0
         */
        _document) {
          var _thisSuper, _this32;
          _classCallCheck(this, _DomPortalOutlet);
          _this32 = _super9.call(this);
          _this32.outletElement = outletElement;
          _this32._componentFactoryResolver = _componentFactoryResolver;
          _this32._appRef = _appRef;
          _this32._defaultInjector = _defaultInjector;
          /**
           * Attaches a DOM portal by transferring its content into the outlet.
           * @param portal Portal to be attached.
           * @deprecated To be turned into a method.
           * @breaking-change 10.0.0
           */
          _this32.attachDomPortal = function (portal) {
            // @breaking-change 10.0.0 Remove check and error once the
            // `_document` constructor parameter is required.
            if (!_this32._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw Error('Cannot attach DOM portal without _document constructor parameter');
            }
            var element = portal.element;
            if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw Error('DOM portal content must be attached to a parent node.');
            }
            // Anchor used to save the element's previous position so
            // that we can restore it when the portal is detached.
            var anchorNode = _this32._document.createComment('dom-portal');
            element.parentNode.insertBefore(anchorNode, element);
            _this32.outletElement.appendChild(element);
            _this32._attachedPortal = portal;
            _get((_thisSuper = _assertThisInitialized(_this32), _getPrototypeOf(_DomPortalOutlet.prototype)), "setDisposeFn", _thisSuper).call(_thisSuper, function () {
              // We can't use `replaceWith` here because IE doesn't support it.
              if (anchorNode.parentNode) {
                anchorNode.parentNode.replaceChild(element, anchorNode);
              }
            });
          };
          _this32._document = _document;
          return _this32;
        }
        /**
         * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
         * @param portal Portal to be attached
         * @returns Reference to the created component.
         */
        _createClass(_DomPortalOutlet, [{
          key: "attachComponentPortal",
          value: function attachComponentPortal(portal) {
            var _this33 = this;
            var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
            var componentFactory = resolver.resolveComponentFactory(portal.component);
            var componentRef;
            // If the portal specifies a ViewContainerRef, we will use that as the attachment point
            // for the component (in terms of Angular's component tree, not rendering).
            // When the ViewContainerRef is missing, we use the factory to create the component directly
            // and then manually attach the view to the application.
            if (portal.viewContainerRef) {
              componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);
              this.setDisposeFn(function () {
                return componentRef.destroy();
              });
            } else {
              componentRef = componentFactory.create(portal.injector || this._defaultInjector);
              this._appRef.attachView(componentRef.hostView);
              this.setDisposeFn(function () {
                _this33._appRef.detachView(componentRef.hostView);
                componentRef.destroy();
              });
            }
            // At this point the component has been instantiated, so we move it to the location in the DOM
            // where we want it to be rendered.
            this.outletElement.appendChild(this._getComponentRootNode(componentRef));
            this._attachedPortal = portal;
            return componentRef;
          }
          /**
           * Attaches a template portal to the DOM as an embedded view.
           * @param portal Portal to be attached.
           * @returns Reference to the created embedded view.
           */
        }, {
          key: "attachTemplatePortal",
          value: function attachTemplatePortal(portal) {
            var _this34 = this;
            var viewContainer = portal.viewContainerRef;
            var viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);
            // The method `createEmbeddedView` will add the view as a child of the viewContainer.
            // But for the DomPortalOutlet the view can be added everywhere in the DOM
            // (e.g Overlay Container) To move the view to the specified host element. We just
            // re-append the existing root nodes.
            viewRef.rootNodes.forEach(function (rootNode) {
              return _this34.outletElement.appendChild(rootNode);
            });
            // Note that we want to detect changes after the nodes have been moved so that
            // any directives inside the portal that are looking at the DOM inside a lifecycle
            // hook won't be invoked too early.
            viewRef.detectChanges();
            this.setDisposeFn(function () {
              var index = viewContainer.indexOf(viewRef);
              if (index !== -1) {
                viewContainer.remove(index);
              }
            });
            this._attachedPortal = portal;
            // TODO(jelbourn): Return locals from view.
            return viewRef;
          }
          /**
           * Clears out a portal from the DOM.
           */
        }, {
          key: "dispose",
          value: function dispose() {
            _get(_getPrototypeOf(_DomPortalOutlet.prototype), "dispose", this).call(this);
            if (this.outletElement.parentNode != null) {
              this.outletElement.parentNode.removeChild(this.outletElement);
            }
          }
          /** Gets the root HTMLElement for an instantiated component. */
        }, {
          key: "_getComponentRootNode",
          value: function _getComponentRootNode(componentRef) {
            return componentRef.hostView.rootNodes[0];
          }
        }]);
        return _DomPortalOutlet;
      }(_BasePortalOutlet);
      /**
       * @deprecated Use `DomPortalOutlet` instead.
       * @breaking-change 9.0.0
       */
      var _DomPortalHost = /*#__PURE__*/function (_DomPortalOutlet2) {
        _inherits(_DomPortalHost, _DomPortalOutlet2);
        var _super10 = _createSuper(_DomPortalHost);
        function _DomPortalHost() {
          _classCallCheck(this, _DomPortalHost);
          return _super10.apply(this, arguments);
        }
        return _createClass(_DomPortalHost);
      }(_DomPortalOutlet);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,
       * the directive instance itself can be attached to a host, enabling declarative use of portals.
       */
      var _CdkPortal = /*#__PURE__*/function (_TemplatePortal2) {
        _inherits(_CdkPortal, _TemplatePortal2);
        var _super11 = _createSuper(_CdkPortal);
        function _CdkPortal(templateRef, viewContainerRef) {
          _classCallCheck(this, _CdkPortal);
          return _super11.call(this, templateRef, viewContainerRef);
        }
        return _createClass(_CdkPortal);
      }(_TemplatePortal);
      _CdkPortal.ɵfac = function CdkPortal_Factory(t) {
        return new (t || _CdkPortal)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef));
      };
      _CdkPortal.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: _CdkPortal,
        selectors: [["", "cdkPortal", ""]],
        exportAs: ["cdkPortal"],
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
      });
      _CdkPortal.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_CdkPortal, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[cdkPortal]',
            exportAs: 'cdkPortal'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef
          }];
        }, null);
      })();
      /**
       * @deprecated Use `CdkPortal` instead.
       * @breaking-change 9.0.0
       */
      var _TemplatePortalDirective = /*#__PURE__*/function (_CdkPortal2) {
        _inherits(_TemplatePortalDirective, _CdkPortal2);
        var _super12 = _createSuper(_TemplatePortalDirective);
        function _TemplatePortalDirective() {
          _classCallCheck(this, _TemplatePortalDirective);
          return _super12.apply(this, arguments);
        }
        return _createClass(_TemplatePortalDirective);
      }(_CdkPortal);
      _TemplatePortalDirective.ɵfac = /*@__PURE__*/function () {
        var ɵTemplatePortalDirective_BaseFactory;
        return function TemplatePortalDirective_Factory(t) {
          return (ɵTemplatePortalDirective_BaseFactory || (ɵTemplatePortalDirective_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](_TemplatePortalDirective)))(t || _TemplatePortalDirective);
        };
      }();
      _TemplatePortalDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: _TemplatePortalDirective,
        selectors: [["", "cdk-portal", ""], ["", "portal", ""]],
        exportAs: ["cdkPortal"],
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
          provide: _CdkPortal,
          useExisting: _TemplatePortalDirective
        }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
      });
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_TemplatePortalDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[cdk-portal], [portal]',
            exportAs: 'cdkPortal',
            providers: [{
              provide: _CdkPortal,
              useExisting: _TemplatePortalDirective
            }]
          }]
        }], null, null);
      })();
      /**
       * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be
       * directly attached to it, enabling declarative use.
       *
       * Usage:
       * `<ng-template [cdkPortalOutlet]="greeting"></ng-template>`
       */
      var _CdkPortalOutlet = /*#__PURE__*/function (_BasePortalOutlet4) {
        _inherits(_CdkPortalOutlet, _BasePortalOutlet4);
        var _super13 = _createSuper(_CdkPortalOutlet);
        function _CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef,
        /**
         * @deprecated `_document` parameter to be made required.
         * @breaking-change 9.0.0
         */
        _document) {
          var _thisSuper2, _this35;
          _classCallCheck(this, _CdkPortalOutlet);
          _this35 = _super13.call(this);
          _this35._componentFactoryResolver = _componentFactoryResolver;
          _this35._viewContainerRef = _viewContainerRef;
          /** Whether the portal component is initialized. */
          _this35._isInitialized = false;
          /** Emits when a portal is attached to the outlet. */
          _this35.attached = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.
           * @param portal Portal to be attached.
           * @deprecated To be turned into a method.
           * @breaking-change 10.0.0
           */
          _this35.attachDomPortal = function (portal) {
            // @breaking-change 9.0.0 Remove check and error once the
            // `_document` constructor parameter is required.
            if (!_this35._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw Error('Cannot attach DOM portal without _document constructor parameter');
            }
            var element = portal.element;
            if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw Error('DOM portal content must be attached to a parent node.');
            }
            // Anchor used to save the element's previous position so
            // that we can restore it when the portal is detached.
            var anchorNode = _this35._document.createComment('dom-portal');
            portal.setAttachedHost(_assertThisInitialized(_this35));
            element.parentNode.insertBefore(anchorNode, element);
            _this35._getRootNode().appendChild(element);
            _this35._attachedPortal = portal;
            _get((_thisSuper2 = _assertThisInitialized(_this35), _getPrototypeOf(_CdkPortalOutlet.prototype)), "setDisposeFn", _thisSuper2).call(_thisSuper2, function () {
              if (anchorNode.parentNode) {
                anchorNode.parentNode.replaceChild(element, anchorNode);
              }
            });
          };
          _this35._document = _document;
          return _this35;
        }
        /** Portal associated with the Portal outlet. */
        _createClass(_CdkPortalOutlet, [{
          key: "portal",
          get: function get() {
            return this._attachedPortal;
          },
          set: function set(portal) {
            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have
            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`
            // and attach a portal programmatically in the parent component. When Angular does the first CD
            // round, it will fire the setter with empty string, causing the user's content to be cleared.
            if (this.hasAttached() && !portal && !this._isInitialized) {
              return;
            }
            if (this.hasAttached()) {
              _get(_getPrototypeOf(_CdkPortalOutlet.prototype), "detach", this).call(this);
            }
            if (portal) {
              _get(_getPrototypeOf(_CdkPortalOutlet.prototype), "attach", this).call(this, portal);
            }
            this._attachedPortal = portal;
          }
          /** Component or view reference that is attached to the portal. */
        }, {
          key: "attachedRef",
          get: function get() {
            return this._attachedRef;
          }
        }, {
          key: "ngOnInit",
          value: function ngOnInit() {
            this._isInitialized = true;
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            _get(_getPrototypeOf(_CdkPortalOutlet.prototype), "dispose", this).call(this);
            this._attachedPortal = null;
            this._attachedRef = null;
          }
          /**
           * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
           *
           * @param portal Portal to be attached to the portal outlet.
           * @returns Reference to the created component.
           */
        }, {
          key: "attachComponentPortal",
          value: function attachComponentPortal(portal) {
            portal.setAttachedHost(this);
            // If the portal specifies an origin, use that as the logical location of the component
            // in the application tree. Otherwise use the location of this PortalOutlet.
            var viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;
            var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
            var componentFactory = resolver.resolveComponentFactory(portal.component);
            var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);
            // If we're using a view container that's different from the injected one (e.g. when the portal
            // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered
            // inside of the alternate view container.
            if (viewContainerRef !== this._viewContainerRef) {
              this._getRootNode().appendChild(ref.hostView.rootNodes[0]);
            }
            _get(_getPrototypeOf(_CdkPortalOutlet.prototype), "setDisposeFn", this).call(this, function () {
              return ref.destroy();
            });
            this._attachedPortal = portal;
            this._attachedRef = ref;
            this.attached.emit(ref);
            return ref;
          }
          /**
           * Attach the given TemplatePortal to this PortalHost as an embedded View.
           * @param portal Portal to be attached.
           * @returns Reference to the created embedded view.
           */
        }, {
          key: "attachTemplatePortal",
          value: function attachTemplatePortal(portal) {
            var _this36 = this;
            portal.setAttachedHost(this);
            var viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);
            _get(_getPrototypeOf(_CdkPortalOutlet.prototype), "setDisposeFn", this).call(this, function () {
              return _this36._viewContainerRef.clear();
            });
            this._attachedPortal = portal;
            this._attachedRef = viewRef;
            this.attached.emit(viewRef);
            return viewRef;
          }
          /** Gets the root node of the portal outlet. */
        }, {
          key: "_getRootNode",
          value: function _getRootNode() {
            var nativeElement = this._viewContainerRef.element.nativeElement;
            // The directive could be set on a template which will result in a comment
            // node being the root. Use the comment's parent node if that is the case.
            return nativeElement.nodeType === nativeElement.ELEMENT_NODE ? nativeElement : nativeElement.parentNode;
          }
        }]);
        return _CdkPortalOutlet;
      }(_BasePortalOutlet);
      _CdkPortalOutlet.ɵfac = function CdkPortalOutlet_Factory(t) {
        return new (t || _CdkPortalOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentFactoryResolver), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT));
      };
      _CdkPortalOutlet.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: _CdkPortalOutlet,
        selectors: [["", "cdkPortalOutlet", ""]],
        inputs: {
          portal: ["cdkPortalOutlet", "portal"]
        },
        outputs: {
          attached: "attached"
        },
        exportAs: ["cdkPortalOutlet"],
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
      });
      _CdkPortalOutlet.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentFactoryResolver
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT]
          }]
        }];
      };
      _CdkPortalOutlet.propDecorators = {
        attached: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }]
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_CdkPortalOutlet, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[cdkPortalOutlet]',
            exportAs: 'cdkPortalOutlet',
            inputs: ['portal: cdkPortalOutlet']
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentFactoryResolver
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT]
            }]
          }];
        }, {
          attached: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }]
        });
      })();
      /**
       * @deprecated Use `CdkPortalOutlet` instead.
       * @breaking-change 9.0.0
       */
      var _PortalHostDirective = /*#__PURE__*/function (_CdkPortalOutlet2) {
        _inherits(_PortalHostDirective, _CdkPortalOutlet2);
        var _super14 = _createSuper(_PortalHostDirective);
        function _PortalHostDirective() {
          _classCallCheck(this, _PortalHostDirective);
          return _super14.apply(this, arguments);
        }
        return _createClass(_PortalHostDirective);
      }(_CdkPortalOutlet);
      _PortalHostDirective.ɵfac = /*@__PURE__*/function () {
        var ɵPortalHostDirective_BaseFactory;
        return function PortalHostDirective_Factory(t) {
          return (ɵPortalHostDirective_BaseFactory || (ɵPortalHostDirective_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](_PortalHostDirective)))(t || _PortalHostDirective);
        };
      }();
      _PortalHostDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: _PortalHostDirective,
        selectors: [["", "cdkPortalHost", ""], ["", "portalHost", ""]],
        inputs: {
          portal: ["cdkPortalHost", "portal"]
        },
        exportAs: ["cdkPortalHost"],
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
          provide: _CdkPortalOutlet,
          useExisting: _PortalHostDirective
        }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]]
      });
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_PortalHostDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[cdkPortalHost], [portalHost]',
            exportAs: 'cdkPortalHost',
            inputs: ['portal: cdkPortalHost'],
            providers: [{
              provide: _CdkPortalOutlet,
              useExisting: _PortalHostDirective
            }]
          }]
        }], null, null);
      })();
      var _PortalModule = /*#__PURE__*/_createClass(function _PortalModule() {
        _classCallCheck(this, _PortalModule);
      });
      _PortalModule.ɵfac = function PortalModule_Factory(t) {
        return new (t || _PortalModule)();
      };
      _PortalModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
        type: _PortalModule
      });
      _PortalModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_PortalModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
          args: [{
            exports: [_CdkPortal, _CdkPortalOutlet, _TemplatePortalDirective, _PortalHostDirective],
            declarations: [_CdkPortal, _CdkPortalOutlet, _TemplatePortalDirective, _PortalHostDirective]
          }]
        }], null, null);
      })();
      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_PortalModule, {
          declarations: [_CdkPortal, _CdkPortalOutlet, _TemplatePortalDirective, _PortalHostDirective],
          exports: [_CdkPortal, _CdkPortalOutlet, _TemplatePortalDirective, _PortalHostDirective]
        });
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Custom injector to be used when providing custom
       * injection tokens to components inside a portal.
       * @docs-private
       * @deprecated Use `Injector.create` instead.
       * @breaking-change 11.0.0
       */
      var _PortalInjector = /*#__PURE__*/function () {
        function _PortalInjector(_parentInjector, _customTokens) {
          _classCallCheck(this, _PortalInjector);
          this._parentInjector = _parentInjector;
          this._customTokens = _customTokens;
        }
        _createClass(_PortalInjector, [{
          key: "get",
          value: function get(token, notFoundValue) {
            var value = this._customTokens.get(token);
            if (typeof value !== 'undefined') {
              return value;
            }
            return this._parentInjector.get(token, notFoundValue);
          }
        }]);
        return _PortalInjector;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Generated bundle index. Do not edit.
       */
      /***/
    },
    /***/42791:
    /*!**********************************************************************!*\
      !*** ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/scrolling.js ***!
      \**********************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"CdkFixedSizeVirtualScroll": function CdkFixedSizeVirtualScroll() {
          return (/* binding */_CdkFixedSizeVirtualScroll
          );
        },
        /* harmony export */"CdkScrollable": function CdkScrollable() {
          return (/* binding */_CdkScrollable
          );
        },
        /* harmony export */"CdkScrollableModule": function CdkScrollableModule() {
          return (/* binding */_CdkScrollableModule
          );
        },
        /* harmony export */"CdkVirtualForOf": function CdkVirtualForOf() {
          return (/* binding */_CdkVirtualForOf
          );
        },
        /* harmony export */"CdkVirtualScrollViewport": function CdkVirtualScrollViewport() {
          return (/* binding */_CdkVirtualScrollViewport
          );
        },
        /* harmony export */"DEFAULT_RESIZE_TIME": function DEFAULT_RESIZE_TIME() {
          return (/* binding */_DEFAULT_RESIZE_TIME
          );
        },
        /* harmony export */"DEFAULT_SCROLL_TIME": function DEFAULT_SCROLL_TIME() {
          return (/* binding */_DEFAULT_SCROLL_TIME
          );
        },
        /* harmony export */"FixedSizeVirtualScrollStrategy": function FixedSizeVirtualScrollStrategy() {
          return (/* binding */_FixedSizeVirtualScrollStrategy
          );
        },
        /* harmony export */"ScrollDispatcher": function ScrollDispatcher() {
          return (/* binding */_ScrollDispatcher
          );
        },
        /* harmony export */"ScrollingModule": function ScrollingModule() {
          return (/* binding */_ScrollingModule
          );
        },
        /* harmony export */"VIRTUAL_SCROLL_STRATEGY": function VIRTUAL_SCROLL_STRATEGY() {
          return (/* binding */_VIRTUAL_SCROLL_STRATEGY
          );
        },
        /* harmony export */"ViewportRuler": function ViewportRuler() {
          return (/* binding */_ViewportRuler
          );
        },
        /* harmony export */"_fixedSizeVirtualScrollStrategyFactory": function _fixedSizeVirtualScrollStrategyFactory() {
          return (/* binding */_fixedSizeVirtualScrollStrategyFactory2
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @angular/cdk/coercion */20657);
      /* harmony import */
      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @angular/core */2316);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! rxjs */79441);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! rxjs */81134);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! rxjs */25160);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! rxjs */82516);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__( /*! rxjs */90970);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__( /*! rxjs */36317);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__( /*! rxjs */94283);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__( /*! rxjs */64674);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! rxjs/operators */83720);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! rxjs/operators */7494);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! rxjs/operators */9170);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__( /*! rxjs/operators */22663);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__( /*! rxjs/operators */1143);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__( /*! rxjs/operators */15347);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__( /*! rxjs/operators */79902);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__( /*! rxjs/operators */92597);
      /* harmony import */
      var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! @angular/cdk/platform */36145);
      /* harmony import */
      var _angular_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__( /*! @angular/common */54364);
      /* harmony import */
      var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__( /*! @angular/cdk/bidi */772);
      /* harmony import */
      var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__( /*! @angular/cdk/collections */62604);

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** The injection token used to specify the virtual scrolling strategy. */

      var _c0 = ["contentWrapper"];
      var _c1 = ["*"];
      var _VIRTUAL_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('VIRTUAL_SCROLL_STRATEGY');

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Virtual scrolling strategy for lists with items of known fixed size. */
      var _FixedSizeVirtualScrollStrategy = /*#__PURE__*/function () {
        /**
         * @param itemSize The size of the items in the virtually scrolling list.
         * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
         * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
         */
        function _FixedSizeVirtualScrollStrategy(itemSize, minBufferPx, maxBufferPx) {
          _classCallCheck(this, _FixedSizeVirtualScrollStrategy);
          this._scrolledIndexChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** @docs-private Implemented as part of VirtualScrollStrategy. */
          this.scrolledIndexChange = this._scrolledIndexChange.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.distinctUntilChanged)());
          /** The attached viewport. */
          this._viewport = null;
          this._itemSize = itemSize;
          this._minBufferPx = minBufferPx;
          this._maxBufferPx = maxBufferPx;
        }
        /**
         * Attaches this scroll strategy to a viewport.
         * @param viewport The viewport to attach this strategy to.
         */
        _createClass(_FixedSizeVirtualScrollStrategy, [{
          key: "attach",
          value: function attach(viewport) {
            this._viewport = viewport;
            this._updateTotalContentSize();
            this._updateRenderedRange();
          }
          /** Detaches this scroll strategy from the currently attached viewport. */
        }, {
          key: "detach",
          value: function detach() {
            this._scrolledIndexChange.complete();
            this._viewport = null;
          }
          /**
           * Update the item size and buffer size.
           * @param itemSize The size of the items in the virtually scrolling list.
           * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
           * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
           */
        }, {
          key: "updateItemAndBufferSize",
          value: function updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
            if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');
            }
            this._itemSize = itemSize;
            this._minBufferPx = minBufferPx;
            this._maxBufferPx = maxBufferPx;
            this._updateTotalContentSize();
            this._updateRenderedRange();
          }
          /** @docs-private Implemented as part of VirtualScrollStrategy. */
        }, {
          key: "onContentScrolled",
          value: function onContentScrolled() {
            this._updateRenderedRange();
          }
          /** @docs-private Implemented as part of VirtualScrollStrategy. */
        }, {
          key: "onDataLengthChanged",
          value: function onDataLengthChanged() {
            this._updateTotalContentSize();
            this._updateRenderedRange();
          }
          /** @docs-private Implemented as part of VirtualScrollStrategy. */
        }, {
          key: "onContentRendered",
          value: function onContentRendered() {}
          /** @docs-private Implemented as part of VirtualScrollStrategy. */
        }, {
          key: "onRenderedOffsetChanged",
          value: function onRenderedOffsetChanged() {}
          /**
           * Scroll to the offset for the given index.
           * @param index The index of the element to scroll to.
           * @param behavior The ScrollBehavior to use when scrolling.
           */
        }, {
          key: "scrollToIndex",
          value: function scrollToIndex(index, behavior) {
            if (this._viewport) {
              this._viewport.scrollToOffset(index * this._itemSize, behavior);
            }
          }
          /** Update the viewport's total content size. */
        }, {
          key: "_updateTotalContentSize",
          value: function _updateTotalContentSize() {
            if (!this._viewport) {
              return;
            }
            this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
          }
          /** Update the viewport's rendered range. */
        }, {
          key: "_updateRenderedRange",
          value: function _updateRenderedRange() {
            if (!this._viewport) {
              return;
            }
            var renderedRange = this._viewport.getRenderedRange();
            var newRange = {
              start: renderedRange.start,
              end: renderedRange.end
            };
            var viewportSize = this._viewport.getViewportSize();
            var dataLength = this._viewport.getDataLength();
            var scrollOffset = this._viewport.measureScrollOffset();
            // Prevent NaN as result when dividing by zero.
            var firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
            // If user scrolls to the bottom of the list and data changes to a smaller list
            if (newRange.end > dataLength) {
              // We have to recalculate the first visible index based on new data length and viewport size.
              var maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
              var newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
              // If first visible index changed we must update scroll offset to handle start/end buffers
              // Current range must also be adjusted to cover the new position (bottom of new list).
              if (firstVisibleIndex != newVisibleIndex) {
                firstVisibleIndex = newVisibleIndex;
                scrollOffset = newVisibleIndex * this._itemSize;
                newRange.start = Math.floor(firstVisibleIndex);
              }
              newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
            }
            var startBuffer = scrollOffset - newRange.start * this._itemSize;
            if (startBuffer < this._minBufferPx && newRange.start != 0) {
              var expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
              newRange.start = Math.max(0, newRange.start - expandStart);
              newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
            } else {
              var endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
              if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
                var expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
                if (expandEnd > 0) {
                  newRange.end = Math.min(dataLength, newRange.end + expandEnd);
                  newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
                }
              }
            }
            this._viewport.setRenderedRange(newRange);
            this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);
            this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
          }
        }]);
        return _FixedSizeVirtualScrollStrategy;
      }();
      /**
       * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created
       * `FixedSizeVirtualScrollStrategy` from the given directive.
       * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the
       *     `FixedSizeVirtualScrollStrategy` from.
       */
      function _fixedSizeVirtualScrollStrategyFactory2(fixedSizeDir) {
        return fixedSizeDir._scrollStrategy;
      }
      /** A virtual scroll strategy that supports fixed-size items. */
      var _CdkFixedSizeVirtualScroll = /*#__PURE__*/function () {
        function _CdkFixedSizeVirtualScroll() {
          _classCallCheck(this, _CdkFixedSizeVirtualScroll);
          this._itemSize = 20;
          this._minBufferPx = 100;
          this._maxBufferPx = 200;
          /** The scroll strategy used by this directive. */
          this._scrollStrategy = new _FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
        }
        /** The size of the items in the list (in pixels). */
        _createClass(_CdkFixedSizeVirtualScroll, [{
          key: "itemSize",
          get: function get() {
            return this._itemSize;
          },
          set: function set(value) {
            this._itemSize = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceNumberProperty)(value);
          }
          /**
           * The minimum amount of buffer rendered beyond the viewport (in pixels).
           * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
           */
        }, {
          key: "minBufferPx",
          get: function get() {
            return this._minBufferPx;
          },
          set: function set(value) {
            this._minBufferPx = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceNumberProperty)(value);
          }
          /**
           * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
           */
        }, {
          key: "maxBufferPx",
          get: function get() {
            return this._maxBufferPx;
          },
          set: function set(value) {
            this._maxBufferPx = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceNumberProperty)(value);
          }
        }, {
          key: "ngOnChanges",
          value: function ngOnChanges() {
            this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
          }
        }]);
        return _CdkFixedSizeVirtualScroll;
      }();
      _CdkFixedSizeVirtualScroll.ɵfac = function CdkFixedSizeVirtualScroll_Factory(t) {
        return new (t || _CdkFixedSizeVirtualScroll)();
      };
      _CdkFixedSizeVirtualScroll.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: _CdkFixedSizeVirtualScroll,
        selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
        inputs: {
          itemSize: "itemSize",
          minBufferPx: "minBufferPx",
          maxBufferPx: "maxBufferPx"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
          provide: _VIRTUAL_SCROLL_STRATEGY,
          useFactory: _fixedSizeVirtualScrollStrategyFactory2,
          deps: [(0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
            return _CdkFixedSizeVirtualScroll;
          })]
        }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
      });
      _CdkFixedSizeVirtualScroll.propDecorators = {
        itemSize: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        minBufferPx: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        maxBufferPx: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }]
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_CdkFixedSizeVirtualScroll, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: 'cdk-virtual-scroll-viewport[itemSize]',
            providers: [{
              provide: _VIRTUAL_SCROLL_STRATEGY,
              useFactory: _fixedSizeVirtualScrollStrategyFactory2,
              deps: [(0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function () {
                return _CdkFixedSizeVirtualScroll;
              })]
            }]
          }]
        }], function () {
          return [];
        }, {
          itemSize: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          minBufferPx: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          maxBufferPx: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Time in ms to throttle the scrolling events by default. */
      var _DEFAULT_SCROLL_TIME = 20;
      /**
       * Service contained all registered Scrollable references and emits an event when any one of the
       * Scrollable references emit a scrolled event.
       */
      var _ScrollDispatcher = /*#__PURE__*/function () {
        function _ScrollDispatcher(_ngZone, _platform, document) {
          _classCallCheck(this, _ScrollDispatcher);
          this._ngZone = _ngZone;
          this._platform = _platform;
          /** Subject for notifying that a registered scrollable reference element has been scrolled. */
          this._scrolled = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** Keeps track of the global `scroll` and `resize` subscriptions. */
          this._globalSubscription = null;
          /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */
          this._scrolledCount = 0;
          /**
           * Map of all the scrollable references that are registered with the service and their
           * scroll event subscriptions.
           */
          this.scrollContainers = new Map();
          this._document = document;
        }
        /**
         * Registers a scrollable instance with the service and listens for its scrolled events. When the
         * scrollable is scrolled, the service emits the event to its scrolled observable.
         * @param scrollable Scrollable instance to be registered.
         */
        _createClass(_ScrollDispatcher, [{
          key: "register",
          value: function register(scrollable) {
            var _this37 = this;
            if (!this.scrollContainers.has(scrollable)) {
              this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(function () {
                return _this37._scrolled.next(scrollable);
              }));
            }
          }
          /**
           * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
           * @param scrollable Scrollable instance to be deregistered.
           */
        }, {
          key: "deregister",
          value: function deregister(scrollable) {
            var scrollableReference = this.scrollContainers.get(scrollable);
            if (scrollableReference) {
              scrollableReference.unsubscribe();
              this.scrollContainers["delete"](scrollable);
            }
          }
          /**
           * Returns an observable that emits an event whenever any of the registered Scrollable
           * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
           * to override the default "throttle" time.
           *
           * **Note:** in order to avoid hitting change detection for every scroll event,
           * all of the events emitted from this stream will be run outside the Angular zone.
           * If you need to update any data bindings as a result of a scroll event, you have
           * to run the callback using `NgZone.run`.
           */
        }, {
          key: "scrolled",
          value: function scrolled() {
            var _this38 = this;
            var auditTimeInMs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _DEFAULT_SCROLL_TIME;
            if (!this._platform.isBrowser) {
              return (0, rxjs__WEBPACK_IMPORTED_MODULE_4__.of)();
            }
            return new rxjs__WEBPACK_IMPORTED_MODULE_5__.Observable(function (observer) {
              if (!_this38._globalSubscription) {
                _this38._addGlobalListener();
              }
              // In the case of a 0ms delay, use an observable without auditTime
              // since it does add a perceptible delay in processing overhead.
              var subscription = auditTimeInMs > 0 ? _this38._scrolled.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.auditTime)(auditTimeInMs)).subscribe(observer) : _this38._scrolled.subscribe(observer);
              _this38._scrolledCount++;
              return function () {
                subscription.unsubscribe();
                _this38._scrolledCount--;
                if (!_this38._scrolledCount) {
                  _this38._removeGlobalListener();
                }
              };
            });
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            var _this39 = this;
            this._removeGlobalListener();
            this.scrollContainers.forEach(function (_, container) {
              return _this39.deregister(container);
            });
            this._scrolled.complete();
          }
          /**
           * Returns an observable that emits whenever any of the
           * scrollable ancestors of an element are scrolled.
           * @param elementOrElementRef Element whose ancestors to listen for.
           * @param auditTimeInMs Time to throttle the scroll events.
           */
        }, {
          key: "ancestorScrolled",
          value: function ancestorScrolled(elementOrElementRef, auditTimeInMs) {
            var ancestors = this.getAncestorScrollContainers(elementOrElementRef);
            return this.scrolled(auditTimeInMs).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.filter)(function (target) {
              return !target || ancestors.indexOf(target) > -1;
            }));
          }
          /** Returns all registered Scrollables that contain the provided element. */
        }, {
          key: "getAncestorScrollContainers",
          value: function getAncestorScrollContainers(elementOrElementRef) {
            var _this40 = this;
            var scrollingContainers = [];
            this.scrollContainers.forEach(function (_subscription, scrollable) {
              if (_this40._scrollableContainsElement(scrollable, elementOrElementRef)) {
                scrollingContainers.push(scrollable);
              }
            });
            return scrollingContainers;
          }
          /** Use defaultView of injected document if available or fallback to global window reference */
        }, {
          key: "_getWindow",
          value: function _getWindow() {
            return this._document.defaultView || window;
          }
          /** Returns true if the element is contained within the provided Scrollable. */
        }, {
          key: "_scrollableContainsElement",
          value: function _scrollableContainsElement(scrollable, elementOrElementRef) {
            var element = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceElement)(elementOrElementRef);
            var scrollableElement = scrollable.getElementRef().nativeElement;
            // Traverse through the element parents until we reach null, checking if any of the elements
            // are the scrollable's element.
            do {
              if (element == scrollableElement) {
                return true;
              }
            } while (element = element.parentElement);
            return false;
          }
          /** Sets up the global scroll listeners. */
        }, {
          key: "_addGlobalListener",
          value: function _addGlobalListener() {
            var _this41 = this;
            this._globalSubscription = this._ngZone.runOutsideAngular(function () {
              var window = _this41._getWindow();
              return (0, rxjs__WEBPACK_IMPORTED_MODULE_8__.fromEvent)(window.document, 'scroll').subscribe(function () {
                return _this41._scrolled.next();
              });
            });
          }
          /** Cleans up the global scroll listener. */
        }, {
          key: "_removeGlobalListener",
          value: function _removeGlobalListener() {
            if (this._globalSubscription) {
              this._globalSubscription.unsubscribe();
              this._globalSubscription = null;
            }
          }
        }]);
        return _ScrollDispatcher;
      }();
      _ScrollDispatcher.ɵfac = function ScrollDispatcher_Factory(t) {
        return new (t || _ScrollDispatcher)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_10__.DOCUMENT, 8));
      };
      _ScrollDispatcher.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
        factory: function ScrollDispatcher_Factory() {
          return new _ScrollDispatcher(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_10__.DOCUMENT, 8));
        },
        token: _ScrollDispatcher,
        providedIn: "root"
      });
      _ScrollDispatcher.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
        }, {
          type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.Platform
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_10__.DOCUMENT]
          }]
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_ScrollDispatcher, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
          }, {
            type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.Platform
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
            }, {
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_10__.DOCUMENT]
            }]
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Sends an event when the directive's element is scrolled. Registers itself with the
       * ScrollDispatcher service to include itself as part of its collection of scrolling events that it
       * can be listened to through the service.
       */
      var _CdkScrollable = /*#__PURE__*/function () {
        function _CdkScrollable(elementRef, scrollDispatcher, ngZone, dir) {
          var _this42 = this;
          _classCallCheck(this, _CdkScrollable);
          this.elementRef = elementRef;
          this.scrollDispatcher = scrollDispatcher;
          this.ngZone = ngZone;
          this.dir = dir;
          this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          this._elementScrolled = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Observable(function (observer) {
            return _this42.ngZone.runOutsideAngular(function () {
              return (0, rxjs__WEBPACK_IMPORTED_MODULE_8__.fromEvent)(_this42.elementRef.nativeElement, 'scroll').pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.takeUntil)(_this42._destroyed)).subscribe(observer);
            });
          });
        }
        _createClass(_CdkScrollable, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            this.scrollDispatcher.register(this);
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this.scrollDispatcher.deregister(this);
            this._destroyed.next();
            this._destroyed.complete();
          }
          /** Returns observable that emits when a scroll event is fired on the host element. */
        }, {
          key: "elementScrolled",
          value: function elementScrolled() {
            return this._elementScrolled;
          }
          /** Gets the ElementRef for the viewport. */
        }, {
          key: "getElementRef",
          value: function getElementRef() {
            return this.elementRef;
          }
          /**
           * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
           * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
           * left and right always refer to the left and right side of the scrolling container irrespective
           * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
           * in an RTL context.
           * @param options specified the offsets to scroll to.
           */
        }, {
          key: "scrollTo",
          value: function scrollTo(options) {
            var el = this.elementRef.nativeElement;
            var isRtl = this.dir && this.dir.value == 'rtl';
            // Rewrite start & end offsets as right or left offsets.
            if (options.left == null) {
              options.left = isRtl ? options.end : options.start;
            }
            if (options.right == null) {
              options.right = isRtl ? options.start : options.end;
            }
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
              options.top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && (0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.getRtlScrollAxisType)() != 0 /* NORMAL */) {
              if (options.left != null) {
                options.right = el.scrollWidth - el.clientWidth - options.left;
              }
              if ((0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.getRtlScrollAxisType)() == 2 /* INVERTED */) {
                options.left = options.right;
              } else if ((0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.getRtlScrollAxisType)() == 1 /* NEGATED */) {
                options.left = options.right ? -options.right : options.right;
              }
            } else {
              if (options.right != null) {
                options.left = el.scrollWidth - el.clientWidth - options.right;
              }
            }
            this._applyScrollToOptions(options);
          }
        }, {
          key: "_applyScrollToOptions",
          value: function _applyScrollToOptions(options) {
            var el = this.elementRef.nativeElement;
            if ((0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.supportsScrollBehavior)()) {
              el.scrollTo(options);
            } else {
              if (options.top != null) {
                el.scrollTop = options.top;
              }
              if (options.left != null) {
                el.scrollLeft = options.left;
              }
            }
          }
          /**
           * Measures the scroll offset relative to the specified edge of the viewport. This method can be
           * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
           * about what scrollLeft means in RTL. The values returned by this method are normalized such that
           * left and right always refer to the left and right side of the scrolling container irrespective
           * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
           * in an RTL context.
           * @param from The edge to measure from.
           */
        }, {
          key: "measureScrollOffset",
          value: function measureScrollOffset(from) {
            var LEFT = 'left';
            var RIGHT = 'right';
            var el = this.elementRef.nativeElement;
            if (from == 'top') {
              return el.scrollTop;
            }
            if (from == 'bottom') {
              return el.scrollHeight - el.clientHeight - el.scrollTop;
            }
            // Rewrite start & end as left or right offsets.
            var isRtl = this.dir && this.dir.value == 'rtl';
            if (from == 'start') {
              from = isRtl ? RIGHT : LEFT;
            } else if (from == 'end') {
              from = isRtl ? LEFT : RIGHT;
            }
            if (isRtl && (0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.getRtlScrollAxisType)() == 2 /* INVERTED */) {
              // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and
              // 0 when scrolled all the way right.
              if (from == LEFT) {
                return el.scrollWidth - el.clientWidth - el.scrollLeft;
              } else {
                return el.scrollLeft;
              }
            } else if (isRtl && (0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.getRtlScrollAxisType)() == 1 /* NEGATED */) {
              // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and
              // 0 when scrolled all the way right.
              if (from == LEFT) {
                return el.scrollLeft + el.scrollWidth - el.clientWidth;
              } else {
                return -el.scrollLeft;
              }
            } else {
              // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and
              // (scrollWidth - clientWidth) when scrolled all the way right.
              if (from == LEFT) {
                return el.scrollLeft;
              } else {
                return el.scrollWidth - el.clientWidth - el.scrollLeft;
              }
            }
          }
        }]);
        return _CdkScrollable;
      }();
      _CdkScrollable.ɵfac = function CdkScrollable_Factory(t) {
        return new (t || _CdkScrollable)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_ScrollDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality, 8));
      };
      _CdkScrollable.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: _CdkScrollable,
        selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]]
      });
      _CdkScrollable.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
        }, {
          type: _ScrollDispatcher
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
        }, {
          type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
          }]
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_CdkScrollable, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[cdk-scrollable], [cdkScrollable]'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
          }, {
            type: _ScrollDispatcher
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
          }, {
            type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
            }]
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Time in ms to throttle the resize events by default. */
      var _DEFAULT_RESIZE_TIME = 20;
      /**
       * Simple utility for getting the bounds of the browser viewport.
       * @docs-private
       */
      var _ViewportRuler = /*#__PURE__*/function () {
        function _ViewportRuler(_platform, ngZone, document) {
          var _this43 = this;
          _classCallCheck(this, _ViewportRuler);
          this._platform = _platform;
          /** Stream of viewport change events. */
          this._change = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** Event listener that will be used to handle the viewport change events. */
          this._changeListener = function (event) {
            _this43._change.next(event);
          };
          this._document = document;
          ngZone.runOutsideAngular(function () {
            if (_platform.isBrowser) {
              var _window = _this43._getWindow();
              // Note that bind the events ourselves, rather than going through something like RxJS's
              // `fromEvent` so that we can ensure that they're bound outside of the NgZone.
              _window.addEventListener('resize', _this43._changeListener);
              _window.addEventListener('orientationchange', _this43._changeListener);
            }
            // Clear the cached position so that the viewport is re-measured next time it is required.
            // We don't need to keep track of the subscription, because it is completed on destroy.
            _this43.change().subscribe(function () {
              return _this43._viewportSize = null;
            });
          });
        }
        _createClass(_ViewportRuler, [{
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            if (this._platform.isBrowser) {
              var _window2 = this._getWindow();
              _window2.removeEventListener('resize', this._changeListener);
              _window2.removeEventListener('orientationchange', this._changeListener);
            }
            this._change.complete();
          }
          /** Returns the viewport's width and height. */
        }, {
          key: "getViewportSize",
          value: function getViewportSize() {
            if (!this._viewportSize) {
              this._updateViewportSize();
            }
            var output = {
              width: this._viewportSize.width,
              height: this._viewportSize.height
            };
            // If we're not on a browser, don't cache the size since it'll be mocked out anyway.
            if (!this._platform.isBrowser) {
              this._viewportSize = null;
            }
            return output;
          }
          /** Gets a ClientRect for the viewport's bounds. */
        }, {
          key: "getViewportRect",
          value: function getViewportRect() {
            // Use the document element's bounding rect rather than the window scroll properties
            // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll
            // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different
            // conceptual viewports. Under most circumstances these viewports are equivalent, but they
            // can disagree when the page is pinch-zoomed (on devices that support touch).
            // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4
            // We use the documentElement instead of the body because, by default (without a css reset)
            // browsers typically give the document body an 8px margin, which is not included in
            // getBoundingClientRect().
            var scrollPosition = this.getViewportScrollPosition();
            var _this$getViewportSize = this.getViewportSize(),
              width = _this$getViewportSize.width,
              height = _this$getViewportSize.height;
            return {
              top: scrollPosition.top,
              left: scrollPosition.left,
              bottom: scrollPosition.top + height,
              right: scrollPosition.left + width,
              height: height,
              width: width
            };
          }
          /** Gets the (top, left) scroll position of the viewport. */
        }, {
          key: "getViewportScrollPosition",
          value: function getViewportScrollPosition() {
            // While we can get a reference to the fake document
            // during SSR, it doesn't have getBoundingClientRect.
            if (!this._platform.isBrowser) {
              return {
                top: 0,
                left: 0
              };
            }
            // The top-left-corner of the viewport is determined by the scroll position of the document
            // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about
            // whether `document.body` or `document.documentElement` is the scrolled element, so reading
            // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of
            // `document.documentElement` works consistently, where the `top` and `left` values will
            // equal negative the scroll position.
            var document = this._document;
            var window = this._getWindow();
            var documentElement = document.documentElement;
            var documentRect = documentElement.getBoundingClientRect();
            var top = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
            var left = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
            return {
              top: top,
              left: left
            };
          }
          /**
           * Returns a stream that emits whenever the size of the viewport changes.
           * This stream emits outside of the Angular zone.
           * @param throttleTime Time in milliseconds to throttle the stream.
           */
        }, {
          key: "change",
          value: function change() {
            var throttleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _DEFAULT_RESIZE_TIME;
            return throttleTime > 0 ? this._change.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.auditTime)(throttleTime)) : this._change;
          }
          /** Use defaultView of injected document if available or fallback to global window reference */
        }, {
          key: "_getWindow",
          value: function _getWindow() {
            return this._document.defaultView || window;
          }
          /** Updates the cached viewport size. */
        }, {
          key: "_updateViewportSize",
          value: function _updateViewportSize() {
            var window = this._getWindow();
            this._viewportSize = this._platform.isBrowser ? {
              width: window.innerWidth,
              height: window.innerHeight
            } : {
              width: 0,
              height: 0
            };
          }
        }]);
        return _ViewportRuler;
      }();
      _ViewportRuler.ɵfac = function ViewportRuler_Factory(t) {
        return new (t || _ViewportRuler)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_10__.DOCUMENT, 8));
      };
      _ViewportRuler.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
        factory: function ViewportRuler_Factory() {
          return new _ViewportRuler(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_10__.DOCUMENT, 8));
        },
        token: _ViewportRuler,
        providedIn: "root"
      });
      _ViewportRuler.ctorParameters = function () {
        return [{
          type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.Platform
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_10__.DOCUMENT]
          }]
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_ViewportRuler, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.Platform
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
            }, {
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_10__.DOCUMENT]
            }]
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Checks if the given ranges are equal. */
      function rangesEqual(r1, r2) {
        return r1.start == r2.start && r1.end == r2.end;
      }
      /**
       * Scheduler to be used for scroll events. Needs to fall back to
       * something that doesn't rely on requestAnimationFrame on environments
       * that don't support it (e.g. server-side rendering).
       */
      var SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? rxjs__WEBPACK_IMPORTED_MODULE_13__.animationFrameScheduler : rxjs__WEBPACK_IMPORTED_MODULE_14__.asapScheduler;
      /** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */
      var _CdkVirtualScrollViewport = /*#__PURE__*/function (_CdkScrollable2) {
        _inherits(_CdkVirtualScrollViewport, _CdkScrollable2);
        var _super15 = _createSuper(_CdkVirtualScrollViewport);
        function _CdkVirtualScrollViewport(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler) {
          var _this44;
          _classCallCheck(this, _CdkVirtualScrollViewport);
          _this44 = _super15.call(this, elementRef, scrollDispatcher, ngZone, dir);
          _this44.elementRef = elementRef;
          _this44._changeDetectorRef = _changeDetectorRef;
          _this44._scrollStrategy = _scrollStrategy;
          /** Emits when the viewport is detached from a CdkVirtualForOf. */
          _this44._detachedSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** Emits when the rendered range changes. */
          _this44._renderedRangeSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          _this44._orientation = 'vertical';
          _this44._appendOnly = false;
          // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll
          // strategy lazily (i.e. only if the user is actually listening to the events). We do this because
          // depending on how the strategy calculates the scrolled index, it may come at a cost to
          // performance.
          /** Emits when the index of the first element visible in the viewport changes. */
          _this44.scrolledIndexChange = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Observable(function (observer) {
            return _this44._scrollStrategy.scrolledIndexChange.subscribe(function (index) {
              return Promise.resolve().then(function () {
                return _this44.ngZone.run(function () {
                  return observer.next(index);
                });
              });
            });
          });
          /** A stream that emits whenever the rendered range changes. */
          _this44.renderedRangeStream = _this44._renderedRangeSubject;
          /**
           * The total size of all content (in pixels), including content that is not currently rendered.
           */
          _this44._totalContentSize = 0;
          /** A string representing the `style.width` property value to be used for the spacer element. */
          _this44._totalContentWidth = '';
          /** A string representing the `style.height` property value to be used for the spacer element. */
          _this44._totalContentHeight = '';
          /** The currently rendered range of indices. */
          _this44._renderedRange = {
            start: 0,
            end: 0
          };
          /** The length of the data bound to this viewport (in number of items). */
          _this44._dataLength = 0;
          /** The size of the viewport (in pixels). */
          _this44._viewportSize = 0;
          /** The last rendered content offset that was set. */
          _this44._renderedContentOffset = 0;
          /**
           * Whether the last rendered content offset was to the end of the content (and therefore needs to
           * be rewritten as an offset to the start of the content).
           */
          _this44._renderedContentOffsetNeedsRewrite = false;
          /** Whether there is a pending change detection cycle. */
          _this44._isChangeDetectionPending = false;
          /** A list of functions to run after the next change detection cycle. */
          _this44._runAfterChangeDetection = [];
          /** Subscription to changes in the viewport size. */
          _this44._viewportChanges = rxjs__WEBPACK_IMPORTED_MODULE_15__.Subscription.EMPTY;
          if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
          }
          _this44._viewportChanges = viewportRuler.change().subscribe(function () {
            _this44.checkViewportSize();
          });
          return _this44;
        }
        /** The direction the viewport scrolls. */
        _createClass(_CdkVirtualScrollViewport, [{
          key: "orientation",
          get: function get() {
            return this._orientation;
          },
          set: function set(orientation) {
            if (this._orientation !== orientation) {
              this._orientation = orientation;
              this._calculateSpacerSize();
            }
          }
          /**
           * Whether rendered items should persist in the DOM after scrolling out of view. By default, items
           * will be removed.
           */
        }, {
          key: "appendOnly",
          get: function get() {
            return this._appendOnly;
          },
          set: function set(value) {
            this._appendOnly = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceBooleanProperty)(value);
          }
        }, {
          key: "ngOnInit",
          value: function ngOnInit() {
            var _this45 = this;
            _get(_getPrototypeOf(_CdkVirtualScrollViewport.prototype), "ngOnInit", this).call(this);
            // It's still too early to measure the viewport at this point. Deferring with a promise allows
            // the Viewport to be rendered with the correct size before we measure. We run this outside the
            // zone to avoid causing more change detection cycles. We handle the change detection loop
            // ourselves instead.
            this.ngZone.runOutsideAngular(function () {
              return Promise.resolve().then(function () {
                _this45._measureViewportSize();
                _this45._scrollStrategy.attach(_this45);
                _this45.elementScrolled().pipe(
                // Start off with a fake scroll event so we properly detect our initial position.
                (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.startWith)(null),
                // Collect multiple events into one until the next animation frame. This way if
                // there are multiple scroll events in the same frame we only need to recheck
                // our layout once.
                (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.auditTime)(0, SCROLL_SCHEDULER)).subscribe(function () {
                  return _this45._scrollStrategy.onContentScrolled();
                });
                _this45._markChangeDetectionNeeded();
              });
            });
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this.detach();
            this._scrollStrategy.detach();
            // Complete all subjects
            this._renderedRangeSubject.complete();
            this._detachedSubject.complete();
            this._viewportChanges.unsubscribe();
            _get(_getPrototypeOf(_CdkVirtualScrollViewport.prototype), "ngOnDestroy", this).call(this);
          }
          /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */
        }, {
          key: "attach",
          value: function attach(forOf) {
            var _this46 = this;
            if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw Error('CdkVirtualScrollViewport is already attached.');
            }
            // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length
            // changes. Run outside the zone to avoid triggering change detection, since we're managing the
            // change detection loop ourselves.
            this.ngZone.runOutsideAngular(function () {
              _this46._forOf = forOf;
              _this46._forOf.dataStream.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.takeUntil)(_this46._detachedSubject)).subscribe(function (data) {
                var newLength = data.length;
                if (newLength !== _this46._dataLength) {
                  _this46._dataLength = newLength;
                  _this46._scrollStrategy.onDataLengthChanged();
                }
                _this46._doChangeDetection();
              });
            });
          }
          /** Detaches the current `CdkVirtualForOf`. */
        }, {
          key: "detach",
          value: function detach() {
            this._forOf = null;
            this._detachedSubject.next();
          }
          /** Gets the length of the data bound to this viewport (in number of items). */
        }, {
          key: "getDataLength",
          value: function getDataLength() {
            return this._dataLength;
          }
          /** Gets the size of the viewport (in pixels). */
        }, {
          key: "getViewportSize",
          value: function getViewportSize() {
            return this._viewportSize;
          }
          // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
          // cycle happens. I'm being careful to only call it after the render cycle is complete and before
          // setting it to something else, but its error prone and should probably be split into
          // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
          /** Get the current rendered range of items. */
        }, {
          key: "getRenderedRange",
          value: function getRenderedRange() {
            return this._renderedRange;
          }
          /**
           * Sets the total size of all content (in pixels), including content that is not currently
           * rendered.
           */
        }, {
          key: "setTotalContentSize",
          value: function setTotalContentSize(size) {
            if (this._totalContentSize !== size) {
              this._totalContentSize = size;
              this._calculateSpacerSize();
              this._markChangeDetectionNeeded();
            }
          }
          /** Sets the currently rendered range of indices. */
        }, {
          key: "setRenderedRange",
          value: function setRenderedRange(range) {
            var _this47 = this;
            if (!rangesEqual(this._renderedRange, range)) {
              if (this.appendOnly) {
                range = {
                  start: 0,
                  end: Math.max(this._renderedRange.end, range.end)
                };
              }
              this._renderedRangeSubject.next(this._renderedRange = range);
              this._markChangeDetectionNeeded(function () {
                return _this47._scrollStrategy.onContentRendered();
              });
            }
          }
          /**
           * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
           */
        }, {
          key: "getOffsetToRenderedContentStart",
          value: function getOffsetToRenderedContentStart() {
            return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
          }
          /**
           * Sets the offset from the start of the viewport to either the start or end of the rendered data
           * (in pixels).
           */
        }, {
          key: "setRenderedContentOffset",
          value: function setRenderedContentOffset(offset) {
            var _this48 = this;
            var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'to-start';
            // For a horizontal viewport in a right-to-left language we need to translate along the x-axis
            // in the negative direction.
            var isRtl = this.dir && this.dir.value == 'rtl';
            var isHorizontal = this.orientation == 'horizontal';
            var axis = isHorizontal ? 'X' : 'Y';
            var axisDirection = isHorizontal && isRtl ? -1 : 1;
            var transform = "translate".concat(axis, "(").concat(Number(axisDirection * offset), "px)");
            this._renderedContentOffset = offset;
            if (to === 'to-end') {
              transform += " translate".concat(axis, "(-100%)");
              // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise
              // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would
              // expand upward).
              this._renderedContentOffsetNeedsRewrite = true;
            }
            if (this._renderedContentTransform != transform) {
              // We know this value is safe because we parse `offset` with `Number()` before passing it
              // into the string.
              this._renderedContentTransform = transform;
              this._markChangeDetectionNeeded(function () {
                if (_this48._renderedContentOffsetNeedsRewrite) {
                  _this48._renderedContentOffset -= _this48.measureRenderedContentSize();
                  _this48._renderedContentOffsetNeedsRewrite = false;
                  _this48.setRenderedContentOffset(_this48._renderedContentOffset);
                } else {
                  _this48._scrollStrategy.onRenderedOffsetChanged();
                }
              });
            }
          }
          /**
           * Scrolls to the given offset from the start of the viewport. Please note that this is not always
           * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
           * direction, this would be the equivalent of setting a fictional `scrollRight` property.
           * @param offset The offset to scroll to.
           * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
           */
        }, {
          key: "scrollToOffset",
          value: function scrollToOffset(offset) {
            var behavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';
            var options = {
              behavior: behavior
            };
            if (this.orientation === 'horizontal') {
              options.start = offset;
            } else {
              options.top = offset;
            }
            this.scrollTo(options);
          }
          /**
           * Scrolls to the offset for the given index.
           * @param index The index of the element to scroll to.
           * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
           */
        }, {
          key: "scrollToIndex",
          value: function scrollToIndex(index) {
            var behavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';
            this._scrollStrategy.scrollToIndex(index, behavior);
          }
          /**
           * Gets the current scroll offset from the start of the viewport (in pixels).
           * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
           *     in horizontal mode.
           */
        }, {
          key: "measureScrollOffset",
          value: function measureScrollOffset(from) {
            return from ? _get(_getPrototypeOf(_CdkVirtualScrollViewport.prototype), "measureScrollOffset", this).call(this, from) : _get(_getPrototypeOf(_CdkVirtualScrollViewport.prototype), "measureScrollOffset", this).call(this, this.orientation === 'horizontal' ? 'start' : 'top');
          }
          /** Measure the combined size of all of the rendered items. */
        }, {
          key: "measureRenderedContentSize",
          value: function measureRenderedContentSize() {
            var contentEl = this._contentWrapper.nativeElement;
            return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;
          }
          /**
           * Measure the total combined size of the given range. Throws if the range includes items that are
           * not rendered.
           */
        }, {
          key: "measureRangeSize",
          value: function measureRangeSize(range) {
            if (!this._forOf) {
              return 0;
            }
            return this._forOf.measureRangeSize(range, this.orientation);
          }
          /** Update the viewport dimensions and re-render. */
        }, {
          key: "checkViewportSize",
          value: function checkViewportSize() {
            // TODO: Cleanup later when add logic for handling content resize
            this._measureViewportSize();
            this._scrollStrategy.onDataLengthChanged();
          }
          /** Measure the viewport size. */
        }, {
          key: "_measureViewportSize",
          value: function _measureViewportSize() {
            var viewportEl = this.elementRef.nativeElement;
            this._viewportSize = this.orientation === 'horizontal' ? viewportEl.clientWidth : viewportEl.clientHeight;
          }
          /** Queue up change detection to run. */
        }, {
          key: "_markChangeDetectionNeeded",
          value: function _markChangeDetectionNeeded(runAfter) {
            var _this49 = this;
            if (runAfter) {
              this._runAfterChangeDetection.push(runAfter);
            }
            // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of
            // properties sequentially we only have to run `_doChangeDetection` once at the end.
            if (!this._isChangeDetectionPending) {
              this._isChangeDetectionPending = true;
              this.ngZone.runOutsideAngular(function () {
                return Promise.resolve().then(function () {
                  _this49._doChangeDetection();
                });
              });
            }
          }
          /** Run change detection. */
        }, {
          key: "_doChangeDetection",
          value: function _doChangeDetection() {
            var _this50 = this;
            this._isChangeDetectionPending = false;
            // Apply the content transform. The transform can't be set via an Angular binding because
            // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of
            // string literals, a variable that can only be 'X' or 'Y', and user input that is run through
            // the `Number` function first to coerce it to a numeric value.
            this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
            // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection
            // from the root, since the repeated items are content projected in. Calling `detectChanges`
            // instead does not properly check the projected content.
            this.ngZone.run(function () {
              return _this50._changeDetectorRef.markForCheck();
            });
            var runAfterChangeDetection = this._runAfterChangeDetection;
            this._runAfterChangeDetection = [];
            var _iterator5 = _createForOfIteratorHelper(runAfterChangeDetection),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var fn = _step5.value;
                fn();
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }
          /** Calculates the `style.width` and `style.height` for the spacer element. */
        }, {
          key: "_calculateSpacerSize",
          value: function _calculateSpacerSize() {
            this._totalContentHeight = this.orientation === 'horizontal' ? '' : "".concat(this._totalContentSize, "px");
            this._totalContentWidth = this.orientation === 'horizontal' ? "".concat(this._totalContentSize, "px") : '';
          }
        }]);
        return _CdkVirtualScrollViewport;
      }(_CdkScrollable);
      _CdkVirtualScrollViewport.ɵfac = function CdkVirtualScrollViewport_Factory(t) {
        return new (t || _CdkVirtualScrollViewport)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_VIRTUAL_SCROLL_STRATEGY, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality, 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_ScrollDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_ViewportRuler));
      };
      _CdkVirtualScrollViewport.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: _CdkVirtualScrollViewport,
        selectors: [["cdk-virtual-scroll-viewport"]],
        viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](_c0, 7);
          }
          if (rf & 2) {
            var _t;
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx._contentWrapper = _t.first);
          }
        },
        hostAttrs: [1, "cdk-virtual-scroll-viewport"],
        hostVars: 4,
        hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {
          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassProp"]("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
          }
        },
        inputs: {
          orientation: "orientation",
          appendOnly: "appendOnly"
        },
        outputs: {
          scrolledIndexChange: "scrolledIndexChange"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
          provide: _CdkScrollable,
          useExisting: _CdkVirtualScrollViewport
        }]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
        ngContentSelectors: _c1,
        decls: 4,
        vars: 4,
        consts: [[1, "cdk-virtual-scroll-content-wrapper"], ["contentWrapper", ""], [1, "cdk-virtual-scroll-spacer"]],
        template: function CdkVirtualScrollViewport_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0, 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](3, "div", 2);
          }
          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("width", ctx._totalContentWidth)("height", ctx._totalContentHeight);
          }
        },
        styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\n"],
        encapsulation: 2,
        changeDetection: 0
      });
      _CdkVirtualScrollViewport.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
            args: [_VIRTUAL_SCROLL_STRATEGY]
          }]
        }, {
          type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
          }]
        }, {
          type: _ScrollDispatcher
        }, {
          type: _ViewportRuler
        }];
      };
      _CdkVirtualScrollViewport.propDecorators = {
        orientation: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        appendOnly: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        scrolledIndexChange: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        _contentWrapper: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
          args: ['contentWrapper', {
            "static": true
          }]
        }]
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_CdkVirtualScrollViewport, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'cdk-virtual-scroll-viewport',
            template: "<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class=\"cdk-virtual-scroll-content-wrapper\">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class=\"cdk-virtual-scroll-spacer\"\n     [style.width]=\"_totalContentWidth\" [style.height]=\"_totalContentHeight\"></div>\n",
            host: {
              'class': 'cdk-virtual-scroll-viewport',
              '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === "horizontal"',
              '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== "horizontal"'
            },
            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None,
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            providers: [{
              provide: _CdkScrollable,
              useExisting: _CdkVirtualScrollViewport
            }],
            styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\n"]
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
            }, {
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
              args: [_VIRTUAL_SCROLL_STRATEGY]
            }]
          }, {
            type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
            }]
          }, {
            type: _ScrollDispatcher
          }, {
            type: _ViewportRuler
          }];
        }, {
          scrolledIndexChange: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          orientation: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          appendOnly: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          _contentWrapper: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
            args: ['contentWrapper', {
              "static": true
            }]
          }]
        });
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /** Helper to extract the offset of a DOM Node in a certain direction. */
      function getOffset(orientation, direction, node) {
        var el = node;
        if (!el.getBoundingClientRect) {
          return 0;
        }
        var rect = el.getBoundingClientRect();
        if (orientation === 'horizontal') {
          return direction === 'start' ? rect.left : rect.right;
        }
        return direction === 'start' ? rect.top : rect.bottom;
      }
      /**
       * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling
       * container.
       */
      var _CdkVirtualForOf = /*#__PURE__*/function () {
        function _CdkVirtualForOf( /** The view container to add items to. */
        _viewContainerRef, /** The template to use when stamping out new items. */
        _template, /** The set of available differs. */
        _differs, /** The strategy used to render items in the virtual scroll viewport. */
        _viewRepeater, /** The virtual scrolling viewport that these items are being rendered in. */
        _viewport, ngZone) {
          var _this51 = this;
          _classCallCheck(this, _CdkVirtualForOf);
          this._viewContainerRef = _viewContainerRef;
          this._template = _template;
          this._differs = _differs;
          this._viewRepeater = _viewRepeater;
          this._viewport = _viewport;
          /** Emits when the rendered view of the data changes. */
          this.viewChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** Subject that emits when a new DataSource instance is given. */
          this._dataSourceChanges = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          /** Emits whenever the data in the current DataSource changes. */
          this.dataStream = this._dataSourceChanges.pipe(
          // Start off with null `DataSource`.
          (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.startWith)(null),
          // Bundle up the previous and current data sources so we can work with both.
          (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_17__.pairwise)(),
          // Use `_changeDataSource` to disconnect from the previous data source and connect to the
          // new one, passing back a stream of data changes which we run through `switchMap` to give
          // us a data stream that emits the latest data from whatever the current `DataSource` is.
          (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_18__.switchMap)(function (_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
              prev = _ref4[0],
              cur = _ref4[1];
            return _this51._changeDataSource(prev, cur);
          }),
          // Replay the last emitted data when someone subscribes.
          (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.shareReplay)(1));
          /** The differ used to calculate changes to the data. */
          this._differ = null;
          /** Whether the rendered data should be updated during the next ngDoCheck cycle. */
          this._needsUpdate = false;
          this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
          this.dataStream.subscribe(function (data) {
            _this51._data = data;
            _this51._onRenderedDataChange();
          });
          this._viewport.renderedRangeStream.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.takeUntil)(this._destroyed)).subscribe(function (range) {
            _this51._renderedRange = range;
            ngZone.run(function () {
              return _this51.viewChange.next(_this51._renderedRange);
            });
            _this51._onRenderedDataChange();
          });
          this._viewport.attach(this);
        }
        /** The DataSource to display. */
        _createClass(_CdkVirtualForOf, [{
          key: "cdkVirtualForOf",
          get: function get() {
            return this._cdkVirtualForOf;
          },
          set: function set(value) {
            this._cdkVirtualForOf = value;
            if ((0, _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__.isDataSource)(value)) {
              this._dataSourceChanges.next(value);
            } else {
              // If value is an an NgIterable, convert it to an array.
              this._dataSourceChanges.next(new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__.ArrayDataSource((0, rxjs__WEBPACK_IMPORTED_MODULE_21__.isObservable)(value) ? value : Array.from(value || [])));
            }
          }
          /**
           * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
           * the item and produces a value to be used as the item's identity when tracking changes.
           */
        }, {
          key: "cdkVirtualForTrackBy",
          get: function get() {
            return this._cdkVirtualForTrackBy;
          },
          set: function set(fn) {
            var _this52 = this;
            this._needsUpdate = true;
            this._cdkVirtualForTrackBy = fn ? function (index, item) {
              return fn(index + (_this52._renderedRange ? _this52._renderedRange.start : 0), item);
            } : undefined;
          }
          /** The template used to stamp out new elements. */
        }, {
          key: "cdkVirtualForTemplate",
          set: function set(value) {
            if (value) {
              this._needsUpdate = true;
              this._template = value;
            }
          }
          /**
           * The size of the cache used to store templates that are not being used for re-use later.
           * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
           */
        }, {
          key: "cdkVirtualForTemplateCacheSize",
          get: function get() {
            return this._viewRepeater.viewCacheSize;
          },
          set: function set(size) {
            this._viewRepeater.viewCacheSize = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceNumberProperty)(size);
          }
          /**
           * Measures the combined size (width for horizontal orientation, height for vertical) of all items
           * in the specified range. Throws an error if the range includes items that are not currently
           * rendered.
           */
        }, {
          key: "measureRangeSize",
          value: function measureRangeSize(range, orientation) {
            if (range.start >= range.end) {
              return 0;
            }
            if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
              throw Error("Error: attempted to measure an item that isn't rendered.");
            }
            // The index into the list of rendered views for the first item in the range.
            var renderedStartIndex = range.start - this._renderedRange.start;
            // The length of the range we're measuring.
            var rangeLen = range.end - range.start;
            // Loop over all the views, find the first and land node and compute the size by subtracting
            // the top of the first node from the bottom of the last one.
            var firstNode;
            var lastNode;
            // Find the first node by starting from the beginning and going forwards.
            for (var i = 0; i < rangeLen; i++) {
              var view = this._viewContainerRef.get(i + renderedStartIndex);
              if (view && view.rootNodes.length) {
                firstNode = lastNode = view.rootNodes[0];
                break;
              }
            }
            // Find the last node by starting from the end and going backwards.
            for (var _i2 = rangeLen - 1; _i2 > -1; _i2--) {
              var _view = this._viewContainerRef.get(_i2 + renderedStartIndex);
              if (_view && _view.rootNodes.length) {
                lastNode = _view.rootNodes[_view.rootNodes.length - 1];
                break;
              }
            }
            return firstNode && lastNode ? getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode) : 0;
          }
        }, {
          key: "ngDoCheck",
          value: function ngDoCheck() {
            if (this._differ && this._needsUpdate) {
              // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of
              // this list being rendered (can use simpler algorithm) vs needs update due to data actually
              // changing (need to do this diff).
              var changes = this._differ.diff(this._renderedItems);
              if (!changes) {
                this._updateContext();
              } else {
                this._applyChanges(changes);
              }
              this._needsUpdate = false;
            }
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this._viewport.detach();
            this._dataSourceChanges.next(undefined);
            this._dataSourceChanges.complete();
            this.viewChange.complete();
            this._destroyed.next();
            this._destroyed.complete();
            this._viewRepeater.detach();
          }
          /** React to scroll state changes in the viewport. */
        }, {
          key: "_onRenderedDataChange",
          value: function _onRenderedDataChange() {
            var _this53 = this;
            if (!this._renderedRange) {
              return;
            }
            this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
            if (!this._differ) {
              // Use a wrapper function for the `trackBy` so any new values are
              // picked up automatically without having to recreate the differ.
              this._differ = this._differs.find(this._renderedItems).create(function (index, item) {
                return _this53.cdkVirtualForTrackBy ? _this53.cdkVirtualForTrackBy(index, item) : item;
              });
            }
            this._needsUpdate = true;
          }
          /** Swap out one `DataSource` for another. */
        }, {
          key: "_changeDataSource",
          value: function _changeDataSource(oldDs, newDs) {
            if (oldDs) {
              oldDs.disconnect(this);
            }
            this._needsUpdate = true;
            return newDs ? newDs.connect(this) : (0, rxjs__WEBPACK_IMPORTED_MODULE_4__.of)();
          }
          /** Update the `CdkVirtualForOfContext` for all views. */
        }, {
          key: "_updateContext",
          value: function _updateContext() {
            var count = this._data.length;
            var i = this._viewContainerRef.length;
            while (i--) {
              var view = this._viewContainerRef.get(i);
              view.context.index = this._renderedRange.start + i;
              view.context.count = count;
              this._updateComputedContextProperties(view.context);
              view.detectChanges();
            }
          }
          /** Apply changes to the DOM. */
        }, {
          key: "_applyChanges",
          value: function _applyChanges(changes) {
            var _this54 = this;
            this._viewRepeater.applyChanges(changes, this._viewContainerRef, function (record, _adjustedPreviousIndex, currentIndex) {
              return _this54._getEmbeddedViewArgs(record, currentIndex);
            }, function (record) {
              return record.item;
            });
            // Update $implicit for any items that had an identity change.
            changes.forEachIdentityChange(function (record) {
              var view = _this54._viewContainerRef.get(record.currentIndex);
              view.context.$implicit = record.item;
            });
            // Update the context variables on all items.
            var count = this._data.length;
            var i = this._viewContainerRef.length;
            while (i--) {
              var view = this._viewContainerRef.get(i);
              view.context.index = this._renderedRange.start + i;
              view.context.count = count;
              this._updateComputedContextProperties(view.context);
            }
          }
          /** Update the computed properties on the `CdkVirtualForOfContext`. */
        }, {
          key: "_updateComputedContextProperties",
          value: function _updateComputedContextProperties(context) {
            context.first = context.index === 0;
            context.last = context.index === context.count - 1;
            context.even = context.index % 2 === 0;
            context.odd = !context.even;
          }
        }, {
          key: "_getEmbeddedViewArgs",
          value: function _getEmbeddedViewArgs(record, index) {
            // Note that it's important that we insert the item directly at the proper index,
            // rather than inserting it and the moving it in place, because if there's a directive
            // on the same node that injects the `ViewContainerRef`, Angular will insert another
            // comment node which can throw off the move when it's being repeated for all items.
            return {
              templateRef: this._template,
              context: {
                $implicit: record.item,
                // It's guaranteed that the iterable is not "undefined" or "null" because we only
                // generate views for elements if the "cdkVirtualForOf" iterable has elements.
                cdkVirtualForOf: this._cdkVirtualForOf,
                index: -1,
                count: -1,
                first: false,
                last: false,
                odd: false,
                even: false
              },
              index: index
            };
          }
        }]);
        return _CdkVirtualForOf;
      }();
      _CdkVirtualForOf.ɵfac = function CdkVirtualForOf_Factory(t) {
        return new (t || _CdkVirtualForOf)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.IterableDiffers), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__._VIEW_REPEATER_STRATEGY), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_CdkVirtualScrollViewport, 4), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
      };
      _CdkVirtualForOf.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: _CdkVirtualForOf,
        selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
        inputs: {
          cdkVirtualForOf: "cdkVirtualForOf",
          cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
          cdkVirtualForTemplate: "cdkVirtualForTemplate",
          cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵProvidersFeature"]([{
          provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__._VIEW_REPEATER_STRATEGY,
          useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__._RecycleViewRepeaterStrategy
        }])]
      });
      _CdkVirtualForOf.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.IterableDiffers
        }, {
          type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__._RecycleViewRepeaterStrategy,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
            args: [_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__._VIEW_REPEATER_STRATEGY]
          }]
        }, {
          type: _CdkVirtualScrollViewport,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
          }]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
        }];
      };
      _CdkVirtualForOf.propDecorators = {
        cdkVirtualForOf: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        cdkVirtualForTrackBy: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        cdkVirtualForTemplate: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        cdkVirtualForTemplateCacheSize: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }]
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_CdkVirtualForOf, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[cdkVirtualFor][cdkVirtualForOf]',
            providers: [{
              provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__._VIEW_REPEATER_STRATEGY,
              useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__._RecycleViewRepeaterStrategy
            }]
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.IterableDiffers
          }, {
            type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__._RecycleViewRepeaterStrategy,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
              args: [_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_20__._VIEW_REPEATER_STRATEGY]
            }]
          }, {
            type: _CdkVirtualScrollViewport,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
            }]
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
          }];
        }, {
          cdkVirtualForOf: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          cdkVirtualForTrackBy: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          cdkVirtualForTemplate: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          cdkVirtualForTemplateCacheSize: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      var _CdkScrollableModule = /*#__PURE__*/_createClass(function _CdkScrollableModule() {
        _classCallCheck(this, _CdkScrollableModule);
      });
      _CdkScrollableModule.ɵfac = function CdkScrollableModule_Factory(t) {
        return new (t || _CdkScrollableModule)();
      };
      _CdkScrollableModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
        type: _CdkScrollableModule
      });
      _CdkScrollableModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_CdkScrollableModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
          args: [{
            exports: [_CdkScrollable],
            declarations: [_CdkScrollable]
          }]
        }], null, null);
      })();
      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_CdkScrollableModule, {
          declarations: [_CdkScrollable],
          exports: [_CdkScrollable]
        });
      })();
      /**
       * @docs-primary-export
       */
      var _ScrollingModule = /*#__PURE__*/_createClass(function _ScrollingModule() {
        _classCallCheck(this, _ScrollingModule);
      });
      _ScrollingModule.ɵfac = function ScrollingModule_Factory(t) {
        return new (t || _ScrollingModule)();
      };
      _ScrollingModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
        type: _ScrollingModule
      });
      _ScrollingModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
        imports: [[_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.BidiModule, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.PlatformModule, _CdkScrollableModule], _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.BidiModule, _CdkScrollableModule]
      });
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_ScrollingModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
          args: [{
            imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.BidiModule, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.PlatformModule, _CdkScrollableModule],
            exports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.BidiModule, _CdkScrollableModule, _CdkFixedSizeVirtualScroll, _CdkVirtualForOf, _CdkVirtualScrollViewport],
            declarations: [_CdkFixedSizeVirtualScroll, _CdkVirtualForOf, _CdkVirtualScrollViewport]
          }]
        }], null, null);
      })();
      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_ScrollingModule, {
          declarations: function declarations() {
            return [_CdkFixedSizeVirtualScroll, _CdkVirtualForOf, _CdkVirtualScrollViewport];
          },
          imports: function imports() {
            return [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.BidiModule, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.PlatformModule, _CdkScrollableModule];
          },
          exports: function exports() {
            return [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.BidiModule, _CdkScrollableModule, _CdkFixedSizeVirtualScroll, _CdkVirtualForOf, _CdkVirtualScrollViewport];
          }
        });
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/
    },

    /***/50298:
    /*!*************************************************************************!*\
      !*** ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/tooltip.js ***!
      \*************************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"MAT_TOOLTIP_DEFAULT_OPTIONS": function MAT_TOOLTIP_DEFAULT_OPTIONS() {
          return (/* binding */_MAT_TOOLTIP_DEFAULT_OPTIONS
          );
        },
        /* harmony export */"MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY": function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {
          return (/* binding */_MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY
          );
        },
        /* harmony export */"MAT_TOOLTIP_SCROLL_STRATEGY": function MAT_TOOLTIP_SCROLL_STRATEGY() {
          return (/* binding */_MAT_TOOLTIP_SCROLL_STRATEGY
          );
        },
        /* harmony export */"MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY": function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY() {
          return (/* binding */_MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY
          );
        },
        /* harmony export */"MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER": function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER() {
          return (/* binding */_MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER
          );
        },
        /* harmony export */"MatTooltip": function MatTooltip() {
          return (/* binding */_MatTooltip
          );
        },
        /* harmony export */"MatTooltipModule": function MatTooltipModule() {
          return (/* binding */_MatTooltipModule
          );
        },
        /* harmony export */"SCROLL_THROTTLE_MS": function SCROLL_THROTTLE_MS() {
          return (/* binding */_SCROLL_THROTTLE_MS
          );
        },
        /* harmony export */"TOOLTIP_PANEL_CLASS": function TOOLTIP_PANEL_CLASS() {
          return (/* binding */_TOOLTIP_PANEL_CLASS
          );
        },
        /* harmony export */"TooltipComponent": function TooltipComponent() {
          return (/* binding */_TooltipComponent
          );
        },
        /* harmony export */"_MatTooltipBase": function _MatTooltipBase() {
          return (/* binding */_MatTooltipBase2
          );
        },
        /* harmony export */"_TooltipComponentBase": function _TooltipComponentBase() {
          return (/* binding */_TooltipComponentBase2
          );
        },
        /* harmony export */"getMatTooltipInvalidPositionError": function getMatTooltipInvalidPositionError() {
          return (/* binding */_getMatTooltipInvalidPositionError
          );
        },
        /* harmony export */"matTooltipAnimations": function matTooltipAnimations() {
          return (/* binding */_matTooltipAnimations
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @angular/cdk/overlay */45129);
      /* harmony import */
      var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__( /*! @angular/cdk/a11y */51606);
      /* harmony import */
      var _angular_common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__( /*! @angular/common */54364);
      /* harmony import */
      var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @angular/core */2316);
      /* harmony import */
      var _angular_material_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__( /*! @angular/material/core */32220);
      /* harmony import */
      var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__( /*! @angular/cdk/scrolling */42791);
      /* harmony import */
      var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__( /*! @angular/cdk/bidi */772);
      /* harmony import */
      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! @angular/cdk/coercion */20657);
      /* harmony import */
      var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @angular/cdk/keycodes */90084);
      /* harmony import */
      var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__( /*! @angular/cdk/layout */66883);
      /* harmony import */
      var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @angular/cdk/platform */36145);
      /* harmony import */
      var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! @angular/cdk/portal */40912);
      /* harmony import */
      var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! rxjs */79441);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! rxjs/operators */22663);
      /* harmony import */
      var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! rxjs/operators */53466);
      /* harmony import */
      var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @angular/animations */97175);

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      /**
       * Animations used by MatTooltip.
       * @docs-private
       */

      var _matTooltipAnimations = {
        /** Animation that transitions a tooltip in and out. */
        tooltipState: (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.trigger)('state', [(0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.state)('initial, void, hidden', (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.style)({
          opacity: 0,
          transform: 'scale(0)'
        })), (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.state)('visible', (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.style)({
          transform: 'scale(1)'
        })), (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.transition)('* => visible', (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.animate)('200ms cubic-bezier(0, 0, 0.2, 1)', (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.keyframes)([(0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.style)({
          opacity: 0,
          transform: 'scale(0)',
          offset: 0
        }), (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.style)({
          opacity: 0.5,
          transform: 'scale(0.99)',
          offset: 0.5
        }), (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.style)({
          opacity: 1,
          transform: 'scale(1)',
          offset: 1
        })]))), (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.transition)('* => hidden', (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.animate)('100ms cubic-bezier(0, 0, 0.2, 1)', (0, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.style)({
          opacity: 0
        })))])
      };

      /** Time in ms to throttle repositioning after scroll events. */
      var _SCROLL_THROTTLE_MS = 20;
      /**
       * CSS class that will be attached to the overlay panel.
       * @deprecated
       * @breaking-change 13.0.0 remove this variable
       */
      var _TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';
      var PANEL_CLASS = 'tooltip-panel';
      /** Options used to bind passive event listeners. */
      var passiveListenerOptions = (0, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.normalizePassiveListenerOptions)({
        passive: true
      });
      /**
       * Time between the user putting the pointer on a tooltip
       * trigger and the long press event being fired.
       */
      var LONGPRESS_DELAY = 500;
      /**
       * Creates an error to be thrown if the user supplied an invalid tooltip position.
       * @docs-private
       */
      function _getMatTooltipInvalidPositionError(position) {
        return Error("Tooltip position \"".concat(position, "\" is invalid."));
      }
      /** Injection token that determines the scroll handling while a tooltip is visible. */
      var _MAT_TOOLTIP_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('mat-tooltip-scroll-strategy');
      /** @docs-private */
      function _MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay) {
        return function () {
          return overlay.scrollStrategies.reposition({
            scrollThrottle: _SCROLL_THROTTLE_MS
          });
        };
      }
      /** @docs-private */
      var _MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {
        provide: _MAT_TOOLTIP_SCROLL_STRATEGY,
        deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__.Overlay],
        useFactory: _MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY
      };
      /** Injection token to be used to override the default options for `matTooltip`. */
      var _MAT_TOOLTIP_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('mat-tooltip-default-options', {
        providedIn: 'root',
        factory: _MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY
      });
      /** @docs-private */
      function _MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {
        return {
          showDelay: 0,
          hideDelay: 0,
          touchendHideDelay: 1500
        };
      }
      var _MatTooltipBase2 = /*#__PURE__*/function () {
        function _MatTooltipBase2(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, scrollStrategy, _dir, _defaultOptions, _document) {
          var _this55 = this;
          _classCallCheck(this, _MatTooltipBase2);
          this._overlay = _overlay;
          this._elementRef = _elementRef;
          this._scrollDispatcher = _scrollDispatcher;
          this._viewContainerRef = _viewContainerRef;
          this._ngZone = _ngZone;
          this._platform = _platform;
          this._ariaDescriber = _ariaDescriber;
          this._focusMonitor = _focusMonitor;
          this._dir = _dir;
          this._defaultOptions = _defaultOptions;
          this._position = 'below';
          this._disabled = false;
          this._viewInitialized = false;
          this._pointerExitEventsInitialized = false;
          this._viewportMargin = 8;
          this._cssClassPrefix = 'mat';
          /** The default delay in ms before showing the tooltip after show is called */
          this.showDelay = this._defaultOptions.showDelay;
          /** The default delay in ms before hiding the tooltip after hide is called */
          this.hideDelay = this._defaultOptions.hideDelay;
          /**
           * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive
           * uses a long press gesture to show and hide, however it can conflict with the native browser
           * gestures. To work around the conflict, Angular Material disables native gestures on the
           * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable
           * elements). The different values for this option configure the touch event handling as follows:
           * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native
           *   browser gestures on particular elements. In particular, it allows text selection on inputs
           *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.
           * - `on` - Enables touch gestures for all elements and disables native
           *   browser gestures with no exceptions.
           * - `off` - Disables touch gestures. Note that this will prevent the tooltip from
           *   showing on touch devices.
           */
          this.touchGestures = 'auto';
          this._message = '';
          /** Manually-bound passive event listeners. */
          this._passiveListeners = [];
          /** Emits when the component is destroyed. */
          this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_4__.Subject();
          /**
           * Handles the keydown events on the host element.
           * Needs to be an arrow function so that we can use it in addEventListener.
           */
          this._handleKeydown = function (event) {
            if (_this55._isTooltipVisible() && event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.ESCAPE && !(0, _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.hasModifierKey)(event)) {
              event.preventDefault();
              event.stopPropagation();
              _this55._ngZone.run(function () {
                return _this55.hide(0);
              });
            }
          };
          this._scrollStrategy = scrollStrategy;
          this._document = _document;
          if (_defaultOptions) {
            if (_defaultOptions.position) {
              this.position = _defaultOptions.position;
            }
            if (_defaultOptions.touchGestures) {
              this.touchGestures = _defaultOptions.touchGestures;
            }
          }
          _dir.change.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.takeUntil)(this._destroyed)).subscribe(function () {
            if (_this55._overlayRef) {
              _this55._updatePosition(_this55._overlayRef);
            }
          });
          _ngZone.runOutsideAngular(function () {
            _elementRef.nativeElement.addEventListener('keydown', _this55._handleKeydown);
          });
        }
        /** Allows the user to define the position of the tooltip relative to the parent element */
        _createClass(_MatTooltipBase2, [{
          key: "position",
          get: function get() {
            return this._position;
          },
          set: function set(value) {
            var _a;
            if (value !== this._position) {
              this._position = value;
              if (this._overlayRef) {
                this._updatePosition(this._overlayRef);
                (_a = this._tooltipInstance) === null || _a === void 0 ? void 0 : _a.show(0);
                this._overlayRef.updatePosition();
              }
            }
          }
          /** Disables the display of the tooltip. */
        }, {
          key: "disabled",
          get: function get() {
            return this._disabled;
          },
          set: function set(value) {
            this._disabled = (0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_7__.coerceBooleanProperty)(value);
            // If tooltip is disabled, hide immediately.
            if (this._disabled) {
              this.hide(0);
            } else {
              this._setupPointerEnterEventsIfNeeded();
            }
          }
          /** The message to be displayed in the tooltip */
        }, {
          key: "message",
          get: function get() {
            return this._message;
          },
          set: function set(value) {
            var _this56 = this;
            this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message, 'tooltip');
            // If the message is not a string (e.g. number), convert it to a string and trim it.
            // Must convert with `String(value)`, not `${value}`, otherwise Closure Compiler optimises
            // away the string-conversion: https://github.com/angular/components/issues/20684
            this._message = value != null ? String(value).trim() : '';
            if (!this._message && this._isTooltipVisible()) {
              this.hide(0);
            } else {
              this._setupPointerEnterEventsIfNeeded();
              this._updateTooltipMessage();
              this._ngZone.runOutsideAngular(function () {
                // The `AriaDescriber` has some functionality that avoids adding a description if it's the
                // same as the `aria-label` of an element, however we can't know whether the tooltip trigger
                // has a data-bound `aria-label` or when it'll be set for the first time. We can avoid the
                // issue by deferring the description by a tick so Angular has time to set the `aria-label`.
                Promise.resolve().then(function () {
                  _this56._ariaDescriber.describe(_this56._elementRef.nativeElement, _this56.message, 'tooltip');
                });
              });
            }
          }
          /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */
        }, {
          key: "tooltipClass",
          get: function get() {
            return this._tooltipClass;
          },
          set: function set(value) {
            this._tooltipClass = value;
            if (this._tooltipInstance) {
              this._setTooltipClass(this._tooltipClass);
            }
          }
        }, {
          key: "ngAfterViewInit",
          value: function ngAfterViewInit() {
            var _this57 = this;
            // This needs to happen after view init so the initial values for all inputs have been set.
            this._viewInitialized = true;
            this._setupPointerEnterEventsIfNeeded();
            this._focusMonitor.monitor(this._elementRef).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.takeUntil)(this._destroyed)).subscribe(function (origin) {
              // Note that the focus monitor runs outside the Angular zone.
              if (!origin) {
                _this57._ngZone.run(function () {
                  return _this57.hide(0);
                });
              } else if (origin === 'keyboard') {
                _this57._ngZone.run(function () {
                  return _this57.show();
                });
              }
            });
          }
          /**
           * Dispose the tooltip when destroyed.
           */
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            var nativeElement = this._elementRef.nativeElement;
            clearTimeout(this._touchstartTimeout);
            if (this._overlayRef) {
              this._overlayRef.dispose();
              this._tooltipInstance = null;
            }
            // Clean up the event listeners set in the constructor
            nativeElement.removeEventListener('keydown', this._handleKeydown);
            this._passiveListeners.forEach(function (_ref5) {
              var _ref6 = _slicedToArray(_ref5, 2),
                event = _ref6[0],
                listener = _ref6[1];
              nativeElement.removeEventListener(event, listener, passiveListenerOptions);
            });
            this._passiveListeners.length = 0;
            this._destroyed.next();
            this._destroyed.complete();
            this._ariaDescriber.removeDescription(nativeElement, this.message, 'tooltip');
            this._focusMonitor.stopMonitoring(nativeElement);
          }
          /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
        }, {
          key: "show",
          value: function show() {
            var _this58 = this;
            var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.showDelay;
            if (this.disabled || !this.message || this._isTooltipVisible() && !this._tooltipInstance._showTimeoutId && !this._tooltipInstance._hideTimeoutId) {
              return;
            }
            var overlayRef = this._createOverlay();
            this._detach();
            this._portal = this._portal || new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__.ComponentPortal(this._tooltipComponent, this._viewContainerRef);
            this._tooltipInstance = overlayRef.attach(this._portal).instance;
            this._tooltipInstance.afterHidden().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.takeUntil)(this._destroyed)).subscribe(function () {
              return _this58._detach();
            });
            this._setTooltipClass(this._tooltipClass);
            this._updateTooltipMessage();
            this._tooltipInstance.show(delay);
          }
          /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
        }, {
          key: "hide",
          value: function hide() {
            var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hideDelay;
            if (this._tooltipInstance) {
              this._tooltipInstance.hide(delay);
            }
          }
          /** Shows/hides the tooltip */
        }, {
          key: "toggle",
          value: function toggle() {
            this._isTooltipVisible() ? this.hide() : this.show();
          }
          /** Returns true if the tooltip is currently visible to the user */
        }, {
          key: "_isTooltipVisible",
          value: function _isTooltipVisible() {
            return !!this._tooltipInstance && this._tooltipInstance.isVisible();
          }
          /** Create the overlay config and position strategy */
        }, {
          key: "_createOverlay",
          value: function _createOverlay() {
            var _this59 = this;
            if (this._overlayRef) {
              return this._overlayRef;
            }
            var scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);
            // Create connected position strategy that listens for scroll events to reposition.
            var strategy = this._overlay.position().flexibleConnectedTo(this._elementRef).withTransformOriginOn(".".concat(this._cssClassPrefix, "-tooltip")).withFlexibleDimensions(false).withViewportMargin(this._viewportMargin).withScrollableContainers(scrollableAncestors);
            strategy.positionChanges.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.takeUntil)(this._destroyed)).subscribe(function (change) {
              _this59._updateCurrentPositionClass(change.connectionPair);
              if (_this59._tooltipInstance) {
                if (change.scrollableViewProperties.isOverlayClipped && _this59._tooltipInstance.isVisible()) {
                  // After position changes occur and the overlay is clipped by
                  // a parent scrollable then close the tooltip.
                  _this59._ngZone.run(function () {
                    return _this59.hide(0);
                  });
                }
              }
            });
            this._overlayRef = this._overlay.create({
              direction: this._dir,
              positionStrategy: strategy,
              panelClass: "".concat(this._cssClassPrefix, "-").concat(PANEL_CLASS),
              scrollStrategy: this._scrollStrategy()
            });
            this._updatePosition(this._overlayRef);
            this._overlayRef.detachments().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.takeUntil)(this._destroyed)).subscribe(function () {
              return _this59._detach();
            });
            this._overlayRef.outsidePointerEvents().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.takeUntil)(this._destroyed)).subscribe(function () {
              var _a;
              return (_a = _this59._tooltipInstance) === null || _a === void 0 ? void 0 : _a._handleBodyInteraction();
            });
            return this._overlayRef;
          }
          /** Detaches the currently-attached tooltip. */
        }, {
          key: "_detach",
          value: function _detach() {
            if (this._overlayRef && this._overlayRef.hasAttached()) {
              this._overlayRef.detach();
            }
            this._tooltipInstance = null;
          }
          /** Updates the position of the current tooltip. */
        }, {
          key: "_updatePosition",
          value: function _updatePosition(overlayRef) {
            var position = overlayRef.getConfig().positionStrategy;
            var origin = this._getOrigin();
            var overlay = this._getOverlayPosition();
            position.withPositions([this._addOffset(Object.assign(Object.assign({}, origin.main), overlay.main)), this._addOffset(Object.assign(Object.assign({}, origin.fallback), overlay.fallback))]);
          }
          /** Adds the configured offset to a position. Used as a hook for child classes. */
        }, {
          key: "_addOffset",
          value: function _addOffset(position) {
            return position;
          }
          /**
           * Returns the origin position and a fallback position based on the user's position preference.
           * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).
           */
        }, {
          key: "_getOrigin",
          value: function _getOrigin() {
            var isLtr = !this._dir || this._dir.value == 'ltr';
            var position = this.position;
            var originPosition;
            if (position == 'above' || position == 'below') {
              originPosition = {
                originX: 'center',
                originY: position == 'above' ? 'top' : 'bottom'
              };
            } else if (position == 'before' || position == 'left' && isLtr || position == 'right' && !isLtr) {
              originPosition = {
                originX: 'start',
                originY: 'center'
              };
            } else if (position == 'after' || position == 'right' && isLtr || position == 'left' && !isLtr) {
              originPosition = {
                originX: 'end',
                originY: 'center'
              };
            } else if (typeof ngDevMode === 'undefined' || ngDevMode) {
              throw _getMatTooltipInvalidPositionError(position);
            }
            var _this$_invertPosition = this._invertPosition(originPosition.originX, originPosition.originY),
              x = _this$_invertPosition.x,
              y = _this$_invertPosition.y;
            return {
              main: originPosition,
              fallback: {
                originX: x,
                originY: y
              }
            };
          }
          /** Returns the overlay position and a fallback position based on the user's preference */
        }, {
          key: "_getOverlayPosition",
          value: function _getOverlayPosition() {
            var isLtr = !this._dir || this._dir.value == 'ltr';
            var position = this.position;
            var overlayPosition;
            if (position == 'above') {
              overlayPosition = {
                overlayX: 'center',
                overlayY: 'bottom'
              };
            } else if (position == 'below') {
              overlayPosition = {
                overlayX: 'center',
                overlayY: 'top'
              };
            } else if (position == 'before' || position == 'left' && isLtr || position == 'right' && !isLtr) {
              overlayPosition = {
                overlayX: 'end',
                overlayY: 'center'
              };
            } else if (position == 'after' || position == 'right' && isLtr || position == 'left' && !isLtr) {
              overlayPosition = {
                overlayX: 'start',
                overlayY: 'center'
              };
            } else if (typeof ngDevMode === 'undefined' || ngDevMode) {
              throw _getMatTooltipInvalidPositionError(position);
            }
            var _this$_invertPosition2 = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY),
              x = _this$_invertPosition2.x,
              y = _this$_invertPosition2.y;
            return {
              main: overlayPosition,
              fallback: {
                overlayX: x,
                overlayY: y
              }
            };
          }
          /** Updates the tooltip message and repositions the overlay according to the new message length */
        }, {
          key: "_updateTooltipMessage",
          value: function _updateTooltipMessage() {
            var _this60 = this;
            // Must wait for the message to be painted to the tooltip so that the overlay can properly
            // calculate the correct positioning based on the size of the text.
            if (this._tooltipInstance) {
              this._tooltipInstance.message = this.message;
              this._tooltipInstance._markForCheck();
              this._ngZone.onMicrotaskEmpty.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.take)(1), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.takeUntil)(this._destroyed)).subscribe(function () {
                if (_this60._tooltipInstance) {
                  _this60._overlayRef.updatePosition();
                }
              });
            }
          }
          /** Updates the tooltip class */
        }, {
          key: "_setTooltipClass",
          value: function _setTooltipClass(tooltipClass) {
            if (this._tooltipInstance) {
              this._tooltipInstance.tooltipClass = tooltipClass;
              this._tooltipInstance._markForCheck();
            }
          }
          /** Inverts an overlay position. */
        }, {
          key: "_invertPosition",
          value: function _invertPosition(x, y) {
            if (this.position === 'above' || this.position === 'below') {
              if (y === 'top') {
                y = 'bottom';
              } else if (y === 'bottom') {
                y = 'top';
              }
            } else {
              if (x === 'end') {
                x = 'start';
              } else if (x === 'start') {
                x = 'end';
              }
            }
            return {
              x: x,
              y: y
            };
          }
          /** Updates the class on the overlay panel based on the current position of the tooltip. */
        }, {
          key: "_updateCurrentPositionClass",
          value: function _updateCurrentPositionClass(connectionPair) {
            var overlayY = connectionPair.overlayY,
              originX = connectionPair.originX,
              originY = connectionPair.originY;
            var newPosition;
            // If the overlay is in the middle along the Y axis,
            // it means that it's either before or after.
            if (overlayY === 'center') {
              // Note that since this information is used for styling, we want to
              // resolve `start` and `end` to their real values, otherwise consumers
              // would have to remember to do it themselves on each consumption.
              if (this._dir && this._dir.value === 'rtl') {
                newPosition = originX === 'end' ? 'left' : 'right';
              } else {
                newPosition = originX === 'start' ? 'left' : 'right';
              }
            } else {
              newPosition = overlayY === 'bottom' && originY === 'top' ? 'above' : 'below';
            }
            if (newPosition !== this._currentPosition) {
              var overlayRef = this._overlayRef;
              if (overlayRef) {
                var classPrefix = "".concat(this._cssClassPrefix, "-").concat(PANEL_CLASS, "-");
                overlayRef.removePanelClass(classPrefix + this._currentPosition);
                overlayRef.addPanelClass(classPrefix + newPosition);
              }
              this._currentPosition = newPosition;
            }
          }
          /** Binds the pointer events to the tooltip trigger. */
        }, {
          key: "_setupPointerEnterEventsIfNeeded",
          value: function _setupPointerEnterEventsIfNeeded() {
            var _this61 = this;
            // Optimization: Defer hooking up events if there's no message or the tooltip is disabled.
            if (this._disabled || !this.message || !this._viewInitialized || this._passiveListeners.length) {
              return;
            }
            // The mouse events shouldn't be bound on mobile devices, because they can prevent the
            // first tap from firing its click event or can cause the tooltip to open for clicks.
            if (this._platformSupportsMouseEvents()) {
              this._passiveListeners.push(['mouseenter', function () {
                _this61._setupPointerExitEventsIfNeeded();
                _this61.show();
              }]);
            } else if (this.touchGestures !== 'off') {
              this._disableNativeGesturesIfNecessary();
              this._passiveListeners.push(['touchstart', function () {
                // Note that it's important that we don't `preventDefault` here,
                // because it can prevent click events from firing on the element.
                _this61._setupPointerExitEventsIfNeeded();
                clearTimeout(_this61._touchstartTimeout);
                _this61._touchstartTimeout = setTimeout(function () {
                  return _this61.show();
                }, LONGPRESS_DELAY);
              }]);
            }
            this._addListeners(this._passiveListeners);
          }
        }, {
          key: "_setupPointerExitEventsIfNeeded",
          value: function _setupPointerExitEventsIfNeeded() {
            var _this62 = this,
              _this$_passiveListene;
            if (this._pointerExitEventsInitialized) {
              return;
            }
            this._pointerExitEventsInitialized = true;
            var exitListeners = [];
            if (this._platformSupportsMouseEvents()) {
              exitListeners.push(['mouseleave', function () {
                return _this62.hide();
              }], ['wheel', function (event) {
                return _this62._wheelListener(event);
              }]);
            } else if (this.touchGestures !== 'off') {
              this._disableNativeGesturesIfNecessary();
              var touchendListener = function touchendListener() {
                clearTimeout(_this62._touchstartTimeout);
                _this62.hide(_this62._defaultOptions.touchendHideDelay);
              };
              exitListeners.push(['touchend', touchendListener], ['touchcancel', touchendListener]);
            }
            this._addListeners(exitListeners);
            (_this$_passiveListene = this._passiveListeners).push.apply(_this$_passiveListene, exitListeners);
          }
        }, {
          key: "_addListeners",
          value: function _addListeners(listeners) {
            var _this63 = this;
            listeners.forEach(function (_ref7) {
              var _ref8 = _slicedToArray(_ref7, 2),
                event = _ref8[0],
                listener = _ref8[1];
              _this63._elementRef.nativeElement.addEventListener(event, listener, passiveListenerOptions);
            });
          }
        }, {
          key: "_platformSupportsMouseEvents",
          value: function _platformSupportsMouseEvents() {
            return !this._platform.IOS && !this._platform.ANDROID;
          }
          /** Listener for the `wheel` event on the element. */
        }, {
          key: "_wheelListener",
          value: function _wheelListener(event) {
            if (this._isTooltipVisible()) {
              var elementUnderPointer = this._document.elementFromPoint(event.clientX, event.clientY);
              var element = this._elementRef.nativeElement;
              // On non-touch devices we depend on the `mouseleave` event to close the tooltip, but it
              // won't fire if the user scrolls away using the wheel without moving their cursor. We
              // work around it by finding the element under the user's cursor and closing the tooltip
              // if it's not the trigger.
              if (elementUnderPointer !== element && !element.contains(elementUnderPointer)) {
                this.hide();
              }
            }
          }
          /** Disables the native browser gestures, based on how the tooltip has been configured. */
        }, {
          key: "_disableNativeGesturesIfNecessary",
          value: function _disableNativeGesturesIfNecessary() {
            var gestures = this.touchGestures;
            if (gestures !== 'off') {
              var element = this._elementRef.nativeElement;
              var style = element.style;
              // If gestures are set to `auto`, we don't disable text selection on inputs and
              // textareas, because it prevents the user from typing into them on iOS Safari.
              if (gestures === 'on' || element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA') {
                style.userSelect = style.msUserSelect = style.webkitUserSelect = style.MozUserSelect = 'none';
              }
              // If we have `auto` gestures and the element uses native HTML dragging,
              // we don't set `-webkit-user-drag` because it prevents the native behavior.
              if (gestures === 'on' || !element.draggable) {
                style.webkitUserDrag = 'none';
              }
              style.touchAction = 'none';
              style.webkitTapHighlightColor = 'transparent';
            }
          }
        }]);
        return _MatTooltipBase2;
      }();
      _MatTooltipBase2.ɵfac = function _MatTooltipBase_Factory(t) {
        return new (t || _MatTooltipBase2)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__.Overlay), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_10__.ScrollDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.AriaDescriber), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.FocusMonitor), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](undefined), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](undefined), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_13__.DOCUMENT));
      };
      _MatTooltipBase2.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineDirective"]({
        type: _MatTooltipBase2,
        inputs: {
          showDelay: ["matTooltipShowDelay", "showDelay"],
          hideDelay: ["matTooltipHideDelay", "hideDelay"],
          touchGestures: ["matTooltipTouchGestures", "touchGestures"],
          position: ["matTooltipPosition", "position"],
          disabled: ["matTooltipDisabled", "disabled"],
          message: ["matTooltip", "message"],
          tooltipClass: ["matTooltipClass", "tooltipClass"]
        }
      });
      _MatTooltipBase2.ctorParameters = function () {
        return [{
          type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__.Overlay
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef
        }, {
          type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_10__.ScrollDispatcher
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone
        }, {
          type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
        }, {
          type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.AriaDescriber
        }, {
          type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.FocusMonitor
        }, {
          type: undefined
        }, {
          type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality
        }, {
          type: undefined
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_13__.DOCUMENT]
          }]
        }];
      };
      _MatTooltipBase2.propDecorators = {
        position: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
          args: ['matTooltipPosition']
        }],
        disabled: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
          args: ['matTooltipDisabled']
        }],
        showDelay: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
          args: ['matTooltipShowDelay']
        }],
        hideDelay: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
          args: ['matTooltipHideDelay']
        }],
        touchGestures: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
          args: ['matTooltipTouchGestures']
        }],
        message: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
          args: ['matTooltip']
        }],
        tooltipClass: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
          args: ['matTooltipClass']
        }]
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](_MatTooltipBase2, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive
        }], function () {
          return [{
            type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__.Overlay
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef
          }, {
            type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_10__.ScrollDispatcher
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone
          }, {
            type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
          }, {
            type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.AriaDescriber
          }, {
            type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.FocusMonitor
          }, {
            type: undefined
          }, {
            type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality
          }, {
            type: undefined
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_13__.DOCUMENT]
            }]
          }];
        }, {
          showDelay: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
            args: ['matTooltipShowDelay']
          }],
          hideDelay: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
            args: ['matTooltipHideDelay']
          }],
          touchGestures: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
            args: ['matTooltipTouchGestures']
          }],
          position: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
            args: ['matTooltipPosition']
          }],
          disabled: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
            args: ['matTooltipDisabled']
          }],
          message: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
            args: ['matTooltip']
          }],
          tooltipClass: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,
            args: ['matTooltipClass']
          }]
        });
      })();
      /**
       * Directive that attaches a material design tooltip to the host element. Animates the showing and
       * hiding of a tooltip provided position (defaults to below the element).
       *
       * https://material.io/design/components/tooltips.html
       */
      var _MatTooltip = /*#__PURE__*/function (_MatTooltipBase3) {
        _inherits(_MatTooltip, _MatTooltipBase3);
        var _super16 = _createSuper(_MatTooltip);
        function _MatTooltip(overlay, elementRef, scrollDispatcher, viewContainerRef, ngZone, platform, ariaDescriber, focusMonitor, scrollStrategy, dir, defaultOptions, _document) {
          var _this64;
          _classCallCheck(this, _MatTooltip);
          _this64 = _super16.call(this, overlay, elementRef, scrollDispatcher, viewContainerRef, ngZone, platform, ariaDescriber, focusMonitor, scrollStrategy, dir, defaultOptions, _document);
          _this64._tooltipComponent = _TooltipComponent;
          return _this64;
        }
        return _createClass(_MatTooltip);
      }(_MatTooltipBase2);
      _MatTooltip.ɵfac = function MatTooltip_Factory(t) {
        return new (t || _MatTooltip)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__.Overlay), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_10__.ScrollDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.AriaDescriber), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.FocusMonitor), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_MAT_TOOLTIP_SCROLL_STRATEGY), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality, 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_MAT_TOOLTIP_DEFAULT_OPTIONS, 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_13__.DOCUMENT));
      };
      _MatTooltip.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineDirective"]({
        type: _MatTooltip,
        selectors: [["", "matTooltip", ""]],
        hostAttrs: [1, "mat-tooltip-trigger"],
        exportAs: ["matTooltip"],
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵInheritDefinitionFeature"]]
      });
      _MatTooltip.ctorParameters = function () {
        return [{
          type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__.Overlay
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef
        }, {
          type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_10__.ScrollDispatcher
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone
        }, {
          type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
        }, {
          type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.AriaDescriber
        }, {
          type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.FocusMonitor
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
            args: [_MAT_TOOLTIP_SCROLL_STRATEGY]
          }]
        }, {
          type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional
          }]
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
            args: [_MAT_TOOLTIP_DEFAULT_OPTIONS]
          }]
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_13__.DOCUMENT]
          }]
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](_MatTooltip, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,
          args: [{
            selector: '[matTooltip]',
            exportAs: 'matTooltip',
            host: {
              'class': 'mat-tooltip-trigger'
            }
          }]
        }], function () {
          return [{
            type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__.Overlay
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef
          }, {
            type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_10__.ScrollDispatcher
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone
          }, {
            type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
          }, {
            type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.AriaDescriber
          }, {
            type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.FocusMonitor
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
              args: [_MAT_TOOLTIP_SCROLL_STRATEGY]
            }]
          }, {
            type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_12__.Directionality,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional
            }]
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional
            }, {
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
              args: [_MAT_TOOLTIP_DEFAULT_OPTIONS]
            }]
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_13__.DOCUMENT]
            }]
          }];
        }, null);
      })();
      var _TooltipComponentBase2 = /*#__PURE__*/function () {
        function _TooltipComponentBase2(_changeDetectorRef) {
          _classCallCheck(this, _TooltipComponentBase2);
          this._changeDetectorRef = _changeDetectorRef;
          /** Property watched by the animation framework to show or hide the tooltip */
          this._visibility = 'initial';
          /** Whether interactions on the page should close the tooltip */
          this._closeOnInteraction = false;
          /** Subject for notifying that the tooltip has been hidden from the view */
          this._onHide = new rxjs__WEBPACK_IMPORTED_MODULE_4__.Subject();
        }
        /**
         * Shows the tooltip with an animation originating from the provided origin
         * @param delay Amount of milliseconds to the delay showing the tooltip.
         */
        _createClass(_TooltipComponentBase2, [{
          key: "show",
          value: function show(delay) {
            var _this65 = this;
            // Cancel the delayed hide if it is scheduled
            clearTimeout(this._hideTimeoutId);
            // Body interactions should cancel the tooltip if there is a delay in showing.
            this._closeOnInteraction = true;
            this._showTimeoutId = setTimeout(function () {
              _this65._visibility = 'visible';
              _this65._showTimeoutId = undefined;
              _this65._onShow();
              // Mark for check so if any parent component has set the
              // ChangeDetectionStrategy to OnPush it will be checked anyways
              _this65._markForCheck();
            }, delay);
          }
          /**
           * Begins the animation to hide the tooltip after the provided delay in ms.
           * @param delay Amount of milliseconds to delay showing the tooltip.
           */
        }, {
          key: "hide",
          value: function hide(delay) {
            var _this66 = this;
            // Cancel the delayed show if it is scheduled
            clearTimeout(this._showTimeoutId);
            this._hideTimeoutId = setTimeout(function () {
              _this66._visibility = 'hidden';
              _this66._hideTimeoutId = undefined;
              // Mark for check so if any parent component has set the
              // ChangeDetectionStrategy to OnPush it will be checked anyways
              _this66._markForCheck();
            }, delay);
          }
          /** Returns an observable that notifies when the tooltip has been hidden from view. */
        }, {
          key: "afterHidden",
          value: function afterHidden() {
            return this._onHide;
          }
          /** Whether the tooltip is being displayed. */
        }, {
          key: "isVisible",
          value: function isVisible() {
            return this._visibility === 'visible';
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            clearTimeout(this._showTimeoutId);
            clearTimeout(this._hideTimeoutId);
            this._onHide.complete();
          }
        }, {
          key: "_animationStart",
          value: function _animationStart() {
            this._closeOnInteraction = false;
          }
        }, {
          key: "_animationDone",
          value: function _animationDone(event) {
            var toState = event.toState;
            if (toState === 'hidden' && !this.isVisible()) {
              this._onHide.next();
            }
            if (toState === 'visible' || toState === 'hidden') {
              this._closeOnInteraction = true;
            }
          }
          /**
           * Interactions on the HTML body should close the tooltip immediately as defined in the
           * material design spec.
           * https://material.io/design/components/tooltips.html#behavior
           */
        }, {
          key: "_handleBodyInteraction",
          value: function _handleBodyInteraction() {
            if (this._closeOnInteraction) {
              this.hide(0);
            }
          }
          /**
           * Marks that the tooltip needs to be checked in the next change detection run.
           * Mainly used for rendering the initial text before positioning a tooltip, which
           * can be problematic in components with OnPush change detection.
           */
        }, {
          key: "_markForCheck",
          value: function _markForCheck() {
            this._changeDetectorRef.markForCheck();
          }
          /**
           * Callback for when the timeout in this.show() gets completed.
           * This method is only needed by the mdc-tooltip, and so it is only implemented
           * in the mdc-tooltip, not here.
           */
        }, {
          key: "_onShow",
          value: function _onShow() {}
        }]);
        return _TooltipComponentBase2;
      }();
      _TooltipComponentBase2.ɵfac = function _TooltipComponentBase_Factory(t) {
        return new (t || _TooltipComponentBase2)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef));
      };
      _TooltipComponentBase2.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineDirective"]({
        type: _TooltipComponentBase2
      });
      _TooltipComponentBase2.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](_TooltipComponentBase2, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef
          }];
        }, null);
      })();
      /**
       * Internal component that wraps the tooltip's content.
       * @docs-private
       */
      var _TooltipComponent = /*#__PURE__*/function (_TooltipComponentBase3) {
        _inherits(_TooltipComponent, _TooltipComponentBase3);
        var _super17 = _createSuper(_TooltipComponent);
        function _TooltipComponent(changeDetectorRef, _breakpointObserver) {
          var _this67;
          _classCallCheck(this, _TooltipComponent);
          _this67 = _super17.call(this, changeDetectorRef);
          _this67._breakpointObserver = _breakpointObserver;
          /** Stream that emits whether the user has a handset-sized display.  */
          _this67._isHandset = _this67._breakpointObserver.observe(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_14__.Breakpoints.Handset);
          return _this67;
        }
        return _createClass(_TooltipComponent);
      }(_TooltipComponentBase2);
      _TooltipComponent.ɵfac = function TooltipComponent_Factory(t) {
        return new (t || _TooltipComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_14__.BreakpointObserver));
      };
      _TooltipComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineComponent"]({
        type: _TooltipComponent,
        selectors: [["mat-tooltip-component"]],
        hostAttrs: ["aria-hidden", "true"],
        hostVars: 2,
        hostBindings: function TooltipComponent_HostBindings(rf, ctx) {
          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵstyleProp"]("zoom", ctx._visibility === "visible" ? 1 : null);
          }
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵInheritDefinitionFeature"]],
        decls: 3,
        vars: 7,
        consts: [[1, "mat-tooltip", 3, "ngClass"]],
        template: function TooltipComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]("@state.start", function TooltipComponent_Template_div_animation_state_start_0_listener() {
              return ctx._animationStart();
            })("@state.done", function TooltipComponent_Template_div_animation_state_done_0_listener($event) {
              return ctx._animationDone($event);
            });
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipe"](1, "async");
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtext"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
          }
          if (rf & 2) {
            var tmp_0_0;
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵclassProp"]("mat-tooltip-handset", (tmp_0_0 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpipeBind1"](1, 5, ctx._isHandset)) == null ? null : tmp_0_0.matches);
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngClass", ctx.tooltipClass)("@state", ctx._visibility);
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate"](ctx.message);
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_13__.NgClass],
        pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_13__.AsyncPipe],
        styles: [".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n"],
        encapsulation: 2,
        data: {
          animation: [_matTooltipAnimations.tooltipState]
        },
        changeDetection: 0
      });
      _TooltipComponent.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef
        }, {
          type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_14__.BreakpointObserver
        }];
      };
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](_TooltipComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Component,
          args: [{
            selector: 'mat-tooltip-component',
            template: "<div class=\"mat-tooltip\"\n     [ngClass]=\"tooltipClass\"\n     [class.mat-tooltip-handset]=\"(_isHandset | async)?.matches\"\n     [@state]=\"_visibility\"\n     (@state.start)=\"_animationStart()\"\n     (@state.done)=\"_animationDone($event)\">{{message}}</div>\n",
            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.None,
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy.OnPush,
            animations: [_matTooltipAnimations.tooltipState],
            host: {
              // Forces the element to have a layout in IE and Edge. This fixes issues where the element
              // won't be rendered if the animations are disabled or there is no web animations polyfill.
              '[style.zoom]': '_visibility === "visible" ? 1 : null',
              'aria-hidden': 'true'
            },
            styles: [".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\n"]
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef
          }, {
            type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_14__.BreakpointObserver
          }];
        }, null);
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      var _MatTooltipModule = /*#__PURE__*/_createClass(function _MatTooltipModule() {
        _classCallCheck(this, _MatTooltipModule);
      });
      _MatTooltipModule.ɵfac = function MatTooltipModule_Factory(t) {
        return new (t || _MatTooltipModule)();
      };
      _MatTooltipModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
        type: _MatTooltipModule
      });
      _MatTooltipModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjector"]({
        providers: [_MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER],
        imports: [[_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.A11yModule, _angular_common__WEBPACK_IMPORTED_MODULE_13__.CommonModule, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__.OverlayModule, _angular_material_core__WEBPACK_IMPORTED_MODULE_15__.MatCommonModule], _angular_material_core__WEBPACK_IMPORTED_MODULE_15__.MatCommonModule, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_10__.CdkScrollableModule]
      });
      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](_MatTooltipModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgModule,
          args: [{
            imports: [_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.A11yModule, _angular_common__WEBPACK_IMPORTED_MODULE_13__.CommonModule, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__.OverlayModule, _angular_material_core__WEBPACK_IMPORTED_MODULE_15__.MatCommonModule],
            exports: [_MatTooltip, _TooltipComponent, _angular_material_core__WEBPACK_IMPORTED_MODULE_15__.MatCommonModule, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_10__.CdkScrollableModule],
            declarations: [_MatTooltip, _TooltipComponent],
            entryComponents: [_TooltipComponent],
            providers: [_MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER]
          }]
        }], null, null);
      })();
      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵsetNgModuleScope"](_MatTooltipModule, {
          declarations: function declarations() {
            return [_MatTooltip, _TooltipComponent];
          },
          imports: function imports() {
            return [_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_11__.A11yModule, _angular_common__WEBPACK_IMPORTED_MODULE_13__.CommonModule, _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_3__.OverlayModule, _angular_material_core__WEBPACK_IMPORTED_MODULE_15__.MatCommonModule];
          },
          exports: function exports() {
            return [_MatTooltip, _TooltipComponent, _angular_material_core__WEBPACK_IMPORTED_MODULE_15__.MatCommonModule, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_10__.CdkScrollableModule];
          }
        });
      })();

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */

      /***/
    },

    /***/93621:
    /*!*************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/Notification.js ***!
      \*************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"NotificationKind": function NotificationKind() {
          return (/* binding */_NotificationKind
          );
        },
        /* harmony export */"Notification": function Notification() {
          return (/* binding */_Notification
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./observable/empty */8117);
      /* harmony import */
      var _observable_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./observable/of */81134);
      /* harmony import */
      var _observable_throwError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./observable/throwError */45871);
      var _NotificationKind;
      (function (NotificationKind) {
        NotificationKind["NEXT"] = "N";
        NotificationKind["ERROR"] = "E";
        NotificationKind["COMPLETE"] = "C";
      })(_NotificationKind || (_NotificationKind = {}));
      var _Notification = /*#__PURE__*/function () {
        function _Notification(kind, value, error) {
          _classCallCheck(this, _Notification);
          this.kind = kind;
          this.value = value;
          this.error = error;
          this.hasValue = kind === 'N';
        }
        _createClass(_Notification, [{
          key: "observe",
          value: function observe(observer) {
            switch (this.kind) {
              case 'N':
                return observer.next && observer.next(this.value);
              case 'E':
                return observer.error && observer.error(this.error);
              case 'C':
                return observer.complete && observer.complete();
            }
          }
        }, {
          key: "do",
          value: function _do(next, error, complete) {
            var kind = this.kind;
            switch (kind) {
              case 'N':
                return next && next(this.value);
              case 'E':
                return error && error(this.error);
              case 'C':
                return complete && complete();
            }
          }
        }, {
          key: "accept",
          value: function accept(nextOrObserver, error, complete) {
            if (nextOrObserver && typeof nextOrObserver.next === 'function') {
              return this.observe(nextOrObserver);
            } else {
              return this["do"](nextOrObserver, error, complete);
            }
          }
        }, {
          key: "toObservable",
          value: function toObservable() {
            var kind = this.kind;
            switch (kind) {
              case 'N':
                return (0, _observable_of__WEBPACK_IMPORTED_MODULE_0__.of)(this.value);
              case 'E':
                return (0, _observable_throwError__WEBPACK_IMPORTED_MODULE_1__.throwError)(this.error);
              case 'C':
                return (0, _observable_empty__WEBPACK_IMPORTED_MODULE_2__.empty)();
            }
            throw new Error('unexpected notification kind value');
          }
        }], [{
          key: "createNext",
          value: function createNext(value) {
            if (typeof value !== 'undefined') {
              return new _Notification('N', value);
            }
            return _Notification.undefinedValueNotification;
          }
        }, {
          key: "createError",
          value: function createError(err) {
            return new _Notification('E', undefined, err);
          }
        }, {
          key: "createComplete",
          value: function createComplete() {
            return _Notification.completeNotification;
          }
        }]);
        return _Notification;
      }();
      _Notification.completeNotification = new _Notification('C');
      _Notification.undefinedValueNotification = new _Notification('N', undefined);

      /***/
    },

    /***/13413:
    /*!**************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/ReplaySubject.js ***!
      \**************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"ReplaySubject": function ReplaySubject() {
          return (/* binding */_ReplaySubject
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./Subject */79441);
      /* harmony import */
      var _scheduler_queue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! ./scheduler/queue */75751);
      /* harmony import */
      var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./Subscription */94283);
      /* harmony import */
      var _operators_observeOn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! ./operators/observeOn */93253);
      /* harmony import */
      var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./util/ObjectUnsubscribedError */96874);
      /* harmony import */
      var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ./SubjectSubscription */32691);
      var _ReplaySubject = /*#__PURE__*/function (_Subject__WEBPACK_IMP) {
        _inherits(_ReplaySubject, _Subject__WEBPACK_IMP);
        var _super18 = _createSuper(_ReplaySubject);
        function _ReplaySubject() {
          var _this68;
          var bufferSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;
          var windowTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;
          var scheduler = arguments.length > 2 ? arguments[2] : undefined;
          _classCallCheck(this, _ReplaySubject);
          _this68 = _super18.call(this);
          _this68.scheduler = scheduler;
          _this68._events = [];
          _this68._infiniteTimeWindow = false;
          _this68._bufferSize = bufferSize < 1 ? 1 : bufferSize;
          _this68._windowTime = windowTime < 1 ? 1 : windowTime;
          if (windowTime === Number.POSITIVE_INFINITY) {
            _this68._infiniteTimeWindow = true;
            _this68.next = _this68.nextInfiniteTimeWindow;
          } else {
            _this68.next = _this68.nextTimeWindow;
          }
          return _this68;
        }
        _createClass(_ReplaySubject, [{
          key: "nextInfiniteTimeWindow",
          value: function nextInfiniteTimeWindow(value) {
            if (!this.isStopped) {
              var _events = this._events;
              _events.push(value);
              if (_events.length > this._bufferSize) {
                _events.shift();
              }
            }
            _get(_getPrototypeOf(_ReplaySubject.prototype), "next", this).call(this, value);
          }
        }, {
          key: "nextTimeWindow",
          value: function nextTimeWindow(value) {
            if (!this.isStopped) {
              this._events.push(new ReplayEvent(this._getNow(), value));
              this._trimBufferThenGetEvents();
            }
            _get(_getPrototypeOf(_ReplaySubject.prototype), "next", this).call(this, value);
          }
        }, {
          key: "_subscribe",
          value: function _subscribe(subscriber) {
            var _infiniteTimeWindow = this._infiniteTimeWindow;
            var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
            var scheduler = this.scheduler;
            var len = _events.length;
            var subscription;
            if (this.closed) {
              throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__.ObjectUnsubscribedError();
            } else if (this.isStopped || this.hasError) {
              subscription = _Subscription__WEBPACK_IMPORTED_MODULE_2__.Subscription.EMPTY;
            } else {
              this.observers.push(subscriber);
              subscription = new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_3__.SubjectSubscription(this, subscriber);
            }
            if (scheduler) {
              subscriber.add(subscriber = new _operators_observeOn__WEBPACK_IMPORTED_MODULE_4__.ObserveOnSubscriber(subscriber, scheduler));
            }
            if (_infiniteTimeWindow) {
              for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
              }
            } else {
              for (var _i3 = 0; _i3 < len && !subscriber.closed; _i3++) {
                subscriber.next(_events[_i3].value);
              }
            }
            if (this.hasError) {
              subscriber.error(this.thrownError);
            } else if (this.isStopped) {
              subscriber.complete();
            }
            return subscription;
          }
        }, {
          key: "_getNow",
          value: function _getNow() {
            return (this.scheduler || _scheduler_queue__WEBPACK_IMPORTED_MODULE_5__.queue).now();
          }
        }, {
          key: "_trimBufferThenGetEvents",
          value: function _trimBufferThenGetEvents() {
            var now = this._getNow();
            var _bufferSize = this._bufferSize;
            var _windowTime = this._windowTime;
            var _events = this._events;
            var eventsCount = _events.length;
            var spliceCount = 0;
            while (spliceCount < eventsCount) {
              if (now - _events[spliceCount].time < _windowTime) {
                break;
              }
              spliceCount++;
            }
            if (eventsCount > _bufferSize) {
              spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
            }
            if (spliceCount > 0) {
              _events.splice(0, spliceCount);
            }
            return _events;
          }
        }]);
        return _ReplaySubject;
      }(_Subject__WEBPACK_IMPORTED_MODULE_0__.Subject);
      var ReplayEvent = /*#__PURE__*/_createClass(function ReplayEvent(time, value) {
        _classCallCheck(this, ReplayEvent);
        this.time = time;
        this.value = value;
      });
      /***/
    },
    /***/45871:
    /*!**********************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/observable/throwError.js ***!
      \**********************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"throwError": function throwError() {
          return (/* binding */_throwError
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../Observable */25160);
      function _throwError(error, scheduler) {
        if (!scheduler) {
          return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
            return subscriber.error(error);
          });
        } else {
          return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
            return scheduler.schedule(dispatch, 0, {
              error: error,
              subscriber: subscriber
            });
          });
        }
      }
      function dispatch(_ref9) {
        var error = _ref9.error,
          subscriber = _ref9.subscriber;
        subscriber.error(error);
      }

      /***/
    },

    /***/12702:
    /*!*****************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/observable/timer.js ***!
      \*****************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"timer": function timer() {
          return (/* binding */_timer
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ../Observable */25160);
      /* harmony import */
      var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ../scheduler/async */32606);
      /* harmony import */
      var _util_isNumeric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../util/isNumeric */82867);
      /* harmony import */
      var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ../util/isScheduler */86770);
      function _timer() {
        var dueTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var periodOrScheduler = arguments.length > 1 ? arguments[1] : undefined;
        var scheduler = arguments.length > 2 ? arguments[2] : undefined;
        var period = -1;
        if ((0, _util_isNumeric__WEBPACK_IMPORTED_MODULE_0__.isNumeric)(periodOrScheduler)) {
          period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
        } else if ((0, _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.isScheduler)(periodOrScheduler)) {
          scheduler = periodOrScheduler;
        }
        if (!(0, _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.isScheduler)(scheduler)) {
          scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__.async;
        }
        return new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(function (subscriber) {
          var due = (0, _util_isNumeric__WEBPACK_IMPORTED_MODULE_0__.isNumeric)(dueTime) ? dueTime : +dueTime - scheduler.now();
          return scheduler.schedule(dispatch, due, {
            index: 0,
            period: period,
            subscriber: subscriber
          });
        });
      }
      function dispatch(state) {
        var index = state.index,
          period = state.period,
          subscriber = state.subscriber;
        subscriber.next(index);
        if (subscriber.closed) {
          return;
        } else if (period === -1) {
          return subscriber.complete();
        }
        state.index = index + 1;
        this.schedule(state, period);
      }

      /***/
    },

    /***/527:
    /*!****************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/operators/audit.js ***!
      \****************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"audit": function audit() {
          return (/* binding */_audit
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../innerSubscribe */27272);
      function _audit(durationSelector) {
        return function auditOperatorFunction(source) {
          return source.lift(new AuditOperator(durationSelector));
        };
      }
      var AuditOperator = /*#__PURE__*/function () {
        function AuditOperator(durationSelector) {
          _classCallCheck(this, AuditOperator);
          this.durationSelector = durationSelector;
        }
        _createClass(AuditOperator, [{
          key: "call",
          value: function call(subscriber, source) {
            return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
          }
        }]);
        return AuditOperator;
      }();
      var AuditSubscriber = /*#__PURE__*/function (_innerSubscribe__WEBP) {
        _inherits(AuditSubscriber, _innerSubscribe__WEBP);
        var _super19 = _createSuper(AuditSubscriber);
        function AuditSubscriber(destination, durationSelector) {
          var _this69;
          _classCallCheck(this, AuditSubscriber);
          _this69 = _super19.call(this, destination);
          _this69.durationSelector = durationSelector;
          _this69.hasValue = false;
          return _this69;
        }
        _createClass(AuditSubscriber, [{
          key: "_next",
          value: function _next(value) {
            this.value = value;
            this.hasValue = true;
            if (!this.throttled) {
              var duration;
              try {
                var durationSelector = this.durationSelector;
                duration = durationSelector(value);
              } catch (err) {
                return this.destination.error(err);
              }
              var innerSubscription = (0, _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__.innerSubscribe)(duration, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__.SimpleInnerSubscriber(this));
              if (!innerSubscription || innerSubscription.closed) {
                this.clearThrottle();
              } else {
                this.add(this.throttled = innerSubscription);
              }
            }
          }
        }, {
          key: "clearThrottle",
          value: function clearThrottle() {
            var value = this.value,
              hasValue = this.hasValue,
              throttled = this.throttled;
            if (throttled) {
              this.remove(throttled);
              this.throttled = undefined;
              throttled.unsubscribe();
            }
            if (hasValue) {
              this.value = undefined;
              this.hasValue = false;
              this.destination.next(value);
            }
          }
        }, {
          key: "notifyNext",
          value: function notifyNext() {
            this.clearThrottle();
          }
        }, {
          key: "notifyComplete",
          value: function notifyComplete() {
            this.clearThrottle();
          }
        }]);
        return AuditSubscriber;
      }(_innerSubscribe__WEBPACK_IMPORTED_MODULE_0__.SimpleOuterSubscriber);
      /***/
    },
    /***/7494:
    /*!********************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/operators/auditTime.js ***!
      \********************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"auditTime": function auditTime() {
          return (/* binding */_auditTime
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../scheduler/async */32606);
      /* harmony import */
      var _audit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./audit */527);
      /* harmony import */
      var _observable_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ../observable/timer */12702);
      function _auditTime(duration) {
        var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async;
        return (0, _audit__WEBPACK_IMPORTED_MODULE_1__.audit)(function () {
          return (0, _observable_timer__WEBPACK_IMPORTED_MODULE_2__.timer)(duration, scheduler);
        });
      }

      /***/
    },

    /***/93253:
    /*!********************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/operators/observeOn.js ***!
      \********************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"observeOn": function observeOn() {
          return (/* binding */_observeOn
          );
        },
        /* harmony export */"ObserveOnOperator": function ObserveOnOperator() {
          return (/* binding */_ObserveOnOperator
          );
        },
        /* harmony export */"ObserveOnSubscriber": function ObserveOnSubscriber() {
          return (/* binding */_ObserveOnSubscriber
          );
        },
        /* harmony export */"ObserveOnMessage": function ObserveOnMessage() {
          return (/* binding */_ObserveOnMessage
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../Subscriber */71003);
      /* harmony import */
      var _Notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ../Notification */93621);
      function _observeOn(scheduler) {
        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return function observeOnOperatorFunction(source) {
          return source.lift(new _ObserveOnOperator(scheduler, delay));
        };
      }
      var _ObserveOnOperator = /*#__PURE__*/function () {
        function _ObserveOnOperator(scheduler) {
          var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          _classCallCheck(this, _ObserveOnOperator);
          this.scheduler = scheduler;
          this.delay = delay;
        }
        _createClass(_ObserveOnOperator, [{
          key: "call",
          value: function call(subscriber, source) {
            return source.subscribe(new _ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
          }
        }]);
        return _ObserveOnOperator;
      }();
      var _ObserveOnSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_) {
        _inherits(_ObserveOnSubscriber, _Subscriber__WEBPACK_);
        var _super20 = _createSuper(_ObserveOnSubscriber);
        function _ObserveOnSubscriber(destination, scheduler) {
          var _this70;
          var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          _classCallCheck(this, _ObserveOnSubscriber);
          _this70 = _super20.call(this, destination);
          _this70.scheduler = scheduler;
          _this70.delay = delay;
          return _this70;
        }
        _createClass(_ObserveOnSubscriber, [{
          key: "scheduleMessage",
          value: function scheduleMessage(notification) {
            var destination = this.destination;
            destination.add(this.scheduler.schedule(_ObserveOnSubscriber.dispatch, this.delay, new _ObserveOnMessage(notification, this.destination)));
          }
        }, {
          key: "_next",
          value: function _next(value) {
            this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__.Notification.createNext(value));
          }
        }, {
          key: "_error",
          value: function _error(err) {
            this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__.Notification.createError(err));
            this.unsubscribe();
          }
        }, {
          key: "_complete",
          value: function _complete() {
            this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__.Notification.createComplete());
            this.unsubscribe();
          }
        }], [{
          key: "dispatch",
          value: function dispatch(arg) {
            var notification = arg.notification,
              destination = arg.destination;
            notification.observe(destination);
            this.unsubscribe();
          }
        }]);
        return _ObserveOnSubscriber;
      }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber);
      var _ObserveOnMessage = /*#__PURE__*/_createClass(function _ObserveOnMessage(notification, destination) {
        _classCallCheck(this, _ObserveOnMessage);
        this.notification = notification;
        this.destination = destination;
      });
      /***/
    },
    /***/15347:
    /*!*******************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/operators/pairwise.js ***!
      \*******************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"pairwise": function pairwise() {
          return (/* binding */_pairwise
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../Subscriber */71003);
      function _pairwise() {
        return function (source) {
          return source.lift(new PairwiseOperator());
        };
      }
      var PairwiseOperator = /*#__PURE__*/function () {
        function PairwiseOperator() {
          _classCallCheck(this, PairwiseOperator);
        }
        _createClass(PairwiseOperator, [{
          key: "call",
          value: function call(subscriber, source) {
            return source.subscribe(new PairwiseSubscriber(subscriber));
          }
        }]);
        return PairwiseOperator;
      }();
      var PairwiseSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_2) {
        _inherits(PairwiseSubscriber, _Subscriber__WEBPACK_2);
        var _super21 = _createSuper(PairwiseSubscriber);
        function PairwiseSubscriber(destination) {
          var _this71;
          _classCallCheck(this, PairwiseSubscriber);
          _this71 = _super21.call(this, destination);
          _this71.hasPrev = false;
          return _this71;
        }
        _createClass(PairwiseSubscriber, [{
          key: "_next",
          value: function _next(value) {
            var pair;
            if (this.hasPrev) {
              pair = [this.prev, value];
            } else {
              this.hasPrev = true;
            }
            this.prev = value;
            if (pair) {
              this.destination.next(pair);
            }
          }
        }]);
        return PairwiseSubscriber;
      }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber);
      /***/
    },
    /***/92597:
    /*!**********************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js ***!
      \**********************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"shareReplay": function shareReplay() {
          return (/* binding */_shareReplay
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../ReplaySubject */13413);
      function _shareReplay(configOrBufferSize, windowTime, scheduler) {
        var config;
        if (configOrBufferSize && typeof configOrBufferSize === 'object') {
          config = configOrBufferSize;
        } else {
          config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler
          };
        }
        return function (source) {
          return source.lift(shareReplayOperator(config));
        };
      }
      function shareReplayOperator(_ref10) {
        var _ref10$bufferSize = _ref10.bufferSize,
          bufferSize = _ref10$bufferSize === void 0 ? Number.POSITIVE_INFINITY : _ref10$bufferSize,
          _ref10$windowTime = _ref10.windowTime,
          windowTime = _ref10$windowTime === void 0 ? Number.POSITIVE_INFINITY : _ref10$windowTime,
          useRefCount = _ref10.refCount,
          scheduler = _ref10.scheduler;
        var subject;
        var refCount = 0;
        var subscription;
        var hasError = false;
        var isComplete = false;
        return function shareReplayOperation(source) {
          refCount++;
          var innerSub;
          if (!subject || hasError) {
            hasError = false;
            subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__.ReplaySubject(bufferSize, windowTime, scheduler);
            innerSub = subject.subscribe(this);
            subscription = source.subscribe({
              next: function next(value) {
                subject.next(value);
              },
              error: function error(err) {
                hasError = true;
                subject.error(err);
              },
              complete: function complete() {
                isComplete = true;
                subscription = undefined;
                subject.complete();
              }
            });
            if (isComplete) {
              subscription = undefined;
            }
          } else {
            innerSub = subject.subscribe(this);
          }
          this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            innerSub = undefined;
            if (subscription && !isComplete && useRefCount && refCount === 0) {
              subscription.unsubscribe();
              subscription = undefined;
              subject = undefined;
            }
          });
        };
      }

      /***/
    },

    /***/18511:
    /*!********************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/operators/takeWhile.js ***!
      \********************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"takeWhile": function takeWhile() {
          return (/* binding */_takeWhile
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../Subscriber */71003);
      function _takeWhile(predicate) {
        var inclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return function (source) {
          return source.lift(new TakeWhileOperator(predicate, inclusive));
        };
      }
      var TakeWhileOperator = /*#__PURE__*/function () {
        function TakeWhileOperator(predicate, inclusive) {
          _classCallCheck(this, TakeWhileOperator);
          this.predicate = predicate;
          this.inclusive = inclusive;
        }
        _createClass(TakeWhileOperator, [{
          key: "call",
          value: function call(subscriber, source) {
            return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
          }
        }]);
        return TakeWhileOperator;
      }();
      var TakeWhileSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_3) {
        _inherits(TakeWhileSubscriber, _Subscriber__WEBPACK_3);
        var _super22 = _createSuper(TakeWhileSubscriber);
        function TakeWhileSubscriber(destination, predicate, inclusive) {
          var _this72;
          _classCallCheck(this, TakeWhileSubscriber);
          _this72 = _super22.call(this, destination);
          _this72.predicate = predicate;
          _this72.inclusive = inclusive;
          _this72.index = 0;
          return _this72;
        }
        _createClass(TakeWhileSubscriber, [{
          key: "_next",
          value: function _next(value) {
            var destination = this.destination;
            var result;
            try {
              result = this.predicate(value, this.index++);
            } catch (err) {
              destination.error(err);
              return;
            }
            this.nextOrComplete(value, result);
          }
        }, {
          key: "nextOrComplete",
          value: function nextOrComplete(value, predicateResult) {
            var destination = this.destination;
            if (Boolean(predicateResult)) {
              destination.next(value);
            } else {
              if (this.inclusive) {
                destination.next(value);
              }
              destination.complete();
            }
          }
        }]);
        return TakeWhileSubscriber;
      }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber);
      /***/
    },
    /***/9862:
    /*!*******************************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameAction.js ***!
      \*******************************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"AnimationFrameAction": function AnimationFrameAction() {
          return (/* binding */_AnimationFrameAction
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./AsyncAction */23115);
      var _AnimationFrameAction = /*#__PURE__*/function (_AsyncAction__WEBPACK) {
        _inherits(_AnimationFrameAction, _AsyncAction__WEBPACK);
        var _super23 = _createSuper(_AnimationFrameAction);
        function _AnimationFrameAction(scheduler, work) {
          var _this73;
          _classCallCheck(this, _AnimationFrameAction);
          _this73 = _super23.call(this, scheduler, work);
          _this73.scheduler = scheduler;
          _this73.work = work;
          return _this73;
        }
        _createClass(_AnimationFrameAction, [{
          key: "requestAsyncId",
          value: function requestAsyncId(scheduler, id) {
            var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            if (delay !== null && delay > 0) {
              return _get(_getPrototypeOf(_AnimationFrameAction.prototype), "requestAsyncId", this).call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () {
              return scheduler.flush(null);
            }));
          }
        }, {
          key: "recycleAsyncId",
          value: function recycleAsyncId(scheduler, id) {
            var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
              return _get(_getPrototypeOf(_AnimationFrameAction.prototype), "recycleAsyncId", this).call(this, scheduler, id, delay);
            }
            if (scheduler.actions.length === 0) {
              cancelAnimationFrame(id);
              scheduler.scheduled = undefined;
            }
            return undefined;
          }
        }]);
        return _AnimationFrameAction;
      }(_AsyncAction__WEBPACK_IMPORTED_MODULE_0__.AsyncAction);
      /***/
    },
    /***/98028:
    /*!**********************************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameScheduler.js ***!
      \**********************************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"AnimationFrameScheduler": function AnimationFrameScheduler() {
          return (/* binding */_AnimationFrameScheduler
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./AsyncScheduler */16367);
      var _AnimationFrameScheduler = /*#__PURE__*/function (_AsyncScheduler__WEBP) {
        _inherits(_AnimationFrameScheduler, _AsyncScheduler__WEBP);
        var _super24 = _createSuper(_AnimationFrameScheduler);
        function _AnimationFrameScheduler() {
          _classCallCheck(this, _AnimationFrameScheduler);
          return _super24.apply(this, arguments);
        }
        _createClass(_AnimationFrameScheduler, [{
          key: "flush",
          value: function flush(action) {
            this.active = true;
            this.scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            var count = actions.length;
            action = action || actions.shift();
            do {
              if (error = action.execute(action.state, action.delay)) {
                break;
              }
            } while (++index < count && (action = actions.shift()));
            this.active = false;
            if (error) {
              while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
              }
              throw error;
            }
          }
        }]);
        return _AnimationFrameScheduler;
      }(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__.AsyncScheduler);
      /***/
    },
    /***/20959:
    /*!*********************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/scheduler/AsapAction.js ***!
      \*********************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"AsapAction": function AsapAction() {
          return (/* binding */_AsapAction
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _util_Immediate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ../util/Immediate */45429);
      /* harmony import */
      var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./AsyncAction */23115);
      var _AsapAction = /*#__PURE__*/function (_AsyncAction__WEBPACK2) {
        _inherits(_AsapAction, _AsyncAction__WEBPACK2);
        var _super25 = _createSuper(_AsapAction);
        function _AsapAction(scheduler, work) {
          var _this74;
          _classCallCheck(this, _AsapAction);
          _this74 = _super25.call(this, scheduler, work);
          _this74.scheduler = scheduler;
          _this74.work = work;
          return _this74;
        }
        _createClass(_AsapAction, [{
          key: "requestAsyncId",
          value: function requestAsyncId(scheduler, id) {
            var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            if (delay !== null && delay > 0) {
              return _get(_getPrototypeOf(_AsapAction.prototype), "requestAsyncId", this).call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler.scheduled || (scheduler.scheduled = _util_Immediate__WEBPACK_IMPORTED_MODULE_1__.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
          }
        }, {
          key: "recycleAsyncId",
          value: function recycleAsyncId(scheduler, id) {
            var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
              return _get(_getPrototypeOf(_AsapAction.prototype), "recycleAsyncId", this).call(this, scheduler, id, delay);
            }
            if (scheduler.actions.length === 0) {
              _util_Immediate__WEBPACK_IMPORTED_MODULE_1__.Immediate.clearImmediate(id);
              scheduler.scheduled = undefined;
            }
            return undefined;
          }
        }]);
        return _AsapAction;
      }(_AsyncAction__WEBPACK_IMPORTED_MODULE_0__.AsyncAction);
      /***/
    },
    /***/6346:
    /*!************************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/scheduler/AsapScheduler.js ***!
      \************************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"AsapScheduler": function AsapScheduler() {
          return (/* binding */_AsapScheduler
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./AsyncScheduler */16367);
      var _AsapScheduler = /*#__PURE__*/function (_AsyncScheduler__WEBP2) {
        _inherits(_AsapScheduler, _AsyncScheduler__WEBP2);
        var _super26 = _createSuper(_AsapScheduler);
        function _AsapScheduler() {
          _classCallCheck(this, _AsapScheduler);
          return _super26.apply(this, arguments);
        }
        _createClass(_AsapScheduler, [{
          key: "flush",
          value: function flush(action) {
            this.active = true;
            this.scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            var count = actions.length;
            action = action || actions.shift();
            do {
              if (error = action.execute(action.state, action.delay)) {
                break;
              }
            } while (++index < count && (action = actions.shift()));
            this.active = false;
            if (error) {
              while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
              }
              throw error;
            }
          }
        }]);
        return _AsapScheduler;
      }(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__.AsyncScheduler);
      /***/
    },
    /***/97004:
    /*!**********************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js ***!
      \**********************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"QueueAction": function QueueAction() {
          return (/* binding */_QueueAction
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./AsyncAction */23115);
      var _QueueAction = /*#__PURE__*/function (_AsyncAction__WEBPACK3) {
        _inherits(_QueueAction, _AsyncAction__WEBPACK3);
        var _super27 = _createSuper(_QueueAction);
        function _QueueAction(scheduler, work) {
          var _this75;
          _classCallCheck(this, _QueueAction);
          _this75 = _super27.call(this, scheduler, work);
          _this75.scheduler = scheduler;
          _this75.work = work;
          return _this75;
        }
        _createClass(_QueueAction, [{
          key: "schedule",
          value: function schedule(state) {
            var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            if (delay > 0) {
              return _get(_getPrototypeOf(_QueueAction.prototype), "schedule", this).call(this, state, delay);
            }
            this.delay = delay;
            this.state = state;
            this.scheduler.flush(this);
            return this;
          }
        }, {
          key: "execute",
          value: function execute(state, delay) {
            return delay > 0 || this.closed ? _get(_getPrototypeOf(_QueueAction.prototype), "execute", this).call(this, state, delay) : this._execute(state, delay);
          }
        }, {
          key: "requestAsyncId",
          value: function requestAsyncId(scheduler, id) {
            var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
              return _get(_getPrototypeOf(_QueueAction.prototype), "requestAsyncId", this).call(this, scheduler, id, delay);
            }
            return scheduler.flush(this);
          }
        }]);
        return _QueueAction;
      }(_AsyncAction__WEBPACK_IMPORTED_MODULE_0__.AsyncAction);
      /***/
    },
    /***/66018:
    /*!*************************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js ***!
      \*************************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"QueueScheduler": function QueueScheduler() {
          return (/* binding */_QueueScheduler
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./AsyncScheduler */16367);
      var _QueueScheduler = /*#__PURE__*/function (_AsyncScheduler__WEBP3) {
        _inherits(_QueueScheduler, _AsyncScheduler__WEBP3);
        var _super28 = _createSuper(_QueueScheduler);
        function _QueueScheduler() {
          _classCallCheck(this, _QueueScheduler);
          return _super28.apply(this, arguments);
        }
        return _createClass(_QueueScheduler);
      }(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__.AsyncScheduler);
      /***/
    },
    /***/90970:
    /*!*************************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js ***!
      \*************************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"animationFrameScheduler": function animationFrameScheduler() {
          return (/* binding */_animationFrameScheduler
          );
        },
        /* harmony export */"animationFrame": function animationFrame() {
          return (/* binding */_animationFrame
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _AnimationFrameAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./AnimationFrameAction */9862);
      /* harmony import */
      var _AnimationFrameScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./AnimationFrameScheduler */98028);
      var _animationFrameScheduler = new _AnimationFrameScheduler__WEBPACK_IMPORTED_MODULE_0__.AnimationFrameScheduler(_AnimationFrameAction__WEBPACK_IMPORTED_MODULE_1__.AnimationFrameAction);
      var _animationFrame = _animationFrameScheduler;

      /***/
    },

    /***/36317:
    /*!***************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/scheduler/asap.js ***!
      \***************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"asapScheduler": function asapScheduler() {
          return (/* binding */_asapScheduler
          );
        },
        /* harmony export */"asap": function asap() {
          return (/* binding */_asap
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _AsapAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./AsapAction */20959);
      /* harmony import */
      var _AsapScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./AsapScheduler */6346);
      var _asapScheduler = new _AsapScheduler__WEBPACK_IMPORTED_MODULE_0__.AsapScheduler(_AsapAction__WEBPACK_IMPORTED_MODULE_1__.AsapAction);
      var _asap = _asapScheduler;

      /***/
    },

    /***/75751:
    /*!****************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/scheduler/queue.js ***!
      \****************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"queueScheduler": function queueScheduler() {
          return (/* binding */_queueScheduler
          );
        },
        /* harmony export */"queue": function queue() {
          return (/* binding */_queue
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _QueueAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./QueueAction */97004);
      /* harmony import */
      var _QueueScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./QueueScheduler */66018);
      var _queueScheduler = new _QueueScheduler__WEBPACK_IMPORTED_MODULE_0__.QueueScheduler(_QueueAction__WEBPACK_IMPORTED_MODULE_1__.QueueAction);
      var _queue = _queueScheduler;

      /***/
    },

    /***/45429:
    /*!***************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/util/Immediate.js ***!
      \***************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"Immediate": function Immediate() {
          return (/* binding */_Immediate
          );
        },
        /* harmony export */"TestTools": function TestTools() {
          return (/* binding */_TestTools
          );
        }
        /* harmony export */
      });
      var nextHandle = 1;
      var RESOLVED = function () {
        return Promise.resolve();
      }();
      var activeHandles = {};
      function findAndClearHandle(handle) {
        if (handle in activeHandles) {
          delete activeHandles[handle];
          return true;
        }
        return false;
      }
      var _Immediate = {
        setImmediate: function setImmediate(cb) {
          var handle = nextHandle++;
          activeHandles[handle] = true;
          RESOLVED.then(function () {
            return findAndClearHandle(handle) && cb();
          });
          return handle;
        },
        clearImmediate: function clearImmediate(handle) {
          findAndClearHandle(handle);
        }
      };
      var _TestTools = {
        pending: function pending() {
          return Object.keys(activeHandles).length;
        }
      };

      /***/
    },

    /***/82867:
    /*!***************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/util/isNumeric.js ***!
      \***************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"isNumeric": function isNumeric() {
          return (/* binding */_isNumeric
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./isArray */49861);
      function _isNumeric(val) {
        return !(0, _isArray__WEBPACK_IMPORTED_MODULE_0__.isArray)(val) && val - parseFloat(val) + 1 >= 0;
      }

      /***/
    },

    /***/64674:
    /*!******************************************************************!*\
      !*** ./node_modules/rxjs/_esm2015/internal/util/isObservable.js ***!
      \******************************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"isObservable": function isObservable() {
          return (/* binding */_isObservable
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../Observable */25160);
      function _isObservable(obj) {
        return !!obj && (obj instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable || typeof obj.lift === 'function' && typeof obj.subscribe === 'function');
      }

      /***/
    },

    /***/82682:
    /*!*************************************************!*\
      !*** ./src/app/complex/complex-portal-utils.ts ***!
      \*************************************************/
    /***/
    function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */"interactorTypeIcon": function interactorTypeIcon() {
          return (/* binding */_interactorTypeIcon
          );
        },
        /* harmony export */"organismIcon": function organismIcon() {
          return (/* binding */_organismIcon
          );
        },
        /* harmony export */"ecoCodeName": function ecoCodeName() {
          return (/* binding */_ecoCodeName
          );
        },
        /* harmony export */"ecoCodeSymbol": function ecoCodeSymbol() {
          return (/* binding */_ecoCodeSymbol
          );
        }
        /* harmony export */
      });
      function _interactorTypeIcon(type) {
        switch (type) {
          case 'small molecule':
            return 'icon icon-conceptual icon-chemical';
          case 'protein':
          case 'peptide':
            return 'icon icon-conceptual icon-structures-3d';
          case 'stable complex':
            return 'icon icon-conceptual icon-systems';
          case 'molecule set':
            return 'icon icon-generic icon-math';
          case 'single stranded deoxyribonucleic acid':
          case 'double stranded deoxyribonucleic acid':
          case 'small nuclear rna':
          case 'small nucleolar rna':
          case 'ribosomal rna':
          case 'messenger rna':
          case 'transfer rna':
          case 'signal recognition particle rna':
          case 'ribonucleic acid':
          case 'nucleic acid':
          case 'long non-coding ribonucleic acid':
            return 'icon icon-conceptual icon-dna';
        }
      }
      function _organismIcon(organism) {
        var formattedName = formatOrganismName(organism);
        switch (formattedName) {
          case 'Homo sapiens':
            return 'icon icon-species icon-human';
          case 'Mus musculus':
            return 'icon icon-species icon-mouse';
          case 'Schizosaccharomyces pombe':
          case 'Saccharomyces cerevisiae':
            return 'icon icon-species icon-yeast';
          case 'Escherichia coli':
          case 'Pseudomonas aeruginosa':
            return 'icon icon-species icon-ecoli';
          case 'Rattus norvegicus':
            return 'icon icon-species icon-rat';
          case 'Caenorhabditis elegans':
            return 'icon icon-species icon-c-elegans';
          case 'Gallus gallus':
            return 'icon icon-species icon-chicken';
          case 'Drosophila melanogaster':
            return 'icon icon-species icon-fly';
          case 'Bos taurus':
            return 'icon icon-species icon-cow';
          case 'Oryctolagus cuniculus':
            return 'icon icon-species icon-rabbit';
          case 'Ovis aries':
            return 'icon icon-species icon-sheep';
          case 'Xenopus laevis':
            return 'icon icon-species icon-frog';
          case 'Canis lupus':
          case 'Canis familiaris':
            return 'icon icon-species icon-dog';
          case 'Vibrio cholerae':
            return 'assets/images/EMBL_Species_Vibrio_cholerae.svg';
          case 'Crotalus durissus':
            return 'assets/images/EMBL_Species_RattleSnake.svg';
          case 'Sus scrofa':
            return 'icon icon-species icon-pig';
          case 'Torpedo marmorata':
          case 'Tetronarce californica':
            return 'icon icon-species icon-ray';
          case 'Lymnaea stagnalis':
            return 'icon icon-species icon-snail';
          case 'Arabidopsis thaliana':
            return 'icon icon-species icon-brassica';
          case 'Danio rerio':
            return 'icon icon-species icon-zebrafish';
          case 'Severe acute':
          case 'Human SARS':
          case 'SARS-CoV-2':
          case 'Middle East':
          case 'Human betacoronavirus':
            return 'icon icon-species icon-virus';
        }
        return '';
      }
      function _ecoCodeName(ecoCode) {
        switch (ecoCode) {
          case 'ECO:0005547':
            return 'inferred by curator';
          case 'ECO:0000353':
            return 'physical interaction evidence';
          case 'ECO:0005610':
            return 'inferred by homology';
          case 'ECO:0005544':
            return 'inferred by orthology';
          case 'ECO:0005546':
            return 'inferred by paralogy';
          case 'ECO:0005543':
            return 'inferred from mixed species evidence';
          case 'ECO:0005542':
            return 'inferred from single species evidence';
          // TODO: review new ECO code labels below
          //  two new ones for UniPlex import and other existing ones that had no label set yet
          case 'ECO:0000269':
            return 'experimental evidence used in manual assertion';
          case 'ECO:0000314':
            return 'direct assay evidence used in manual assertion';
          case 'ECO:0007653':
            return 'automatically integrated combinatorial prediction';
          case 'ECO:0008004':
            return 'machine learning prediction';
          case 'ECO:0008006':
            return 'deep learning prediction';
          default:
            return null;
        }
      }
      function _ecoCodeSymbol(ecoCode) {
        switch (ecoCode) {
          case 'ECO:0005547':
            return 'B';
          // Empty
          case 'ECO:0000353':
          case 'ECO:0005543':
          case 'ECO:0005542':
            return 'E';
          // Full
          case 'ECO:0005610':
          case 'ECO:0005544':
          case 'ECO:0005546':
            return 'C';
          // 40%
          case 'ECO:0008006':
          case 'ECO:0007653':
          case 'ECO:0008004':
            return '';
          // Chip
          // TODO: what icon should we use for the two ECO codes below?
          case 'ECO:0000314':
          case 'ECO:0000269':
          default:
            return null;
        }
      }
      function formatOrganismName(name) {
        return (name || '?').split(';')[0].split(' ').slice(0, 2).join(' ');
      }

      /***/
    }
  }]);
})();
//# sourceMappingURL=default-node_modules_angular_material___ivy_ngcc___fesm2015_tooltip_js-src_app_complex_comple-8a6e67-es5.js.map